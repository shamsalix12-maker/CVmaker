id: B26
name: "Markdown File Generator"
phase: 4
phase_name: "Export & Templates"

goal: |
  Create a system to generate and export Markdown (.md) files.
  Also includes HTML to Markdown conversion for content from the editor.
  API route for Markdown export.

dependencies: [B01, B02, B03, B04, B25]

files_to_create:
  - id: F076
    path: "src/lib/generators/markdown-generator.ts"
    description: "Markdown generation and conversion logic"

  - id: F026
    path: "src/app/api/export/markdown/route.ts"
    description: "API route for Markdown export"

files_to_modify:
  - id: F144
    path: "src/lib/generators/index.ts"
    description: "Add markdown generator export"

files_available:
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F144
    path: "src/lib/generators/index.ts"
    from_block: B25

commands: []

instructions: |
  1. Create markdown-generator.ts:
     ```typescript
     // ============================================
     // [F076] src/lib/generators/markdown-generator.ts
     // ============================================
     
     export type DocumentType = 'cv' | 'cover_letter' | 'email';
     
     export interface GenerateMarkdownOptions {
       content: string;
       type: DocumentType;
       title?: string;
       includeMetadata?: boolean;
       metadata?: {
         author?: string;
         date?: string;
         company?: string;
         jobTitle?: string;
       };
     }
     
     // Convert HTML to Markdown
     export function htmlToMarkdown(html: string): string {
       let markdown = html;
       
       // Remove extra whitespace
       markdown = markdown.replace(/\s+/g, ' ');
       
       // Headers
       markdown = markdown.replace(/<h1[^>]*>(.*?)<\/h1>/gi, '\n# $1\n');
       markdown = markdown.replace(/<h2[^>]*>(.*?)<\/h2>/gi, '\n## $1\n');
       markdown = markdown.replace(/<h3[^>]*>(.*?)<\/h3>/gi, '\n### $1\n');
       markdown = markdown.replace(/<h4[^>]*>(.*?)<\/h4>/gi, '\n#### $1\n');
       markdown = markdown.replace(/<h5[^>]*>(.*?)<\/h5>/gi, '\n##### $1\n');
       markdown = markdown.replace(/<h6[^>]*>(.*?)<\/h6>/gi, '\n###### $1\n');
       
       // Bold and italic
       markdown = markdown.replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**');
       markdown = markdown.replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**');
       markdown = markdown.replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*');
       markdown = markdown.replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*');
       
       // Links
       markdown = markdown.replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)');
       
       // Line breaks and paragraphs
       markdown = markdown.replace(/<br\s*\/?>/gi, '\n');
       markdown = markdown.replace(/<\/p>/gi, '\n\n');
       markdown = markdown.replace(/<p[^>]*>/gi, '');
       
       // Lists
       markdown = markdown.replace(/<ul[^>]*>/gi, '\n');
       markdown = markdown.replace(/<\/ul>/gi, '\n');
       markdown = markdown.replace(/<ol[^>]*>/gi, '\n');
       markdown = markdown.replace(/<\/ol>/gi, '\n');
       markdown = markdown.replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n');
       
       // Blockquotes
       markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gi, '\n> $1\n');
       
       // Code
       markdown = markdown.replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`');
       markdown = markdown.replace(/<pre[^>]*>(.*?)<\/pre>/gi, '\n```\n$1\n```\n');
       
       // Horizontal rule
       markdown = markdown.replace(/<hr\s*\/?>/gi, '\n---\n');
       
       // Remove remaining HTML tags
       markdown = markdown.replace(/<[^>]+>/g, '');
       
       // Decode HTML entities
       markdown = markdown.replace(/&nbsp;/g, ' ');
       markdown = markdown.replace(/&amp;/g, '&');
       markdown = markdown.replace(/&lt;/g, '<');
       markdown = markdown.replace(/&gt;/g, '>');
       markdown = markdown.replace(/&quot;/g, '"');
       markdown = markdown.replace(/&#39;/g, "'");
       
       // Clean up extra newlines
       markdown = markdown.replace(/\n{3,}/g, '\n\n');
       markdown = markdown.trim();
       
       return markdown;
     }
     
     // Clean and normalize content
     function normalizeContent(content: string): string {
       // Check if content is HTML
       if (content.includes('<') && content.includes('>')) {
         return htmlToMarkdown(content);
       }
       return content;
     }
     
     // Generate frontmatter for metadata
     function generateFrontmatter(options: GenerateMarkdownOptions): string {
       if (!options.includeMetadata || !options.metadata) {
         return '';
       }
       
       const lines = ['---'];
       
       if (options.title) {
         lines.push(`title: "${options.title}"`);
       }
       if (options.metadata.author) {
         lines.push(`author: "${options.metadata.author}"`);
       }
       if (options.metadata.date) {
         lines.push(`date: "${options.metadata.date}"`);
       } else {
         lines.push(`date: "${new Date().toISOString().split('T')[0]}"`);
       }
       if (options.metadata.company) {
         lines.push(`company: "${options.metadata.company}"`);
       }
       if (options.metadata.jobTitle) {
         lines.push(`job_title: "${options.metadata.jobTitle}"`);
       }
       lines.push(`type: "${options.type}"`);
       lines.push('---\n');
       
       return lines.join('\n');
     }
     
     // Generate CV markdown with structure
     function generateCVMarkdown(content: string, options: GenerateMarkdownOptions): string {
       const normalized = normalizeContent(content);
       const frontmatter = generateFrontmatter(options);
       
       return `${frontmatter}${normalized}`;
     }
     
     // Generate Cover Letter markdown
     function generateCoverLetterMarkdown(content: string, options: GenerateMarkdownOptions): string {
       const normalized = normalizeContent(content);
       const frontmatter = generateFrontmatter(options);
       
       const date = new Date().toLocaleDateString('en-US', {
         year: 'numeric',
         month: 'long',
         day: 'numeric',
       });
       
       return `${frontmatter}${date}\n\n${normalized}`;
     }
     
     // Generate Email markdown
     function generateEmailMarkdown(content: string, options: GenerateMarkdownOptions): string {
       const normalized = normalizeContent(content);
       const frontmatter = generateFrontmatter(options);
       
       return `${frontmatter}${normalized}`;
     }
     
     // Main export function
     export function generateMarkdown(options: GenerateMarkdownOptions): string {
       switch (options.type) {
         case 'cv':
           return generateCVMarkdown(options.content, options);
         case 'cover_letter':
           return generateCoverLetterMarkdown(options.content, options);
         case 'email':
           return generateEmailMarkdown(options.content, options);
         default:
           return generateCVMarkdown(options.content, options);
       }
     }
     
     // Convert markdown to plain text (for AI processing)
     export function markdownToPlainText(markdown: string): string {
       let text = markdown;
       
       // Remove frontmatter
       text = text.replace(/^---[\s\S]*?---\n*/m, '');
       
       // Remove headers markers but keep text
       text = text.replace(/^#{1,6}\s+/gm, '');
       
       // Remove bold/italic markers
       text = text.replace(/\*\*(.*?)\*\*/g, '$1');
       text = text.replace(/\*(.*?)\*/g, '$1');
       text = text.replace(/__(.*?)__/g, '$1');
       text = text.replace(/_(.*?)_/g, '$1');
       
       // Remove link formatting, keep text
       text = text.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
       
       // Remove code formatting
       text = text.replace(/`{1,3}[^`]*`{1,3}/g, '');
       
       // Remove horizontal rules
       text = text.replace(/^---+$/gm, '');
       
       // Remove blockquote markers
       text = text.replace(/^>\s*/gm, '');
       
       // Remove list markers
       text = text.replace(/^[-*+]\s+/gm, '');
       text = text.replace(/^\d+\.\s+/gm, '');
       
       // Clean up whitespace
       text = text.replace(/\n{3,}/g, '\n\n');
       text = text.trim();
       
       return text;
     }
     
     // Generate all documents as markdown object
     export function generateAllMarkdown(
       documents: {
         cv: string;
         coverLetter: string;
         email: string;
       },
       options?: Partial<GenerateMarkdownOptions>
     ): {
       cv: string;
       coverLetter: string;
       email: string;
     } {
       return {
         cv: generateMarkdown({ ...options, content: documents.cv, type: 'cv' }),
         coverLetter: generateMarkdown({ ...options, content: documents.coverLetter, type: 'cover_letter' }),
         email: generateMarkdown({ ...options, content: documents.email, type: 'email' }),
       };
     }
     ```

  2. Create API route for Markdown export:
     ```typescript
     // ============================================
     // [F026] src/app/api/export/markdown/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { generateMarkdown, DocumentType } from '@/lib/generators/markdown-generator';
     
     export async function POST(request: NextRequest) {
       try {
         const body = await request.json();
         const { content, type, filename, includeMetadata, metadata } = body;
         
         if (!content) {
           return NextResponse.json(
             { error: 'Content is required' },
             { status: 400 }
           );
         }
         
         const docType: DocumentType = type || 'cv';
         const markdown = generateMarkdown({
           content,
           type: docType,
           title: filename,
           includeMetadata: includeMetadata ?? false,
           metadata,
         });
         
         const fileName = filename 
           ? `${filename}.md` 
           : `${docType}-${Date.now()}.md`;
         
         return new NextResponse(markdown, {
           status: 200,
           headers: {
             'Content-Type': 'text/markdown; charset=utf-8',
             'Content-Disposition': `attachment; filename="${fileName}"`,
             'Content-Length': Buffer.byteLength(markdown, 'utf8').toString(),
           },
         });
         
       } catch (error: any) {
         console.error('Markdown generation error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to generate markdown' },
           { status: 500 }
         );
       }
     }
     
     // GET - Convert HTML to Markdown (utility endpoint)
     export async function PUT(request: NextRequest) {
       try {
         const body = await request.json();
         const { html } = body;
         
         if (!html) {
           return NextResponse.json(
             { error: 'HTML content is required' },
             { status: 400 }
           );
         }
         
         const { htmlToMarkdown } = await import('@/lib/generators/markdown-generator');
         const markdown = htmlToMarkdown(html);
         
         return NextResponse.json({ markdown });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Conversion failed' },
           { status: 500 }
         );
       }
     }
     ```

  3. Update generators index:
     ```typescript
     // ============================================
     // [F144] src/lib/generators/index.ts (updated)
     // ============================================
     
     export * from './docx-generator';
     export * from './docx-styles';
     export * from './docx-templates';
     export * from './markdown-generator';
     ```

checkpoint_tests:
  - id: T01
    description: "Markdown generator file exists"
    type: "files_exist"
    files:
      - "src/lib/generators/markdown-generator.ts"

  - id: T02
    description: "API route exists"
    type: "files_exist"
    files:
      - "src/app/api/export/markdown/route.ts"

  - id: T03
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T04
    description: "Markdown generator exports main functions"
    type: "grep"
    file: "src/lib/generators/markdown-generator.ts"
    patterns:
      - "export function generateMarkdown"
      - "export function htmlToMarkdown"
      - "export function markdownToPlainText"
      - "generateCVMarkdown"
      - "generateCoverLetterMarkdown"

  - id: T05
    description: "API route handles POST and PUT"
    type: "grep"
    file: "src/app/api/export/markdown/route.ts"
    patterns:
      - "export async function POST"
      - "export async function PUT"
      - "generateMarkdown"
      - "Content-Disposition"

  - id: T06
    description: "Index exports markdown generator"
    type: "grep"
    file: "src/lib/generators/index.ts"
    patterns:
      - "markdown-generator"

max_retries: 3