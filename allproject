
بلوک‌های B25 تا B30
B25.yaml — سیستم تولید فایل Word (DOCX Generator)
YAML

# blocks/B25.yaml

id: B25
name: "DOCX File Generator"
phase: 4
phase_name: "Export & Templates"

goal: |
  Create a system to generate formatted Word (.docx) files from document content.
  This includes API routes for exporting CV, cover letter, and email as Word files.
  Uses the 'docx' library to create professional, formatted documents.

dependencies: [B01, B02, B03, B04, B05, B06]

files_to_create:
  - id: F075
    path: "src/lib/generators/docx-generator.ts"
    description: "Core DOCX generation logic"

  - id: F142
    path: "src/lib/generators/docx-styles.ts"
    description: "Predefined styles for DOCX documents"

  - id: F143
    path: "src/lib/generators/docx-templates.ts"
    description: "Document templates for CV, cover letter, email"

  - id: F025
    path: "src/app/api/export/docx/route.ts"
    description: "API route for DOCX export"

  - id: F144
    path: "src/lib/generators/index.ts"
    description: "Export all generator modules"

files_to_modify: []

files_available:
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F080
    path: "src/lib/utils.ts"
    from_block: B04

commands: []

instructions: |
  1. Create docx-styles.ts:
     ```typescript
     // ============================================
     // [F142] src/lib/generators/docx-styles.ts
     // ============================================
     
     import {
       HeadingLevel,
       AlignmentType,
       TabStopPosition,
       TabStopType,
       convertInchesToTwip,
       BorderStyle,
     } from 'docx';
     
     // Color palette
     export const COLORS = {
       primary: '2563EB',      // Blue
       secondary: '64748B',    // Slate
       text: '1E293B',         // Dark slate
       lightText: '64748B',    // Light slate
       accent: '0EA5E9',       // Sky blue
       border: 'E2E8F0',       // Light border
       background: 'F8FAFC',   // Light background
     };
     
     // Font sizes in half-points (1 point = 2 half-points)
     export const FONT_SIZES = {
       title: 48,          // 24pt
       heading1: 36,       // 18pt
       heading2: 28,       // 14pt
       heading3: 24,       // 12pt
       body: 22,           // 11pt
       small: 20,          // 10pt
       caption: 18,        // 9pt
     };
     
     // Spacing in twips (1 inch = 1440 twips)
     export const SPACING = {
       paragraph: 240,     // 12pt after paragraph
       section: 480,       // 24pt after section
       line: 276,          // 1.15 line spacing
     };
     
     // Common text run styles
     export const TEXT_STYLES = {
       title: {
         bold: true,
         size: FONT_SIZES.title,
         color: COLORS.text,
         font: 'Calibri',
       },
       heading1: {
         bold: true,
         size: FONT_SIZES.heading1,
         color: COLORS.primary,
         font: 'Calibri',
       },
       heading2: {
         bold: true,
         size: FONT_SIZES.heading2,
         color: COLORS.text,
         font: 'Calibri',
       },
       heading3: {
         bold: true,
         size: FONT_SIZES.heading3,
         color: COLORS.text,
         font: 'Calibri',
       },
       body: {
         size: FONT_SIZES.body,
         color: COLORS.text,
         font: 'Calibri',
       },
       bodyBold: {
         bold: true,
         size: FONT_SIZES.body,
         color: COLORS.text,
         font: 'Calibri',
       },
       subtle: {
         size: FONT_SIZES.small,
         color: COLORS.lightText,
         font: 'Calibri',
       },
       link: {
         size: FONT_SIZES.body,
         color: COLORS.primary,
         font: 'Calibri',
         underline: {},
       },
     };
     
     // Paragraph styles
     export const PARAGRAPH_STYLES = {
       title: {
         alignment: AlignmentType.CENTER,
         spacing: { after: SPACING.paragraph },
       },
       heading: {
         spacing: { before: SPACING.section, after: SPACING.paragraph },
       },
       body: {
         spacing: { after: SPACING.paragraph, line: SPACING.line },
       },
       bullet: {
         spacing: { after: 120, line: SPACING.line },
       },
       contact: {
         alignment: AlignmentType.CENTER,
         spacing: { after: 60 },
       },
     };
     
     // Page margins
     export const PAGE_MARGINS = {
       top: convertInchesToTwip(0.75),
       right: convertInchesToTwip(0.75),
       bottom: convertInchesToTwip(0.75),
       left: convertInchesToTwip(0.75),
     };
     
     // Section properties
     export const SECTION_PROPERTIES = {
       page: {
         margin: PAGE_MARGINS,
       },
     };
     ```

  2. Create docx-templates.ts:
     ```typescript
     // ============================================
     // [F143] src/lib/generators/docx-templates.ts
     // ============================================
     
     import {
       Document,
       Paragraph,
       TextRun,
       HeadingLevel,
       AlignmentType,
       BorderStyle,
       Table,
       TableRow,
       TableCell,
       WidthType,
       Header,
       Footer,
       PageNumber,
       NumberFormat,
     } from 'docx';
     import { TEXT_STYLES, PARAGRAPH_STYLES, SECTION_PROPERTIES, COLORS, SPACING } from './docx-styles';
     
     // Helper to create a styled text run
     export function createTextRun(
       text: string, 
       style: keyof typeof TEXT_STYLES = 'body'
     ): TextRun {
       return new TextRun({
         text,
         ...TEXT_STYLES[style],
       });
     }
     
     // Helper to create a paragraph with runs
     export function createParagraph(
       runs: TextRun | TextRun[],
       options: {
         heading?: HeadingLevel;
         alignment?: AlignmentType;
         spacing?: { before?: number; after?: number };
         bullet?: { level: number };
       } = {}
     ): Paragraph {
       const runsArray = Array.isArray(runs) ? runs : [runs];
       
       return new Paragraph({
         children: runsArray,
         heading: options.heading,
         alignment: options.alignment,
         spacing: options.spacing || PARAGRAPH_STYLES.body.spacing,
         bullet: options.bullet,
       });
     }
     
     // Create section header with line
     export function createSectionHeader(title: string): Paragraph[] {
       return [
         new Paragraph({
           children: [createTextRun(title, 'heading1')],
           spacing: { before: SPACING.section, after: 120 },
           border: {
             bottom: {
               color: COLORS.primary,
               space: 4,
               size: 12,
               style: BorderStyle.SINGLE,
             },
           },
         }),
       ];
     }
     
     // Create contact info line
     export function createContactLine(items: string[]): Paragraph {
       const runs: TextRun[] = [];
       
       items.forEach((item, index) => {
         if (index > 0) {
           runs.push(new TextRun({
             text: '  •  ',
             ...TEXT_STYLES.subtle,
           }));
         }
         runs.push(new TextRun({
           text: item,
           ...TEXT_STYLES.subtle,
         }));
       });
       
       return new Paragraph({
         children: runs,
         alignment: AlignmentType.CENTER,
         spacing: { after: 60 },
       });
     }
     
     // Create experience/education entry
     export function createExperienceEntry(
       title: string,
       subtitle: string,
       dateRange: string,
       description?: string,
       bullets?: string[]
     ): Paragraph[] {
       const paragraphs: Paragraph[] = [];
       
       // Title and date on same line
       paragraphs.push(new Paragraph({
         children: [
           createTextRun(title, 'bodyBold'),
           new TextRun({ text: '\t' }),
           createTextRun(dateRange, 'subtle'),
         ],
         tabStops: [
           {
             type: 'right' as any,
             position: 9360, // Right align at 6.5 inches
           },
         ],
         spacing: { after: 60 },
       }));
       
       // Subtitle (company/institution)
       paragraphs.push(new Paragraph({
         children: [createTextRun(subtitle, 'subtle')],
         spacing: { after: 120 },
       }));
       
       // Description
       if (description) {
         paragraphs.push(new Paragraph({
           children: [createTextRun(description, 'body')],
           spacing: { after: 120 },
         }));
       }
       
       // Bullet points
       if (bullets && bullets.length > 0) {
         bullets.forEach(bullet => {
           paragraphs.push(new Paragraph({
             children: [createTextRun(bullet, 'body')],
             bullet: { level: 0 },
             spacing: { after: 60 },
           }));
         });
       }
       
       return paragraphs;
     }
     
     // Create skills section
     export function createSkillsSection(skills: string[]): Paragraph[] {
       const skillText = skills.join('  •  ');
       
       return [
         ...createSectionHeader('Skills'),
         new Paragraph({
           children: [createTextRun(skillText, 'body')],
           spacing: { after: SPACING.paragraph },
         }),
       ];
     }
     
     // Create footer with page numbers
     export function createFooter(): Footer {
       return new Footer({
         children: [
           new Paragraph({
             alignment: AlignmentType.CENTER,
             children: [
               new TextRun({
                 children: [PageNumber.CURRENT],
                 ...TEXT_STYLES.caption,
               }),
               new TextRun({
                 text: ' / ',
                 ...TEXT_STYLES.caption,
               }),
               new TextRun({
                 children: [PageNumber.TOTAL_PAGES],
                 ...TEXT_STYLES.caption,
               }),
             ],
           }),
         ],
       });
     }
     ```

  3. Create docx-generator.ts:
     ```typescript
     // ============================================
     // [F075] src/lib/generators/docx-generator.ts
     // ============================================
     
     import {
       Document,
       Paragraph,
       TextRun,
       Packer,
       AlignmentType,
       HeadingLevel,
       Header,
       Footer,
       PageNumber,
     } from 'docx';
     import {
       TEXT_STYLES,
       PARAGRAPH_STYLES,
       SECTION_PROPERTIES,
       COLORS,
       SPACING,
     } from './docx-styles';
     import {
       createTextRun,
       createParagraph,
       createSectionHeader,
       createContactLine,
       createExperienceEntry,
       createSkillsSection,
       createFooter,
     } from './docx-templates';
     
     export type DocumentType = 'cv' | 'cover_letter' | 'email';
     
     export interface GenerateDocxOptions {
       content: string;
       type: DocumentType;
       title?: string;
       metadata?: {
         author?: string;
         company?: string;
         jobTitle?: string;
       };
     }
     
     // Parse markdown-like content into paragraphs
     function parseContent(content: string): Paragraph[] {
       const paragraphs: Paragraph[] = [];
       const lines = content.split('\n');
       
       let currentBullets: string[] = [];
       
       const flushBullets = () => {
         if (currentBullets.length > 0) {
           currentBullets.forEach(bullet => {
             paragraphs.push(new Paragraph({
               children: [createTextRun(bullet.replace(/^[-•*]\s*/, ''), 'body')],
               bullet: { level: 0 },
               spacing: { after: 60 },
             }));
           });
           currentBullets = [];
         }
       };
       
       for (const line of lines) {
         const trimmedLine = line.trim();
         
         if (!trimmedLine) {
           flushBullets();
           continue;
         }
         
         // Heading 1: # Title or === underline
         if (trimmedLine.startsWith('# ') || trimmedLine.startsWith('## ')) {
           flushBullets();
           const headingText = trimmedLine.replace(/^#+\s*/, '');
           const level = trimmedLine.startsWith('## ') ? 'heading2' : 'heading1';
           
           if (level === 'heading1') {
             paragraphs.push(...createSectionHeader(headingText));
           } else {
             paragraphs.push(new Paragraph({
               children: [createTextRun(headingText, 'heading2')],
               spacing: { before: SPACING.paragraph, after: 120 },
             }));
           }
           continue;
         }
         
         // Heading 3: ### Subtitle
         if (trimmedLine.startsWith('### ')) {
           flushBullets();
           const headingText = trimmedLine.replace(/^###\s*/, '');
           paragraphs.push(new Paragraph({
             children: [createTextRun(headingText, 'heading3')],
             spacing: { before: 120, after: 60 },
           }));
           continue;
         }
         
         // Bullet points
         if (/^[-•*]\s/.test(trimmedLine)) {
           currentBullets.push(trimmedLine);
           continue;
         }
         
         // Bold text: **text**
         if (trimmedLine.includes('**')) {
           flushBullets();
           const parts = trimmedLine.split(/\*\*(.*?)\*\*/g);
           const runs: TextRun[] = [];
           
           parts.forEach((part, index) => {
             if (index % 2 === 1) {
               // Bold part
               runs.push(createTextRun(part, 'bodyBold'));
             } else if (part) {
               runs.push(createTextRun(part, 'body'));
             }
           });
           
           paragraphs.push(new Paragraph({
             children: runs,
             spacing: { after: SPACING.paragraph },
           }));
           continue;
         }
         
         // Regular paragraph
         flushBullets();
         paragraphs.push(new Paragraph({
           children: [createTextRun(trimmedLine, 'body')],
           spacing: { after: SPACING.paragraph },
         }));
       }
       
       flushBullets();
       return paragraphs;
     }
     
     // Generate CV document
     function generateCVDocument(content: string, options: GenerateDocxOptions): Document {
       const paragraphs = parseContent(content);
       
       return new Document({
         creator: options.metadata?.author || 'CV Tailor',
         title: options.title || 'Tailored CV',
         description: 'CV generated by CV Tailor',
         sections: [
           {
             properties: SECTION_PROPERTIES,
             footers: {
               default: createFooter(),
             },
             children: paragraphs,
           },
         ],
       });
     }
     
     // Generate Cover Letter document
     function generateCoverLetterDocument(content: string, options: GenerateDocxOptions): Document {
       const paragraphs = parseContent(content);
       
       // Add date at the top
       const today = new Date().toLocaleDateString('en-US', {
         year: 'numeric',
         month: 'long',
         day: 'numeric',
       });
       
       const headerParagraphs: Paragraph[] = [
         new Paragraph({
           children: [createTextRun(today, 'body')],
           spacing: { after: SPACING.section },
         }),
       ];
       
       return new Document({
         creator: options.metadata?.author || 'CV Tailor',
         title: options.title || 'Cover Letter',
         description: 'Cover letter generated by CV Tailor',
         sections: [
           {
             properties: SECTION_PROPERTIES,
             children: [...headerParagraphs, ...paragraphs],
           },
         ],
       });
     }
     
     // Generate Email document
     function generateEmailDocument(content: string, options: GenerateDocxOptions): Document {
       const paragraphs = parseContent(content);
       
       return new Document({
         creator: options.metadata?.author || 'CV Tailor',
         title: options.title || 'Application Email',
         description: 'Application email generated by CV Tailor',
         sections: [
           {
             properties: SECTION_PROPERTIES,
             children: paragraphs,
           },
         ],
       });
     }
     
     // Main export function
     export async function generateDocx(options: GenerateDocxOptions): Promise<Buffer> {
       let document: Document;
       
       switch (options.type) {
         case 'cv':
           document = generateCVDocument(options.content, options);
           break;
         case 'cover_letter':
           document = generateCoverLetterDocument(options.content, options);
           break;
         case 'email':
           document = generateEmailDocument(options.content, options);
           break;
         default:
           document = generateCVDocument(options.content, options);
       }
       
       const buffer = await Packer.toBuffer(document);
       return Buffer.from(buffer);
     }
     
     // Generate all three documents as a zip (optional future feature)
     export async function generateAllDocx(
       documents: {
         cv: string;
         coverLetter: string;
         email: string;
       },
       metadata?: GenerateDocxOptions['metadata']
     ): Promise<{
       cv: Buffer;
       coverLetter: Buffer;
       email: Buffer;
     }> {
       const [cv, coverLetter, email] = await Promise.all([
         generateDocx({ content: documents.cv, type: 'cv', metadata }),
         generateDocx({ content: documents.coverLetter, type: 'cover_letter', metadata }),
         generateDocx({ content: documents.email, type: 'email', metadata }),
       ]);
       
       return { cv, coverLetter, email };
     }
     ```

  4. Create API route for DOCX export:
     ```typescript
     // ============================================
     // [F025] src/app/api/export/docx/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { generateDocx, DocumentType } from '@/lib/generators/docx-generator';
     
     export async function POST(request: NextRequest) {
       try {
         const body = await request.json();
         const { content, type, filename, metadata } = body;
         
         if (!content) {
           return NextResponse.json(
             { error: 'Content is required' },
             { status: 400 }
           );
         }
         
         const docType: DocumentType = type || 'cv';
         const buffer = await generateDocx({
           content,
           type: docType,
           title: filename,
           metadata,
         });
         
         const fileName = filename 
           ? `${filename}.docx` 
           : `${docType}-${Date.now()}.docx`;
         
         return new NextResponse(buffer, {
           status: 200,
           headers: {
             'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
             'Content-Disposition': `attachment; filename="${fileName}"`,
             'Content-Length': buffer.length.toString(),
           },
         });
         
       } catch (error: any) {
         console.error('DOCX generation error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to generate document' },
           { status: 500 }
         );
       }
     }
     ```

  5. Create generators index:
     ```typescript
     // ============================================
     // [F144] src/lib/generators/index.ts
     // ============================================
     
     export * from './docx-generator';
     export * from './docx-styles';
     export * from './docx-templates';
     ```

checkpoint_tests:
  - id: T01
    description: "All generator files exist"
    type: "files_exist"
    files:
      - "src/lib/generators/docx-generator.ts"
      - "src/lib/generators/docx-styles.ts"
      - "src/lib/generators/docx-templates.ts"
      - "src/lib/generators/index.ts"

  - id: T02
    description: "API route exists"
    type: "files_exist"
    files:
      - "src/app/api/export/docx/route.ts"

  - id: T03
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T04
    description: "DOCX generator exports main function"
    type: "grep"
    file: "src/lib/generators/docx-generator.ts"
    patterns:
      - "export async function generateDocx"
      - "generateCVDocument"
      - "generateCoverLetterDocument"
      - "generateEmailDocument"
      - "Packer.toBuffer"

  - id: T05
    description: "Styles are properly defined"
    type: "grep"
    file: "src/lib/generators/docx-styles.ts"
    patterns:
      - "TEXT_STYLES"
      - "PARAGRAPH_STYLES"
      - "PAGE_MARGINS"
      - "COLORS"

  - id: T06
    description: "Templates have helper functions"
    type: "grep"
    file: "src/lib/generators/docx-templates.ts"
    patterns:
      - "createTextRun"
      - "createParagraph"
      - "createSectionHeader"
      - "createExperienceEntry"

  - id: T07
    description: "API route handles POST"
    type: "grep"
    file: "src/app/api/export/docx/route.ts"
    patterns:
      - "export async function POST"
      - "generateDocx"
      - "Content-Disposition"

max_retries: 3
B26.yaml — سیستم تولید فایل Markdown
YAML

# blocks/B26.yaml

id: B26
name: "Markdown File Generator"
phase: 4
phase_name: "Export & Templates"

goal: |
  Create a system to generate and export Markdown (.md) files.
  Also includes HTML to Markdown conversion for content from the editor.
  API route for Markdown export.

dependencies: [B01, B02, B03, B04, B25]

files_to_create:
  - id: F076
    path: "src/lib/generators/markdown-generator.ts"
    description: "Markdown generation and conversion logic"

  - id: F026
    path: "src/app/api/export/markdown/route.ts"
    description: "API route for Markdown export"

files_to_modify:
  - id: F144
    path: "src/lib/generators/index.ts"
    description: "Add markdown generator export"

files_available:
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F144
    path: "src/lib/generators/index.ts"
    from_block: B25

commands: []

instructions: |
  1. Create markdown-generator.ts:
     ```typescript
     // ============================================
     // [F076] src/lib/generators/markdown-generator.ts
     // ============================================
     
     export type DocumentType = 'cv' | 'cover_letter' | 'email';
     
     export interface GenerateMarkdownOptions {
       content: string;
       type: DocumentType;
       title?: string;
       includeMetadata?: boolean;
       metadata?: {
         author?: string;
         date?: string;
         company?: string;
         jobTitle?: string;
       };
     }
     
     // Convert HTML to Markdown
     export function htmlToMarkdown(html: string): string {
       let markdown = html;
       
       // Remove extra whitespace
       markdown = markdown.replace(/\s+/g, ' ');
       
       // Headers
       markdown = markdown.replace(/<h1[^>]*>(.*?)<\/h1>/gi, '\n# $1\n');
       markdown = markdown.replace(/<h2[^>]*>(.*?)<\/h2>/gi, '\n## $1\n');
       markdown = markdown.replace(/<h3[^>]*>(.*?)<\/h3>/gi, '\n### $1\n');
       markdown = markdown.replace(/<h4[^>]*>(.*?)<\/h4>/gi, '\n#### $1\n');
       markdown = markdown.replace(/<h5[^>]*>(.*?)<\/h5>/gi, '\n##### $1\n');
       markdown = markdown.replace(/<h6[^>]*>(.*?)<\/h6>/gi, '\n###### $1\n');
       
       // Bold and italic
       markdown = markdown.replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**');
       markdown = markdown.replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**');
       markdown = markdown.replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*');
       markdown = markdown.replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*');
       
       // Links
       markdown = markdown.replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)');
       
       // Line breaks and paragraphs
       markdown = markdown.replace(/<br\s*\/?>/gi, '\n');
       markdown = markdown.replace(/<\/p>/gi, '\n\n');
       markdown = markdown.replace(/<p[^>]*>/gi, '');
       
       // Lists
       markdown = markdown.replace(/<ul[^>]*>/gi, '\n');
       markdown = markdown.replace(/<\/ul>/gi, '\n');
       markdown = markdown.replace(/<ol[^>]*>/gi, '\n');
       markdown = markdown.replace(/<\/ol>/gi, '\n');
       markdown = markdown.replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n');
       
       // Blockquotes
       markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gi, '\n> $1\n');
       
       // Code
       markdown = markdown.replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`');
       markdown = markdown.replace(/<pre[^>]*>(.*?)<\/pre>/gi, '\n```\n$1\n```\n');
       
       // Horizontal rule
       markdown = markdown.replace(/<hr\s*\/?>/gi, '\n---\n');
       
       // Remove remaining HTML tags
       markdown = markdown.replace(/<[^>]+>/g, '');
       
       // Decode HTML entities
       markdown = markdown.replace(/&nbsp;/g, ' ');
       markdown = markdown.replace(/&amp;/g, '&');
       markdown = markdown.replace(/&lt;/g, '<');
       markdown = markdown.replace(/&gt;/g, '>');
       markdown = markdown.replace(/&quot;/g, '"');
       markdown = markdown.replace(/&#39;/g, "'");
       
       // Clean up extra newlines
       markdown = markdown.replace(/\n{3,}/g, '\n\n');
       markdown = markdown.trim();
       
       return markdown;
     }
     
     // Clean and normalize content
     function normalizeContent(content: string): string {
       // Check if content is HTML
       if (content.includes('<') && content.includes('>')) {
         return htmlToMarkdown(content);
       }
       return content;
     }
     
     // Generate frontmatter for metadata
     function generateFrontmatter(options: GenerateMarkdownOptions): string {
       if (!options.includeMetadata || !options.metadata) {
         return '';
       }
       
       const lines = ['---'];
       
       if (options.title) {
         lines.push(`title: "${options.title}"`);
       }
       if (options.metadata.author) {
         lines.push(`author: "${options.metadata.author}"`);
       }
       if (options.metadata.date) {
         lines.push(`date: "${options.metadata.date}"`);
       } else {
         lines.push(`date: "${new Date().toISOString().split('T')[0]}"`);
       }
       if (options.metadata.company) {
         lines.push(`company: "${options.metadata.company}"`);
       }
       if (options.metadata.jobTitle) {
         lines.push(`job_title: "${options.metadata.jobTitle}"`);
       }
       lines.push(`type: "${options.type}"`);
       lines.push('---\n');
       
       return lines.join('\n');
     }
     
     // Generate CV markdown with structure
     function generateCVMarkdown(content: string, options: GenerateMarkdownOptions): string {
       const normalized = normalizeContent(content);
       const frontmatter = generateFrontmatter(options);
       
       return `${frontmatter}${normalized}`;
     }
     
     // Generate Cover Letter markdown
     function generateCoverLetterMarkdown(content: string, options: GenerateMarkdownOptions): string {
       const normalized = normalizeContent(content);
       const frontmatter = generateFrontmatter(options);
       
       const date = new Date().toLocaleDateString('en-US', {
         year: 'numeric',
         month: 'long',
         day: 'numeric',
       });
       
       return `${frontmatter}${date}\n\n${normalized}`;
     }
     
     // Generate Email markdown
     function generateEmailMarkdown(content: string, options: GenerateMarkdownOptions): string {
       const normalized = normalizeContent(content);
       const frontmatter = generateFrontmatter(options);
       
       return `${frontmatter}${normalized}`;
     }
     
     // Main export function
     export function generateMarkdown(options: GenerateMarkdownOptions): string {
       switch (options.type) {
         case 'cv':
           return generateCVMarkdown(options.content, options);
         case 'cover_letter':
           return generateCoverLetterMarkdown(options.content, options);
         case 'email':
           return generateEmailMarkdown(options.content, options);
         default:
           return generateCVMarkdown(options.content, options);
       }
     }
     
     // Convert markdown to plain text (for AI processing)
     export function markdownToPlainText(markdown: string): string {
       let text = markdown;
       
       // Remove frontmatter
       text = text.replace(/^---[\s\S]*?---\n*/m, '');
       
       // Remove headers markers but keep text
       text = text.replace(/^#{1,6}\s+/gm, '');
       
       // Remove bold/italic markers
       text = text.replace(/\*\*(.*?)\*\*/g, '$1');
       text = text.replace(/\*(.*?)\*/g, '$1');
       text = text.replace(/__(.*?)__/g, '$1');
       text = text.replace(/_(.*?)_/g, '$1');
       
       // Remove link formatting, keep text
       text = text.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
       
       // Remove code formatting
       text = text.replace(/`{1,3}[^`]*`{1,3}/g, '');
       
       // Remove horizontal rules
       text = text.replace(/^---+$/gm, '');
       
       // Remove blockquote markers
       text = text.replace(/^>\s*/gm, '');
       
       // Remove list markers
       text = text.replace(/^[-*+]\s+/gm, '');
       text = text.replace(/^\d+\.\s+/gm, '');
       
       // Clean up whitespace
       text = text.replace(/\n{3,}/g, '\n\n');
       text = text.trim();
       
       return text;
     }
     
     // Generate all documents as markdown object
     export function generateAllMarkdown(
       documents: {
         cv: string;
         coverLetter: string;
         email: string;
       },
       options?: Partial<GenerateMarkdownOptions>
     ): {
       cv: string;
       coverLetter: string;
       email: string;
     } {
       return {
         cv: generateMarkdown({ ...options, content: documents.cv, type: 'cv' }),
         coverLetter: generateMarkdown({ ...options, content: documents.coverLetter, type: 'cover_letter' }),
         email: generateMarkdown({ ...options, content: documents.email, type: 'email' }),
       };
     }
     ```

  2. Create API route for Markdown export:
     ```typescript
     // ============================================
     // [F026] src/app/api/export/markdown/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { generateMarkdown, DocumentType } from '@/lib/generators/markdown-generator';
     
     export async function POST(request: NextRequest) {
       try {
         const body = await request.json();
         const { content, type, filename, includeMetadata, metadata } = body;
         
         if (!content) {
           return NextResponse.json(
             { error: 'Content is required' },
             { status: 400 }
           );
         }
         
         const docType: DocumentType = type || 'cv';
         const markdown = generateMarkdown({
           content,
           type: docType,
           title: filename,
           includeMetadata: includeMetadata ?? false,
           metadata,
         });
         
         const fileName = filename 
           ? `${filename}.md` 
           : `${docType}-${Date.now()}.md`;
         
         return new NextResponse(markdown, {
           status: 200,
           headers: {
             'Content-Type': 'text/markdown; charset=utf-8',
             'Content-Disposition': `attachment; filename="${fileName}"`,
             'Content-Length': Buffer.byteLength(markdown, 'utf8').toString(),
           },
         });
         
       } catch (error: any) {
         console.error('Markdown generation error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to generate markdown' },
           { status: 500 }
         );
       }
     }
     
     // GET - Convert HTML to Markdown (utility endpoint)
     export async function PUT(request: NextRequest) {
       try {
         const body = await request.json();
         const { html } = body;
         
         if (!html) {
           return NextResponse.json(
             { error: 'HTML content is required' },
             { status: 400 }
           );
         }
         
         const { htmlToMarkdown } = await import('@/lib/generators/markdown-generator');
         const markdown = htmlToMarkdown(html);
         
         return NextResponse.json({ markdown });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Conversion failed' },
           { status: 500 }
         );
       }
     }
     ```

  3. Update generators index:
     ```typescript
     // ============================================
     // [F144] src/lib/generators/index.ts (updated)
     // ============================================
     
     export * from './docx-generator';
     export * from './docx-styles';
     export * from './docx-templates';
     export * from './markdown-generator';
     ```

checkpoint_tests:
  - id: T01
    description: "Markdown generator file exists"
    type: "files_exist"
    files:
      - "src/lib/generators/markdown-generator.ts"

  - id: T02
    description: "API route exists"
    type: "files_exist"
    files:
      - "src/app/api/export/markdown/route.ts"

  - id: T03
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T04
    description: "Markdown generator exports main functions"
    type: "grep"
    file: "src/lib/generators/markdown-generator.ts"
    patterns:
      - "export function generateMarkdown"
      - "export function htmlToMarkdown"
      - "export function markdownToPlainText"
      - "generateCVMarkdown"
      - "generateCoverLetterMarkdown"

  - id: T05
    description: "API route handles POST and PUT"
    type: "grep"
    file: "src/app/api/export/markdown/route.ts"
    patterns:
      - "export async function POST"
      - "export async function PUT"
      - "generateMarkdown"
      - "Content-Disposition"

  - id: T06
    description: "Index exports markdown generator"
    type: "grep"
    file: "src/lib/generators/index.ts"
    patterns:
      - "markdown-generator"

max_retries: 3
B27.yaml — سیستم مدیریت تمپلیت‌ها
YAML

# blocks/B27.yaml

id: B27
name: "Template Management System"
phase: 4
phase_name: "Export & Templates"

goal: |
  Create a complete template management system that allows users to:
  - Upload custom templates (Word or Markdown)
  - Select templates when generating documents
  - Preview templates
  - Apply templates to generated content
  
  Templates define the visual styling and structure of output documents.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08, B09, B25, B26]

files_to_create:
  # Service Layer
  - id: F145
    path: "src/lib/templates/template-service.ts"
    description: "Template CRUD service"

  - id: F146
    path: "src/lib/templates/template-processor.ts"
    description: "Apply templates to content"

  - id: F147
    path: "src/lib/templates/index.ts"
    description: "Export template modules"

  # API Routes
  - id: F148
    path: "src/app/api/templates/route.ts"
    description: "Templates list and create API"

  - id: F149
    path: "src/app/api/templates/[id]/route.ts"
    description: "Single template CRUD API"

  # React Hook
  - id: F150
    path: "src/hooks/useTemplates.ts"
    description: "React hook for templates"

  # UI Components
  - id: F060
    path: "src/components/templates/TemplateUploader.tsx"
    description: "Upload template component"

  - id: F061
    path: "src/components/templates/TemplateSelector.tsx"
    description: "Select template component"

  - id: F062
    path: "src/components/templates/TemplatePreview.tsx"
    description: "Preview template component"

  - id: F151
    path: "src/components/templates/TemplateCard.tsx"
    description: "Template card display"

  - id: F152
    path: "src/components/templates/TemplateList.tsx"
    description: "List of templates"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add template translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add template translations"

files_available:
  - id: F063
    path: "src/lib/supabase/client.ts"
    from_block: B06
  - id: F064
    path: "src/lib/supabase/server.ts"
    from_block: B06
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F072
    path: "src/lib/parsers/docx-parser.ts"
    from_block: B09
  - id: F073
    path: "src/lib/parsers/markdown-parser.ts"
    from_block: B09
  - id: F090
    path: "src/context/AuthContext.tsx"
    from_block: B07
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F030
    path: "src/components/ui/dialog.tsx"
    from_block: B02

commands: []

instructions: |
  1. Create template-service.ts:
     ```typescript
     // ============================================
     // [F145] src/lib/templates/template-service.ts
     // ============================================
     
     import { SupabaseClient } from '@supabase/supabase-js';
     import { Template, TemplateType, FileFormat } from '@/lib/types';
     
     export class TemplateService {
       constructor(private supabase: SupabaseClient) {}
       
       async getUserTemplates(userId: string): Promise<Template[]> {
         const { data, error } = await this.supabase
           .from('templates')
           .select('*')
           .eq('user_id', userId)
           .order('created_at', { ascending: false });
         
         if (error) throw error;
         return data || [];
       }
       
       async getTemplatesByType(userId: string, type: TemplateType): Promise<Template[]> {
         const { data, error } = await this.supabase
           .from('templates')
           .select('*')
           .eq('user_id', userId)
           .eq('template_type', type)
           .order('created_at', { ascending: false });
         
         if (error) throw error;
         return data || [];
       }
       
       async getTemplate(id: string, userId: string): Promise<Template | null> {
         const { data, error } = await this.supabase
           .from('templates')
           .select('*')
           .eq('id', id)
           .eq('user_id', userId)
           .single();
         
         if (error) {
           if (error.code === 'PGRST116') return null;
           throw error;
         }
         
         return data;
       }
       
       async createTemplate(
         userId: string,
         template: {
           template_name: string;
           template_type: TemplateType;
           file_format: FileFormat;
           file_content: string;
         }
       ): Promise<Template> {
         const { data, error } = await this.supabase
           .from('templates')
           .insert({
             user_id: userId,
             ...template,
           })
           .select()
           .single();
         
         if (error) throw error;
         return data;
       }
       
       async updateTemplate(
         id: string,
         userId: string,
         updates: Partial<Template>
       ): Promise<Template> {
         const { id: _, user_id, created_at, ...validUpdates } = updates as any;
         
         const { data, error } = await this.supabase
           .from('templates')
           .update(validUpdates)
           .eq('id', id)
           .eq('user_id', userId)
           .select()
           .single();
         
         if (error) throw error;
         return data;
       }
       
       async deleteTemplate(id: string, userId: string): Promise<void> {
         const { error } = await this.supabase
           .from('templates')
           .delete()
           .eq('id', id)
           .eq('user_id', userId);
         
         if (error) throw error;
       }
     }
     
     export function createTemplateService(supabase: SupabaseClient): TemplateService {
       return new TemplateService(supabase);
     }
     ```

  2. Create template-processor.ts:
     ```typescript
     // ============================================
     // [F146] src/lib/templates/template-processor.ts
     // ============================================
     
     import { Template } from '@/lib/types';
     
     export interface TemplateVariables {
       // Personal info
       name?: string;
       email?: string;
       phone?: string;
       location?: string;
       linkedin?: string;
       website?: string;
       summary?: string;
       
       // Job info
       job_title?: string;
       company?: string;
       date?: string;
       
       // Content sections
       content?: string;
       cv_content?: string;
       cover_letter_content?: string;
       email_content?: string;
     }
     
     // Variable pattern: {{variable_name}} or {{{variable_name}}}
     const VARIABLE_PATTERN = /\{\{\{?(\w+)\}\}\}?/g;
     
     // Extract variables from template content
     export function extractTemplateVariables(templateContent: string): string[] {
       const matches = templateContent.matchAll(VARIABLE_PATTERN);
       const variables = new Set<string>();
       
       for (const match of matches) {
         variables.add(match[1]);
       }
       
       return Array.from(variables);
     }
     
     // Apply variables to template
     export function applyTemplate(
       templateContent: string,
       variables: TemplateVariables
     ): string {
       let result = templateContent;
       
       // Replace all variables
       result = result.replace(VARIABLE_PATTERN, (match, varName) => {
         const value = variables[varName as keyof TemplateVariables];
         return value !== undefined ? String(value) : match;
       });
       
       return result;
     }
     
     // Merge content with template
     export function mergeWithTemplate(
       template: Template,
       content: string,
       variables?: TemplateVariables
     ): string {
       const allVariables: TemplateVariables = {
         ...variables,
         content,
         date: new Date().toLocaleDateString('en-US', {
           year: 'numeric',
           month: 'long',
           day: 'numeric',
         }),
       };
       
       return applyTemplate(template.file_content, allVariables);
     }
     
     // Validate template content
     export function validateTemplate(content: string): {
       valid: boolean;
       errors: string[];
       variables: string[];
     } {
       const errors: string[] = [];
       const variables = extractTemplateVariables(content);
       
       // Check for content variable (required)
       if (!variables.includes('content')) {
         errors.push('Template must include {{content}} variable');
       }
       
       // Check for unmatched braces
       const openBraces = (content.match(/\{\{/g) || []).length;
       const closeBraces = (content.match(/\}\}/g) || []).length;
       if (openBraces !== closeBraces) {
         errors.push('Mismatched template variable braces');
       }
       
       return {
         valid: errors.length === 0,
         errors,
         variables,
       };
     }
     
     // Get default template content
     export function getDefaultTemplateContent(type: 'cv' | 'cover_letter' | 'email'): string {
       switch (type) {
         case 'cv':
           return `# {{name}}

     {{email}} | {{phone}} | {{location}}

     {{content}}`;
         
         case 'cover_letter':
           return `{{date}}

     Dear Hiring Manager,

     {{content}}

     Sincerely,
     {{name}}`;
         
         case 'email':
           return `Subject: Application for {{job_title}} Position

     Dear {{company}} Hiring Team,

     {{content}}

     Best regards,
     {{name}}
     {{email}}
     {{phone}}`;
         
         default:
           return '{{content}}';
       }
     }
     ```

  3. Create index.ts:
     ```typescript
     // ============================================
     // [F147] src/lib/templates/index.ts
     // ============================================
     
     export * from './template-service';
     export * from './template-processor';
     ```

  4. Create API route for templates:
     ```typescript
     // ============================================
     // [F148] src/app/api/templates/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createTemplateService, validateTemplate } from '@/lib/templates';
     
     // GET - List user's templates
     export async function GET(request: NextRequest) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const { searchParams } = new URL(request.url);
         const type = searchParams.get('type');
         
         const supabase = createServerSupabaseClient();
         const service = createTemplateService(supabase);
         
         let templates;
         if (type) {
           templates = await service.getTemplatesByType(userId, type as any);
         } else {
           templates = await service.getUserTemplates(userId);
         }
         
         return NextResponse.json({ templates });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Failed to fetch templates' },
           { status: 500 }
         );
       }
     }
     
     // POST - Create new template
     export async function POST(request: NextRequest) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const body = await request.json();
         const { template_name, template_type, file_format, file_content } = body;
         
         // Validation
         if (!template_name || !template_type || !file_format || !file_content) {
           return NextResponse.json(
             { error: 'Missing required fields' },
             { status: 400 }
           );
         }
         
         // Validate template content
         const validation = validateTemplate(file_content);
         if (!validation.valid) {
           return NextResponse.json(
             { error: 'Invalid template', details: validation.errors },
             { status: 400 }
           );
         }
         
         const supabase = createServerSupabaseClient();
         const service = createTemplateService(supabase);
         
         const template = await service.createTemplate(userId, {
           template_name,
           template_type,
           file_format,
           file_content,
         });
         
         return NextResponse.json({ 
           template, 
           variables: validation.variables,
           success: true 
         });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Failed to create template' },
           { status: 500 }
         );
       }
     }
     ```

  5. Create API route for single template:
     ```typescript
     // ============================================
     // [F149] src/app/api/templates/[id]/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createTemplateService, validateTemplate } from '@/lib/templates';
     
     interface RouteParams {
       params: { id: string };
     }
     
     // GET - Get single template
     export async function GET(request: NextRequest, { params }: RouteParams) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const supabase = createServerSupabaseClient();
         const service = createTemplateService(supabase);
         
         const template = await service.getTemplate(params.id, userId);
         
         if (!template) {
           return NextResponse.json({ error: 'Not found' }, { status: 404 });
         }
         
         return NextResponse.json({ template });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Failed to fetch template' },
           { status: 500 }
         );
       }
     }
     
     // PUT - Update template
     export async function PUT(request: NextRequest, { params }: RouteParams) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const body = await request.json();
         
         // Validate if content is being updated
         if (body.file_content) {
           const validation = validateTemplate(body.file_content);
           if (!validation.valid) {
             return NextResponse.json(
               { error: 'Invalid template', details: validation.errors },
               { status: 400 }
             );
           }
         }
         
         const supabase = createServerSupabaseClient();
         const service = createTemplateService(supabase);
         
         const template = await service.updateTemplate(params.id, userId, body);
         
         return NextResponse.json({ template, success: true });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Failed to update template' },
           { status: 500 }
         );
       }
     }
     
     // DELETE - Delete template
     export async function DELETE(request: NextRequest, { params }: RouteParams) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const supabase = createServerSupabaseClient();
         const service = createTemplateService(supabase);
         
         await service.deleteTemplate(params.id, userId);
         
         return NextResponse.json({ success: true });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Failed to delete template' },
           { status: 500 }
         );
       }
     }
     ```

  6. Create useTemplates hook:
     ```typescript
     // ============================================
     // [F150] src/hooks/useTemplates.ts
     // ============================================
     
     'use client';
     
     import { useState, useEffect, useCallback } from 'react';
     import { useAuth } from '@/context/AuthContext';
     import { Template, TemplateType } from '@/lib/types';
     
     interface UseTemplatesOptions {
       type?: TemplateType;
       autoFetch?: boolean;
     }
     
     export function useTemplates(options: UseTemplatesOptions = {}) {
       const { type, autoFetch = true } = options;
       const { user } = useAuth();
       
       const [templates, setTemplates] = useState<Template[]>([]);
       const [loading, setLoading] = useState(true);
       const [error, setError] = useState<string | null>(null);
       
       const fetchTemplates = useCallback(async () => {
         if (!user) return;
         
         setLoading(true);
         setError(null);
         
         try {
           const params = new URLSearchParams();
           if (type) params.set('type', type);
           
           const res = await fetch(`/api/templates?${params}`, {
             headers: { 'x-user-id': user.id }
           });
           
           const data = await res.json();
           if (data.error) throw new Error(data.error);
           
           setTemplates(data.templates || []);
         } catch (err: any) {
           setError(err.message);
         } finally {
           setLoading(false);
         }
       }, [user, type]);
       
       const createTemplate = useCallback(async (
         template: {
           template_name: string;
           template_type: TemplateType;
           file_format: 'docx' | 'md';
           file_content: string;
         }
       ): Promise<Template> => {
         if (!user) throw new Error('Not authenticated');
         
         const res = await fetch('/api/templates', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'x-user-id': user.id
           },
           body: JSON.stringify(template)
         });
         
         const data = await res.json();
         if (data.error) throw new Error(data.error);
         
         setTemplates(prev => [data.template, ...prev]);
         return data.template;
       }, [user]);
       
       const updateTemplate = useCallback(async (
         id: string,
         updates: Partial<Template>
       ): Promise<Template> => {
         if (!user) throw new Error('Not authenticated');
         
         const res = await fetch(`/api/templates/${id}`, {
           method: 'PUT',
           headers: {
             'Content-Type': 'application/json',
             'x-user-id': user.id
           },
           body: JSON.stringify(updates)
         });
         
         const data = await res.json();
         if (data.error) throw new Error(data.error);
         
         setTemplates(prev => prev.map(t => t.id === id ? data.template : t));
         return data.template;
       }, [user]);
       
       const deleteTemplate = useCallback(async (id: string): Promise<void> => {
         if (!user) throw new Error('Not authenticated');
         
         const res = await fetch(`/api/templates/${id}`, {
           method: 'DELETE',
           headers: { 'x-user-id': user.id }
         });
         
         const data = await res.json();
         if (data.error) throw new Error(data.error);
         
         setTemplates(prev => prev.filter(t => t.id !== id));
       }, [user]);
       
       useEffect(() => {
         if (autoFetch && user) {
           fetchTemplates();
         }
       }, [autoFetch, user, fetchTemplates]);
       
       return {
         templates,
         loading,
         error,
         fetchTemplates,
         createTemplate,
         updateTemplate,
         deleteTemplate,
       };
     }
     ```

  7. Create TemplateCard.tsx:
     ```typescript
     // ============================================
     // [F151] src/components/templates/TemplateCard.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { Template } from '@/lib/types';
     import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
     import { Button } from '@/components/ui/button';
     import { Badge } from '@/components/ui/badge';
     import { Eye, Trash2, FileText, File, Check } from 'lucide-react';
     import { cn } from '@/lib/utils';
     
     interface TemplateCardProps {
       template: Template;
       selected?: boolean;
       selectable?: boolean;
       onSelect?: (template: Template) => void;
       onPreview?: (template: Template) => void;
       onDelete?: (template: Template) => void;
       className?: string;
     }
     
     const typeLabels: Record<string, string> = {
       cv: 'CV',
       cover_letter: 'Cover Letter',
       email: 'Email',
     };
     
     export function TemplateCard({
       template,
       selected = false,
       selectable = false,
       onSelect,
       onPreview,
       onDelete,
       className
     }: TemplateCardProps) {
       const t = useTranslations('templates');
       
       return (
         <Card
           className={cn(
             'relative transition-all',
             selectable && 'cursor-pointer hover:border-primary',
             selected && 'border-primary ring-2 ring-primary/20',
             className
           )}
           onClick={() => selectable && onSelect?.(template)}
         >
           {selected && (
             <div className="absolute top-3 right-3 bg-primary text-primary-foreground rounded-full p-1">
               <Check className="h-4 w-4" />
             </div>
           )}
           
           <CardHeader className="pb-2">
             <div className="flex items-start justify-between">
               <CardTitle className="text-base">{template.template_name}</CardTitle>
               {template.file_format === 'docx' ? (
                 <File className="h-4 w-4 text-blue-500" />
               ) : (
                 <FileText className="h-4 w-4 text-green-500" />
               )}
             </div>
           </CardHeader>
           
           <CardContent>
             <div className="flex items-center gap-2 mb-3">
               <Badge variant="outline">{typeLabels[template.template_type]}</Badge>
               <Badge variant="secondary" className="uppercase text-xs">
                 {template.file_format}
               </Badge>
             </div>
             
             <div className="flex items-center gap-2">
               {onPreview && (
                 <Button
                   variant="ghost"
                   size="sm"
                   onClick={(e) => { e.stopPropagation(); onPreview(template); }}
                 >
                   <Eye className="h-4 w-4 mr-1" />
                   {t('preview')}
                 </Button>
               )}
               {onDelete && (
                 <Button
                   variant="ghost"
                   size="sm"
                   className="text-destructive hover:text-destructive"
                   onClick={(e) => { e.stopPropagation(); onDelete(template); }}
                 >
                   <Trash2 className="h-4 w-4 mr-1" />
                   {t('delete')}
                 </Button>
               )}
             </div>
           </CardContent>
         </Card>
       );
     }
     ```

  8. Create TemplateList.tsx:
     ```typescript
     // ============================================
     // [F152] src/components/templates/TemplateList.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { Template, TemplateType } from '@/lib/types';
     import { TemplateCard } from './TemplateCard';
     import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
     import { FileCheck, FileText, Mail, Loader2 } from 'lucide-react';
     
     interface TemplateListProps {
       templates: Template[];
       loading?: boolean;
       selectedId?: string;
       selectable?: boolean;
       onSelect?: (template: Template) => void;
       onPreview?: (template: Template) => void;
       onDelete?: (template: Template) => void;
       filterByType?: TemplateType;
       className?: string;
     }
     
     export function TemplateList({
       templates,
       loading = false,
       selectedId,
       selectable = false,
       onSelect,
       onPreview,
       onDelete,
       filterByType,
       className
     }: TemplateListProps) {
       const t = useTranslations('templates');
       
       if (loading) {
         return (
           <div className="flex items-center justify-center py-12">
             <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
           </div>
         );
       }
       
       const filteredTemplates = filterByType
         ? templates.filter(t => t.template_type === filterByType)
         : templates;
       
       if (filteredTemplates.length === 0) {
         return (
           <div className="text-center py-12">
             <p className="text-muted-foreground">{t('no_templates')}</p>
           </div>
         );
       }
       
       if (filterByType) {
         return (
           <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
             {filteredTemplates.map((template) => (
               <TemplateCard
                 key={template.id}
                 template={template}
                 selected={template.id === selectedId}
                 selectable={selectable}
                 onSelect={onSelect}
                 onPreview={onPreview}
                 onDelete={onDelete}
               />
             ))}
           </div>
         );
       }
       
       // Group by type
       const cvTemplates = templates.filter(t => t.template_type === 'cv');
       const coverTemplates = templates.filter(t => t.template_type === 'cover_letter');
       const emailTemplates = templates.filter(t => t.template_type === 'email');
       
       return (
         <Tabs defaultValue="cv" className={className}>
           <TabsList>
             <TabsTrigger value="cv" className="flex items-center gap-2">
               <FileCheck className="h-4 w-4" />
               {t('cv_templates')} ({cvTemplates.length})
             </TabsTrigger>
             <TabsTrigger value="cover_letter" className="flex items-center gap-2">
               <FileText className="h-4 w-4" />
               {t('cover_letter_templates')} ({coverTemplates.length})
             </TabsTrigger>
             <TabsTrigger value="email" className="flex items-center gap-2">
               <Mail className="h-4 w-4" />
               {t('email_templates')} ({emailTemplates.length})
             </TabsTrigger>
           </TabsList>
           
           {['cv', 'cover_letter', 'email'].map((type) => {
             const typeTemplates = templates.filter(t => t.template_type === type);
             return (
               <TabsContent key={type} value={type} className="mt-4">
                 {typeTemplates.length === 0 ? (
                   <p className="text-center py-8 text-muted-foreground">
                     {t('no_templates_type')}
                   </p>
                 ) : (
                   <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                     {typeTemplates.map((template) => (
                       <TemplateCard
                         key={template.id}
                         template={template}
                         selected={template.id === selectedId}
                         selectable={selectable}
                         onSelect={onSelect}
                         onPreview={onPreview}
                         onDelete={onDelete}
                       />
                     ))}
                   </div>
                 )}
               </TabsContent>
             );
           })}
         </Tabs>
       );
     }
     ```

  9. Create TemplateUploader.tsx:
     ```typescript
     // ============================================
     // [F060] src/components/templates/TemplateUploader.tsx
     // ============================================
     
     'use client';
     
     import { useState, useCallback } from 'react';
     import { useTranslations } from 'next-intl';
     import { TemplateType } from '@/lib/types';
     import { useTemplates } from '@/hooks/useTemplates';
     import { parseFile } from '@/lib/parsers';
     import { validateTemplate, getDefaultTemplateContent } from '@/lib/templates/template-processor';
     import {
       Dialog,
       DialogContent,
       DialogHeader,
       DialogTitle,
       DialogFooter,
     } from '@/components/ui/dialog';
     import { Button } from '@/components/ui/button';
     import { Input } from '@/components/ui/input';
     import { Label } from '@/components/ui/label';
     import { Textarea } from '@/components/ui/textarea';
     import {
       Select,
       SelectContent,
       SelectItem,
       SelectTrigger,
       SelectValue,
     } from '@/components/ui/select';
     import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
     import { Alert, AlertDescription } from '@/components/ui/alert';
     import { Upload, FileText, Loader2, AlertCircle, Info } from 'lucide-react';
     import { FileDropZone } from '@/components/cv/FileDropZone';
     
     interface TemplateUploaderProps {
       open: boolean;
       onClose: () => void;
       onSuccess?: () => void;
     }
     
     export function TemplateUploader({ open, onClose, onSuccess }: TemplateUploaderProps) {
       const t = useTranslations('templates');
       const { createTemplate } = useTemplates();
       
       const [mode, setMode] = useState<'upload' | 'create'>('upload');
       const [templateName, setTemplateName] = useState('');
       const [templateType, setTemplateType] = useState<TemplateType>('cv');
       const [fileFormat, setFileFormat] = useState<'docx' | 'md'>('md');
       const [content, setContent] = useState('');
       const [file, setFile] = useState<File | null>(null);
       const [saving, setSaving] = useState(false);
       const [error, setError] = useState<string | null>(null);
       
       const resetForm = () => {
         setTemplateName('');
         setTemplateType('cv');
         setFileFormat('md');
         setContent('');
         setFile(null);
         setError(null);
       };
       
       const handleFileSelect = useCallback(async (selectedFile: File) => {
         setFile(selectedFile);
         setError(null);
         
         try {
           const ext = selectedFile.name.split('.').pop()?.toLowerCase();
           setFileFormat(ext === 'docx' ? 'docx' : 'md');
           
           const parsed = await parseFile(selectedFile);
           setContent(parsed.text);
           
           // Auto-set name from filename
           if (!templateName) {
             setTemplateName(selectedFile.name.replace(/\.\w+$/, ''));
           }
         } catch (err: any) {
           setError(err.message);
         }
       }, [templateName]);
       
       const handleUseDefault = () => {
         const defaultContent = getDefaultTemplateContent(templateType);
         setContent(defaultContent);
       };
       
       const handleSave = async () => {
         setError(null);
         
         if (!templateName.trim()) {
           setError(t('name_required'));
           return;
         }
         
         if (!content.trim()) {
           setError(t('content_required'));
           return;
         }
         
         // Validate template
         const validation = validateTemplate(content);
         if (!validation.valid) {
           setError(validation.errors.join(', '));
           return;
         }
         
         setSaving(true);
         
         try {
           await createTemplate({
             template_name: templateName,
             template_type: templateType,
             file_format: fileFormat,
             file_content: content,
           });
           
           resetForm();
           onClose();
           onSuccess?.();
         } catch (err: any) {
           setError(err.message);
         } finally {
           setSaving(false);
         }
       };
       
       return (
         <Dialog open={open} onOpenChange={onClose}>
           <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
             <DialogHeader>
               <DialogTitle className="flex items-center gap-2">
                 <Upload className="h-5 w-5" />
                 {t('add_template')}
               </DialogTitle>
             </DialogHeader>
             
             <div className="space-y-4 py-4">
               {/* Template name */}
               <div className="grid gap-2">
                 <Label htmlFor="name">{t('template_name')}</Label>
                 <Input
                   id="name"
                   value={templateName}
                   onChange={(e) => setTemplateName(e.target.value)}
                   placeholder={t('name_placeholder')}
                 />
               </div>
               
               {/* Template type */}
               <div className="grid gap-2">
                 <Label>{t('template_type')}</Label>
                 <Select value={templateType} onValueChange={(v) => setTemplateType(v as TemplateType)}>
                   <SelectTrigger>
                     <SelectValue />
                   </SelectTrigger>
                   <SelectContent>
                     <SelectItem value="cv">{t('type_cv')}</SelectItem>
                     <SelectItem value="cover_letter">{t('type_cover_letter')}</SelectItem>
                     <SelectItem value="email">{t('type_email')}</SelectItem>
                   </SelectContent>
                 </Select>
               </div>
               
               {/* Upload or Create */}
               <Tabs value={mode} onValueChange={(v) => setMode(v as 'upload' | 'create')}>
                 <TabsList className="grid w-full grid-cols-2">
                   <TabsTrigger value="upload">{t('upload_file')}</TabsTrigger>
                   <TabsTrigger value="create">{t('create_manually')}</TabsTrigger>
                 </TabsList>
                 
                 <TabsContent value="upload" className="mt-4">
                   <FileDropZone
                     onFileSelect={handleFileSelect}
                     acceptedTypes={['.docx', '.md', '.txt']}
                   />
                 </TabsContent>
                 
                 <TabsContent value="create" className="mt-4 space-y-4">
                   <div className="flex items-center justify-between">
                     <Label>{t('template_content')}</Label>
                     <Button variant="outline" size="sm" onClick={handleUseDefault}>
                       {t('use_default')}
                     </Button>
                   </div>
                   <Textarea
                     value={content}
                     onChange={(e) => setContent(e.target.value)}
                     placeholder={t('content_placeholder')}
                     rows={10}
                     className="font-mono text-sm"
                   />
                 </TabsContent>
               </Tabs>
               
               {/* Variable hint */}
               <Alert>
                 <Info className="h-4 w-4" />
                 <AlertDescription>
                   {t('variable_hint')}
                 </AlertDescription>
               </Alert>
               
               {/* Error */}
               {error && (
                 <Alert variant="destructive">
                   <AlertCircle className="h-4 w-4" />
                   <AlertDescription>{error}</AlertDescription>
                 </Alert>
               )}
               
               {/* Preview of content */}
               {content && (
                 <div className="grid gap-2">
                   <Label>{t('preview')}</Label>
                   <div


بلوک B18 — ادامه (بخش ۲ از ۲)
B18.yaml — ادامه instructions
YAML

# ادامه B18.yaml - فایل‌های باقیمانده

  16. Create PromptSelectionStep.tsx:
      ```typescript
      // ============================================
      // [F136] src/components/application/PromptSelectionStep.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { PromptSelector } from '@/components/prompts/PromptSelector';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Sparkles } from 'lucide-react';
      
      interface PromptSelectionStepProps {
        selectedIds: string[];
        onSelectionChange: (ids: string[]) => void;
        disabled?: boolean;
        className?: string;
      }
      
      export function PromptSelectionStep({
        selectedIds,
        onSelectionChange,
        disabled = false,
        className
      }: PromptSelectionStepProps) {
        const t = useTranslations('application');
        
        return (
          <Card className={className}>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Sparkles className="h-5 w-5" />
                {t('select_prompts_title')}
              </CardTitle>
              <CardDescription>
                {t('select_prompts_description')}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <PromptSelector
                selectedIds={selectedIds}
                onSelectionChange={onSelectionChange}
                maxSelection={null}
              />
            </CardContent>
          </Card>
        );
      }
      ```

  17. Create AIConfigurationStep.tsx:
      ```typescript
      // ============================================
      // [F137] src/components/application/AIConfigurationStep.tsx
      // ============================================
      
      'use client';
      
      import { useState } from 'react';
      import { useTranslations } from 'next-intl';
      import { useParams } from 'next/navigation';
      import { useAIKeys } from '@/hooks/useAIKeys';
      import { AIModelSelection, AIProviderName } from '@/lib/types';
      import { SUPPORTED_AI_PROVIDERS } from '@/lib/constants';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Label } from '@/components/ui/label';
      import { Badge } from '@/components/ui/badge';
      import { Button } from '@/components/ui/button';
      import {
        Select,
        SelectContent,
        SelectItem,
        SelectTrigger,
        SelectValue,
      } from '@/components/ui/select';
      import { Switch } from '@/components/ui/switch';
      import { 
        Settings, CheckCircle, AlertCircle, Plus, Trash2, Cpu 
      } from 'lucide-react';
      import { cn } from '@/lib/utils';
      import Link from 'next/link';
      
      interface AIConfigurationStepProps {
        selections: AIModelSelection[];
        onSelectionsChange: (selections: AIModelSelection[]) => void;
        disabled?: boolean;
        className?: string;
      }
      
      export function AIConfigurationStep({
        selections,
        onSelectionsChange,
        disabled = false,
        className
      }: AIConfigurationStepProps) {
        const t = useTranslations('application');
        const params = useParams();
        const locale = params.locale as 'en' | 'fa';
        
        const { keys, loading, hasValidKey, getModelsForProvider, getValidProviders } = useAIKeys();
        
        const [useSeparateFinal, setUseSeparateFinal] = useState(
          selections.some(s => s.role === 'final')
        );
        
        const validProviders = getValidProviders();
        const hasAnyValidKey = validProviders.length > 0;
        
        // Get current draft and final selections
        const draftSelection = selections.find(s => s.role === 'draft');
        const finalSelection = selections.find(s => s.role === 'final');
        
        const updateSelection = (role: 'draft' | 'final', provider: AIProviderName | null, model: string | null) => {
          let newSelections = selections.filter(s => s.role !== role);
          
          if (provider && model) {
            newSelections.push({ provider, model, role });
          }
          
          onSelectionsChange(newSelections);
        };
        
        const handleUseSeparateFinalChange = (checked: boolean) => {
          setUseSeparateFinal(checked);
          if (!checked) {
            // Remove final selection
            onSelectionsChange(selections.filter(s => s.role !== 'final'));
          }
        };
        
        if (loading) {
          return (
            <Card className={className}>
              <CardContent className="py-8">
                <div className="flex items-center justify-center">
                  <div className="animate-spin h-8 w-8 border-2 border-primary border-t-transparent rounded-full" />
                </div>
              </CardContent>
            </Card>
          );
        }
        
        if (!hasAnyValidKey) {
          return (
            <Card className={className}>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Settings className="h-5 w-5" />
                  {t('ai_config_title')}
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex flex-col items-center justify-center py-8 text-center">
                  <AlertCircle className="h-12 w-12 text-yellow-500 mb-4" />
                  <h3 className="text-lg font-medium mb-2">{t('no_ai_keys')}</h3>
                  <p className="text-muted-foreground mb-4">{t('no_ai_keys_hint')}</p>
                  <Link href={`/${locale}/settings`}>
                    <Button>
                      <Settings className="h-4 w-4 mr-2" />
                      {t('go_to_settings')}
                    </Button>
                  </Link>
                </div>
              </CardContent>
            </Card>
          );
        }
        
        return (
          <Card className={className}>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Cpu className="h-5 w-5" />
                {t('ai_config_title')}
              </CardTitle>
              <CardDescription>
                {t('ai_config_description')}
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              
              {/* Draft AI Selection */}
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <Label className="text-base font-medium">
                    {t('draft_ai')}
                  </Label>
                  <Badge variant="outline">{t('required')}</Badge>
                </div>
                <p className="text-sm text-muted-foreground">
                  {t('draft_ai_hint')}
                </p>
                
                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label>{t('provider')}</Label>
                    <Select
                      value={draftSelection?.provider || ''}
                      onValueChange={(v) => {
                        updateSelection('draft', v as AIProviderName, '');
                      }}
                      disabled={disabled}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder={t('select_provider')} />
                      </SelectTrigger>
                      <SelectContent>
                        {SUPPORTED_AI_PROVIDERS.map((provider) => {
                          const isValid = hasValidKey(provider.name);
                          return (
                            <SelectItem
                              key={provider.name}
                              value={provider.name}
                              disabled={!isValid}
                            >
                              <div className="flex items-center gap-2">
                                {isValid ? (
                                  <CheckCircle className="h-3 w-3 text-green-500" />
                                ) : (
                                  <AlertCircle className="h-3 w-3 text-muted-foreground" />
                                )}
                                {provider.label}
                              </div>
                            </SelectItem>
                          );
                        })}
                      </SelectContent>
                    </Select>
                  </div>
                  
                  <div className="space-y-2">
                    <Label>{t('model')}</Label>
                    <Select
                      value={draftSelection?.model || ''}
                      onValueChange={(v) => {
                        if (draftSelection?.provider) {
                          updateSelection('draft', draftSelection.provider, v);
                        }
                      }}
                      disabled={disabled || !draftSelection?.provider}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder={t('select_model')} />
                      </SelectTrigger>
                      <SelectContent>
                        {draftSelection?.provider && 
                          getModelsForProvider(draftSelection.provider).map((model) => (
                            <SelectItem key={model.model_id} value={model.model_id}>
                              {model.model_name}
                            </SelectItem>
                          ))
                        }
                      </SelectContent>
                    </Select>
                  </div>
                </div>
              </div>
              
              {/* Separator */}
              <div className="border-t pt-6">
                <div className="flex items-center justify-between mb-4">
                  <div>
                    <Label className="text-base font-medium">
                      {t('use_different_final')}
                    </Label>
                    <p className="text-sm text-muted-foreground">
                      {t('use_different_final_hint')}
                    </p>
                  </div>
                  <Switch
                    checked={useSeparateFinal}
                    onCheckedChange={handleUseSeparateFinalChange}
                    disabled={disabled}
                  />
                </div>
                
                {/* Final AI Selection */}
                {useSeparateFinal && (
                  <div className="space-y-4 mt-4 p-4 bg-muted/50 rounded-lg">
                    <Label className="text-base font-medium">
                      {t('final_ai')}
                    </Label>
                    <p className="text-sm text-muted-foreground">
                      {t('final_ai_hint')}
                    </p>
                    
                    <div className="grid grid-cols-2 gap-4">
                      <div className="space-y-2">
                        <Label>{t('provider')}</Label>
                        <Select
                          value={finalSelection?.provider || ''}
                          onValueChange={(v) => {
                            updateSelection('final', v as AIProviderName, '');
                          }}
                          disabled={disabled}
                        >
                          <SelectTrigger>
                            <SelectValue placeholder={t('select_provider')} />
                          </SelectTrigger>
                          <SelectContent>
                            {SUPPORTED_AI_PROVIDERS.map((provider) => {
                              const isValid = hasValidKey(provider.name);
                              return (
                                <SelectItem
                                  key={provider.name}
                                  value={provider.name}
                                  disabled={!isValid}
                                >
                                  <div className="flex items-center gap-2">
                                    {isValid ? (
                                      <CheckCircle className="h-3 w-3 text-green-500" />
                                    ) : (
                                      <AlertCircle className="h-3 w-3 text-muted-foreground" />
                                    )}
                                    {provider.label}
                                  </div>
                                </SelectItem>
                              );
                            })}
                          </SelectContent>
                        </Select>
                      </div>
                      
                      <div className="space-y-2">
                        <Label>{t('model')}</Label>
                        <Select
                          value={finalSelection?.model || ''}
                          onValueChange={(v) => {
                            if (finalSelection?.provider) {
                              updateSelection('final', finalSelection.provider, v);
                            }
                          }}
                          disabled={disabled || !finalSelection?.provider}
                        >
                          <SelectTrigger>
                            <SelectValue placeholder={t('select_model')} />
                          </SelectTrigger>
                          <SelectContent>
                            {finalSelection?.provider && 
                              getModelsForProvider(finalSelection.provider).map((model) => (
                                <SelectItem key={model.model_id} value={model.model_id}>
                                  {model.model_name}
                                </SelectItem>
                              ))
                            }
                          </SelectContent>
                        </Select>
                      </div>
                    </div>
                  </div>
                )}
              </div>
              
              {/* Summary */}
              {(draftSelection?.model || finalSelection?.model) && (
                <div className="border-t pt-4">
                  <Label className="text-sm text-muted-foreground mb-2 block">
                    {t('config_summary')}
                  </Label>
                  <div className="flex flex-wrap gap-2">
                    {draftSelection?.model && (
                      <Badge variant="secondary">
                        {t('draft')}: {draftSelection.provider} / {draftSelection.model}
                      </Badge>
                    )}
                    {finalSelection?.model && (
                      <Badge variant="secondary">
                        {t('final')}: {finalSelection.provider} / {finalSelection.model}
                      </Badge>
                    )}
                  </div>
                </div>
              )}
              
            </CardContent>
          </Card>
        );
      }
      ```

  18. Create OutputSettingsStep.tsx:
      ```typescript
      // ============================================
      // [F138] src/components/application/OutputSettingsStep.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { OutputLanguage, ToneSetting } from '@/lib/types';
      import { LanguageSelector } from './LanguageSelector';
      import { ToneSelector } from './ToneSelector';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Settings2 } from 'lucide-react';
      
      interface OutputSettingsStepProps {
        outputLanguage: OutputLanguage;
        onOutputLanguageChange: (lang: OutputLanguage) => void;
        toneSetting: ToneSetting;
        onToneSettingChange: (tone: ToneSetting) => void;
        disabled?: boolean;
        className?: string;
      }
      
      export function OutputSettingsStep({
        outputLanguage,
        onOutputLanguageChange,
        toneSetting,
        onToneSettingChange,
        disabled = false,
        className
      }: OutputSettingsStepProps) {
        const t = useTranslations('application');
        
        return (
          <Card className={className}>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Settings2 className="h-5 w-5" />
                {t('output_settings_title')}
              </CardTitle>
              <CardDescription>
                {t('output_settings_description')}
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-8">
              <LanguageSelector
                value={outputLanguage}
                onChange={onOutputLanguageChange}
                disabled={disabled}
              />
              
              <ToneSelector
                value={toneSetting}
                onChange={onToneSettingChange}
                disabled={disabled}
              />
            </CardContent>
          </Card>
        );
      }
      ```

  19. Create AIChatInterface.tsx:
      ```typescript
      // ============================================
      // [F052] src/components/ai/AIChatInterface.tsx
      // ============================================
      
      'use client';
      
      import { useState, useRef, useEffect } from 'react';
      import { useTranslations } from 'next-intl';
      import { ClarificationMessage } from '@/lib/types';
      import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
      import { Button } from '@/components/ui/button';
      import { Textarea } from '@/components/ui/textarea';
      import { ScrollArea } from '@/components/ui/scroll-area';
      import { Avatar, AvatarFallback } from '@/components/ui/avatar';
      import { MessageSquare, Send, Loader2, Bot, User } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      interface AIChatInterfaceProps {
        messages: ClarificationMessage[];
        onSendMessage: (message: string) => void;
        isProcessing?: boolean;
        disabled?: boolean;
        className?: string;
      }
      
      export function AIChatInterface({
        messages,
        onSendMessage,
        isProcessing = false,
        disabled = false,
        className
      }: AIChatInterfaceProps) {
        const t = useTranslations('application');
        const [input, setInput] = useState('');
        const scrollRef = useRef<HTMLDivElement>(null);
        const textareaRef = useRef<HTMLTextAreaElement>(null);
        
        // Scroll to bottom when messages change
        useEffect(() => {
          if (scrollRef.current) {
            scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
          }
        }, [messages]);
        
        const handleSend = () => {
          if (input.trim() && !isProcessing && !disabled) {
            onSendMessage(input.trim());
            setInput('');
          }
        };
        
        const handleKeyDown = (e: React.KeyboardEvent) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSend();
          }
        };
        
        return (
          <Card className={cn('flex flex-col', className)}>
            <CardHeader className="pb-3">
              <CardTitle className="flex items-center gap-2 text-lg">
                <MessageSquare className="h-5 w-5" />
                {t('ai_clarification')}
              </CardTitle>
            </CardHeader>
            
            <CardContent className="flex-1 flex flex-col min-h-0">
              {/* Messages Area */}
              <ScrollArea 
                ref={scrollRef}
                className="flex-1 pr-4 mb-4"
                style={{ maxHeight: '400px' }}
              >
                <div className="space-y-4">
                  {messages.map((message) => (
                    <div
                      key={message.id}
                      className={cn(
                        'flex gap-3',
                        message.role === 'user' && 'flex-row-reverse'
                      )}
                    >
                      <Avatar className={cn(
                        'h-8 w-8',
                        message.role === 'assistant' ? 'bg-primary' : 'bg-secondary'
                      )}>
                        <AvatarFallback>
                          {message.role === 'assistant' ? (
                            <Bot className="h-4 w-4" />
                          ) : (
                            <User className="h-4 w-4" />
                          )}
                        </AvatarFallback>
                      </Avatar>
                      
                      <div className={cn(
                        'flex-1 max-w-[80%]',
                        message.role === 'user' && 'text-right'
                      )}>
                        <div className={cn(
                          'inline-block p-3 rounded-lg text-sm',
                          message.role === 'assistant' 
                            ? 'bg-muted text-foreground' 
                            : 'bg-primary text-primary-foreground'
                        )}>
                          <p className="whitespace-pre-wrap">{message.content}</p>
                        </div>
                        <p className="text-xs text-muted-foreground mt-1">
                          {new Date(message.timestamp).toLocaleTimeString()}
                        </p>
                      </div>
                    </div>
                  ))}
                  
                  {/* Processing indicator */}
                  {isProcessing && (
                    <div className="flex gap-3">
                      <Avatar className="h-8 w-8 bg-primary">
                        <AvatarFallback>
                          <Bot className="h-4 w-4" />
                        </AvatarFallback>
                      </Avatar>
                      <div className="bg-muted p-3 rounded-lg">
                        <Loader2 className="h-4 w-4 animate-spin" />
                      </div>
                    </div>
                  )}
                </div>
              </ScrollArea>
              
              {/* Input Area */}
              <div className="flex gap-2">
                <Textarea
                  ref={textareaRef}
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  onKeyDown={handleKeyDown}
                  placeholder={t('type_response')}
                  disabled={disabled || isProcessing}
                  rows={2}
                  className="resize-none"
                  dir="auto"
                />
                <Button
                  onClick={handleSend}
                  disabled={!input.trim() || isProcessing || disabled}
                  className="self-end"
                >
                  {isProcessing ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <Send className="h-4 w-4" />
                  )}
                </Button>
              </div>
            </CardContent>
          </Card>
        );
      }
      ```

  20. Create ProcessingStep.tsx:
      ```typescript
      // ============================================
      // [F139] src/components/application/ProcessingStep.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { ApplicationStatus, ClarificationMessage } from '@/lib/types';
      import { AIChatInterface } from '@/components/ai/AIChatInterface';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Button } from '@/components/ui/button';
      import { Loader2, Sparkles, MessageSquare, CheckCircle, AlertCircle } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      interface ProcessingStepProps {
        status: ApplicationStatus;
        clarificationMessages: ClarificationMessage[];
        onStartProcessing: () => void;
        onSendClarification: (message: string) => void;
        onContinueToEdit: () => void;
        isProcessing: boolean;
        error: string | null;
        draftReady: boolean;
        className?: string;
      }
      
      export function ProcessingStep({
        status,
        clarificationMessages,
        onStartProcessing,
        onSendClarification,
        onContinueToEdit,
        isProcessing,
        error,
        draftReady,
        className
      }: ProcessingStepProps) {
        const t = useTranslations('application');
        
        // Initial state - not started
        if (status === 'draft' && clarificationMessages.length === 0 && !isProcessing) {
          return (
            <Card className={className}>
              <CardContent className="py-12">
                <div className="flex flex-col items-center justify-center text-center">
                  <div className="w-16 h-16 rounded-full bg-primary/10 flex items-center justify-center mb-4">
                    <Sparkles className="h-8 w-8 text-primary" />
                  </div>
                  <h3 className="text-xl font-semibold mb-2">{t('ready_to_process')}</h3>
                  <p className="text-muted-foreground mb-6 max-w-md">
                    {t('ready_to_process_hint')}
                  </p>
                  <Button onClick={onStartProcessing} size="lg">
                    <Sparkles className="h-4 w-4 mr-2" />
                    {t('start_processing')}
                  </Button>
                </div>
              </CardContent>
            </Card>
          );
        }
        
        // Processing state
        if (isProcessing && status !== 'clarification') {
          return (
            <Card className={className}>
              <CardContent className="py-12">
                <div className="flex flex-col items-center justify-center text-center">
                  <Loader2 className="h-12 w-12 animate-spin text-primary mb-4" />
                  <h3 className="text-xl font-semibold mb-2">{t('processing')}</h3>
                  <p className="text-muted-foreground">
                    {t('processing_hint')}
                  </p>
                </div>
              </CardContent>
            </Card>
          );
        }
        
        // Error state
        if (error) {
          return (
            <Card className={cn('border-destructive', className)}>
              <CardContent className="py-12">
                <div className="flex flex-col items-center justify-center text-center">
                  <AlertCircle className="h-12 w-12 text-destructive mb-4" />
                  <h3 className="text-xl font-semibold mb-2">{t('processing_error')}</h3>
                  <p className="text-muted-foreground mb-4">{error}</p>
                  <Button onClick={onStartProcessing} variant="outline">
                    {t('try_again')}
                  </Button>
                </div>
              </CardContent>
            </Card>
          );
        }
        
        // Clarification state
        if (status === 'clarification' || clarificationMessages.length > 0) {
          return (
            <div className={cn('space-y-4', className)}>
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <MessageSquare className="h-5 w-5" />
                    {t('ai_needs_info')}
                  </CardTitle>
                  <CardDescription>
                    {t('ai_needs_info_hint')}
                  </CardDescription>
                </CardHeader>
              </Card>
              
              <AIChatInterface
                messages={clarificationMessages}
                onSendMessage={onSendClarification}
                isProcessing={isProcessing}
                className="min-h-[400px]"
              />
            </div>
          );
        }
        
        // Draft ready state
        if (draftReady || status === 'draft_ready') {
          return (
            <Card className={className}>
              <CardContent className="py-12">
                <div className="flex flex-col items-center justify-center text-center">
                  <div className="w-16 h-16 rounded-full bg-green-100 flex items-center justify-center mb-4">
                    <CheckCircle className="h-8 w-8 text-green-600" />
                  </div>
                  <h3 className="text-xl font-semibold mb-2">{t('draft_ready')}</h3>
                  <p className="text-muted-foreground mb-6">
                    {t('draft_ready_hint')}
                  </p>
                  <Button onClick={onContinueToEdit} size="lg">
                    {t('review_and_edit')}
                  </Button>
                </div>
              </CardContent>
            </Card>
          );
        }
        
        return null;
      }
      ```

  21. Create OutputEditor.tsx:
      ```typescript
      // ============================================
      // [F057] src/components/application/OutputEditor.tsx
      // ============================================
      
      'use client';
      
      import { useState, useCallback } from 'react';
      import { useTranslations } from 'next-intl';
      import { useEditor, EditorContent } from '@tiptap/react';
      import StarterKit from '@tiptap/starter-kit';
      import Placeholder from '@tiptap/extension-placeholder';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Button } from '@/components/ui/button';
      import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
      import { 
        Edit, Eye, Bold, Italic, List, ListOrdered, 
        Heading1, Heading2, Undo, Redo, Save 
      } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      interface OutputEditorProps {
        content: string;
        onChange: (content: string) => void;
        onFinalize: () => void;
        isProcessing?: boolean;
        disabled?: boolean;
        className?: string;
      }
      
      export function OutputEditor({
        content,
        onChange,
        onFinalize,
        isProcessing = false,
        disabled = false,
        className
      }: OutputEditorProps) {
        const t = useTranslations('application');
        const [activeTab, setActiveTab] = useState<'edit' | 'preview'>('edit');
        
        const editor = useEditor({
          extensions: [
            StarterKit,
            Placeholder.configure({
              placeholder: t('editor_placeholder'),
            }),
          ],
          content: content,
          editable: !disabled,
          onUpdate: ({ editor }) => {
            onChange(editor.getHTML());
          },
        });
        
        const ToolbarButton = ({ 
          onClick, 
          active, 
          disabled: btnDisabled,
          children 
        }: { 
          onClick: () => void; 
          active?: boolean;
          disabled?: boolean;
          children: React.ReactNode;
        }) => (
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={onClick}
            disabled={btnDisabled}
            className={cn(
              'h-8 w-8 p-0',
              active && 'bg-muted'
            )}
          >
            {children}
          </Button>
        );
        
        return (
          <Card className={className}>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Edit className="h-5 w-5" />
                {t('edit_draft')}
              </CardTitle>
              <CardDescription>
                {t('edit_draft_description')}
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as 'edit' | 'preview')}>
                <div className="flex items-center justify-between mb-4">
                  <TabsList>
                    <TabsTrigger value="edit">
                      <Edit className="h-4 w-4 mr-2" />
                      {t('edit')}
                    </TabsTrigger>
                    <TabsTrigger value="preview">
                      <Eye className="h-4 w-4 mr-2" />
                      {t('preview')}
                    </TabsTrigger>
                  </TabsList>
                  
                  {/* Toolbar - only in edit mode */}
                  {activeTab === 'edit' && editor && (
                    <div className="flex items-center gap-1 border rounded-lg p-1">
                      <ToolbarButton
                        onClick={() => editor.chain().focus().toggleBold().run()}
                        active={editor.isActive('bold')}
                        disabled={disabled}
                      >
                        <Bold className="h-4 w-4" />
                      </ToolbarButton>
                      <ToolbarButton
                        onClick={() => editor.chain().focus().toggleItalic().run()}
                        active={editor.isActive('italic')}
                        disabled={disabled}
                      >
                        <Italic className="h-4 w-4" />
                      </ToolbarButton>
                      <div className="w-px h-4 bg-border mx-1" />
                      <ToolbarButton
                        onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
                        active={editor.isActive('heading', { level: 1 })}
                        disabled={disabled}
                      >
                        <Heading1 className="h-4 w-4" />
                      </ToolbarButton>
                      <ToolbarButton
                        onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
                        active={editor.isActive('heading', { level: 2 })}
                        disabled={disabled}
                      >
                        <Heading2 className="h-4 w-4" />
                      </ToolbarButton>
                      <div className="w-px h-4 bg-border mx-1" />
                      <ToolbarButton
                        onClick={() => editor.chain().focus().toggleBulletList().run()}
                        active={editor.isActive('bulletList')}
                        disabled={disabled}
                      >
                        <List className="h-4 w-4" />
                      </ToolbarButton>
                      <ToolbarButton
                        onClick={() => editor.chain().focus().toggleOrderedList().run()}
                        active={editor.isActive('orderedList')}
                        disabled={disabled}
                      >
                        <ListOrdered className="h-4 w-4" />
                      </ToolbarButton>
                      <div className="w-px h-4 bg-border mx-1" />
                      <ToolbarButton
                        onClick={() => editor.chain().focus().undo().run()}
                        disabled={disabled || !editor.can().undo()}
                      >
                        <Undo className="h-4 w-4" />
                      </ToolbarButton>
                      <ToolbarButton
                        onClick={() => editor.chain().focus().redo().run()}
                        disabled={disabled || !editor.can().redo()}
                      >
                        <Redo className="h-4 w-4" />
                      </ToolbarButton>
                    </div>
                  )}
                </div>
                
                <TabsContent value="edit" className="mt-0">
                  <div className="border rounded-lg min-h-[400px] p-4">
                    <EditorContent 
                      editor={editor} 
                      className="prose prose-sm max-w-none min-h-[350px] focus:outline-none"
                    />
                  </div>
                </TabsContent>
                
                <TabsContent value="preview" className="mt-0">
                  <div 
                    className="border rounded-lg min-h-[400px] p-4 prose prose-sm max-w-none"
                    dangerouslySetInnerHTML={{ __html: content }}
                  />
                </TabsContent>
              </Tabs>
              
              <div className="flex justify-end pt-4 border-t">
                <Button
                  onClick={onFinalize}
                  disabled={isProcessing || disabled}
                  size="lg"
                >
                  {isProcessing ? (
                    <>
                      <span className="animate-spin mr-2">⏳</span>
                      {t('generating')}
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      {t('generate_final')}
                    </>
                  )}
                </Button>
              </div>
            </CardContent>
          </Card>
        );
      }
      ```

  22. Create DocumentPreview.tsx:
      ```typescript
      // ============================================
      // [F058] src/components/application/DocumentPreview.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
      import { ScrollArea } from '@/components/ui/scroll-area';
      import { FileText, Mail, FileCheck } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      type DocumentType = 'cv' | 'cover_letter' | 'email';
      
      interface DocumentPreviewProps {
        type: DocumentType;
        content: string;
        className?: string;
      }
      
      const iconMap: Record<DocumentType, React.ElementType> = {
        cv: FileCheck,
        cover_letter: FileText,
        email: Mail
      };
      
      export function DocumentPreview({
        type,
        content,
        className
      }: DocumentPreviewProps) {
        const t = useTranslations('application');
        const Icon = iconMap[type];
        
        const titleMap: Record<DocumentType, string> = {
          cv: t('tailored_cv'),
          cover_letter: t('cover_letter'),
          email: t('application_email')
        };
        
        return (
          <Card className={className}>
            <CardHeader className="pb-3">
              <CardTitle className="flex items-center gap-2 text-lg">
                <Icon className="h-5 w-5" />
                {titleMap[type]}
              </CardTitle>
            </CardHeader>
            <CardContent>
              <ScrollArea className="h-[400px] rounded-md border p-4 bg-muted/30">
                <div className="prose prose-sm max-w-none whitespace-pre-wrap">
                  {content}
                </div>
              </ScrollArea>
            </CardContent>
          </Card>
        );
      }
      ```

  23. Create DownloadPanel.tsx:
      ```typescript
      // ============================================
      // [F059] src/components/application/DownloadPanel.tsx
      // ============================================
      
      'use client';
      
      import { useState } from 'react';
      import { useTranslations } from 'next-intl';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Button } from '@/components/ui/button';
      import { 
        Download, FileText, File, Mail, FileCheck, 
        Loader2, CheckCircle 
      } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      interface DownloadPanelProps {
        documents: {
          tailored_cv: string;
          cover_letter: string;
          application_email: string;
        };
        jobTitle?: string;
        className?: string;
      }
      
      type DocumentType = 'cv' | 'cover_letter' | 'email';
      type FileFormat = 'docx' | 'md';
      
      export function DownloadPanel({
        documents,
        jobTitle = 'application',
        className
      }: DownloadPanelProps) {
        const t = useTranslations('application');
        const [downloading, setDownloading] = useState<string | null>(null);
        const [downloaded, setDownloaded] = useState<string[]>([]);
        
        const downloadDocument = async (
          type: DocumentType, 
          format: FileFormat,
          content: string
        ) => {
          const key = `${type}-${format}`;
          setDownloading(key);
          
          try {
            // For markdown, just download as text
            if (format === 'md') {
              const blob = new Blob([content], { type: 'text/markdown' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `${jobTitle}-${type}.md`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            } else {
              // For DOCX, call API
              const response = await fetch('/api/export/docx', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                  content, 
                  filename: `${jobTitle}-${type}`,
                  type 
                })
              });
              
              if (!response.ok) throw new Error('Download failed');
              
              const blob = await response.blob();
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `${jobTitle}-${type}.docx`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }
            
            setDownloaded(prev => [...prev, key]);
            
          } catch (error) {
            console.error('Download error:', error);
          } finally {
            setDownloading(null);
          }
        };
        
        const documentTypes: { type: DocumentType; icon: React.ElementType; content: string }[] = [
          { type: 'cv', icon: FileCheck, content: documents.tailored_cv },
          { type: 'cover_letter', icon: FileText, content: documents.cover_letter },
          { type: 'email', icon: Mail, content: documents.application_email },
        ];
        
        const titleMap: Record<DocumentType, string> = {
          cv: t('tailored_cv'),
          cover_letter: t('cover_letter'),
          email: t('application_email')
        };
        
        return (
          <Card className={className}>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Download className="h-5 w-5" />
                {t('download_documents')}
              </CardTitle>
              <CardDescription>
                {t('download_description')}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {documentTypes.map(({ type, icon: Icon, content }) => (
                  <div 
                    key={type}
                    className="flex items-center justify-between p-4 border rounded-lg"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-10 h-10 rounded-full bg-primary/10 flex items-center justify-center">
                        <Icon className="h-5 w-5 text-primary" />
                      </div>
                      <div>
                        <p className="font-medium">{titleMap[type]}</p>
                        <p className="text-sm text-muted-foreground">
                          {content.length} {t('characters')}
                        </p>
                      </div>
                    </div>
                    
                    <div className="flex items-center gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => downloadDocument(type, 'docx', content)}
                        disabled={downloading !== null}
                      >
                        {downloading === `${type}-docx` ? (
                          <Loader2 className="h-4 w-4 animate-spin" />
                        ) : downloaded.includes(`${type}-docx`) ? (
                          <CheckCircle className="h-4 w-4 text-green-500" />
                        ) : (
                          <File className="h-4 w-4" />
                        )}
                        <span className="ml-2">Word</span>
                      </Button>
                      
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => downloadDocument(type, 'md', content)}
                        disabled={downloading !== null}
                      >
                        {downloading === `${type}-md` ? (
                          <Loader2 className="h-4 w-4 animate-spin" />
                        ) : downloaded.includes(`${type}-md`) ? (
                          <CheckCircle className="h-4 w-4 text-green-500" />
                        ) : (
                          <FileText className="h-4 w-4" />
                        )}
                        <span className="ml-2">Markdown</span>
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
              
              {/* Download All Button */}
              <div className="mt-6 pt-4 border-t">
                <Button
                  className="w-full"
                  onClick={async () => {
                    for (const doc of documentTypes) {
                      await downloadDocument(doc.type, 'docx', doc.content);
                    }
                  }}
                  disabled={downloading !== null}
                >
                  <Download className="h-4 w-4 mr-2" />
                  {t('download_all')}
                </Button>
              </div>
            </CardContent>
          </Card>
        );
      }
      ```

  24. Create FinalDocumentsStep.tsx:
      ```typescript
      // ============================================
      // [F140] src/components/application/FinalDocumentsStep.tsx
      // ============================================
      
      'use client';
      
      import { useState } from 'react';
      import { useTranslations } from 'next-intl';
      import { DocumentPreview } from './DocumentPreview';
      import { DownloadPanel } from './DownloadPanel';
      import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Button } from '@/components/ui/button';
      import { 
        CheckCircle, FileCheck, FileText, Mail, Download, Plus 
      } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      interface FinalDocumentsStepProps {
        documents: {
          tailored_cv: string;
          cover_letter: string;
          application_email: string;
        };
        onNewApplication: () => void;
        className?: string;
      }
      
      export function FinalDocumentsStep({
        documents,
        onNewApplication,
        className
      }: FinalDocumentsStepProps) {
        const t = useTranslations('application');
        const [activeDoc, setActiveDoc] = useState<'cv' | 'cover_letter' | 'email'>('cv');
        
        return (
          <div className={cn('space-y-6', className)}>
            {/* Success Header */}
            <Card className="bg-green-50 dark:bg-green-950 border-green-200">
              <CardContent className="py-6">
                <div className="flex items-center gap-4">
                  <div className="w-12 h-12 rounded-full bg-green-100 dark:bg-green-900 flex items-center justify-center">
                    <CheckCircle className="h-6 w-6 text-green-600" />
                  </div>
                  <div>
                    <h2 className="text-xl font-semibold text-green-800 dark:text-green-200">
                      {t('documents_ready')}
                    </h2>
                    <p className="text-green-700 dark:text-green-300">
                      {t('documents_ready_hint')}
                    </p>
                  </div>
                </div>
              </CardContent>
            </Card>
            
            <div className="grid lg:grid-cols-3 gap-6">
              {/* Document Previews - 2 columns */}
              <div className="lg:col-span-2">
                <Card>
                  <CardHeader>
                    <CardTitle>{t('preview_documents')}</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <Tabs value={activeDoc} onValueChange={(v) => setActiveDoc(v as any)}>
                      <TabsList className="grid w-full grid-cols-3">
                        <TabsTrigger value="cv" className="flex items-center gap-2">
                          <FileCheck className="h-4 w-4" />
                          <span className="hidden sm:inline">{t('cv')}</span>
                        </TabsTrigger>
                        <TabsTrigger value="cover_letter" className="flex items-center gap-2">
                          <FileText className="h-4 w-4" />
                          <span className="hidden sm:inline">{t('cover_letter_short')}</span>
                        </TabsTrigger>
                        <TabsTrigger value="email" className="flex items-center gap-2">
                          <Mail className="h-4 w-4" />
                          <span className="hidden sm:inline">{t('email')}</span>
                        </TabsTrigger>
                      </TabsList>
                      
                      <TabsContent value="cv" className="mt-4">
                        <DocumentPreview type="cv" content={documents.tailored_cv} />
                      </TabsContent>
                      <TabsContent value="cover_letter" className="mt-4">
                        <DocumentPreview type="cover_letter" content={documents.cover_letter} />
                      </TabsContent>
                      <TabsContent value="email" className="mt-4">
                        <DocumentPreview type="email" content={documents.application_email} />
                      </TabsContent>
                    </Tabs>
                  </CardContent>
                </Card>
              </div>
              
              {/* Download Panel - 1 column */}
              <div className="space-y-4">
                <DownloadPanel documents={documents} />
                
                {/* New Application Button */}
                <Button
                  variant="outline"
                  className="w-full"
                  onClick={onNewApplication}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  {t('new_application')}
                </Button>
              </div>
            </div>
          </div>
        );
      }
      ```

  25. Create ApplicationWizard.tsx:
      ```typescript
      // ============================================
      // [F134] src/components/application/ApplicationWizard.tsx
      // ============================================
      
      'use client';
      
      import { useEffect } from 'react';
      import { useTranslations } from 'next-intl';
      import { useApplication } from '@/hooks/useApplication';
      import { useCV } from '@/hooks/useCV';
      import { WizardStep } from '@/lib/types';
      import { WizardProgress } from './WizardProgress';
      import { JobDescriptionInput } from './JobDescriptionInput';
      import { PromptSelectionStep } from './PromptSelectionStep';
      import { AIConfigurationStep } from './AIConfigurationStep';
      import { OutputSettingsStep } from './OutputSettingsStep';
      import { ProcessingStep } from './ProcessingStep';
      import { OutputEditor } from './OutputEditor';
      import { FinalDocumentsStep } from './FinalDocumentsStep';
      import { Button } from '@/components/ui/button';
      import { Card, CardContent } from '@/components/ui/card';
      import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
      import { 
        ArrowLeft, ArrowRight, AlertCircle, FileText, Loader2 
      } from 'lucide-react';
      import { cn } from '@/lib/utils';
      import Link from 'next/link';
      import { useParams } from 'next/navigation';
      
      interface ApplicationWizardProps {
        className?: string;
      }
      
      const STEP_ORDER: WizardStep[] = [
        'job_description',
        'prompts',
        'ai_config',
        'settings',
        'processing',
        'editing',
        'final'
      ];
      
      export function ApplicationWizard({ className }: ApplicationWizardProps) {
        const t = useTranslations('application');
        const params = useParams();
        const locale = params.locale as string;
        
        const {
          application,
          loading,
          processing,
          error,
          currentStep,
          setCurrentStep,
          jobDescription,
          setJobDescription,
          selectedPromptIds,
          setSelectedPromptIds,
          aiSelections,
          setAISelections,
          outputLanguage,
          setOutputLanguage,
          toneSetting,
          setToneSetting,
          createApplication,
          startProcessing,
          sendClarification,
          updateDraft,
          finalize,
          reset,
          canProceedToNext,
          draftContent,
          clarificationMessages,
          finalDocuments
        } = useApplication();
        
        const { cv, loading: cvLoading } = useCV();
        
        const currentStepIndex = STEP_ORDER.indexOf(currentStep);
        const completedSteps = STEP_ORDER.slice(0, currentStepIndex);
        
        const canGoBack = currentStepIndex > 0 && currentStepIndex < 4; // Can go back before processing
        const canGoNext = canProceedToNext && currentStepIndex < 4;
        
        const goBack = () => {
          if (canGoBack) {
            setCurrentStep(STEP_ORDER[currentStepIndex - 1]);
          }
        };
        
        const goNext = async () => {
          if (!canGoNext) return;
          
          if (currentStepIndex === 3) {
            // Moving to processing - create application first
            try {
              await createApplication();
              setCurrentStep('processing');
            } catch {}
          } else {
            setCurrentStep(STEP_ORDER[currentStepIndex + 1]);
          }
        };
        
        // Check if CV exists
        if (!cvLoading && !cv) {
          return (
            <Card className={className}>
              <CardContent className="py-12">
                <div className="flex flex-col items-center justify-center text-center">
                  <AlertCircle className="h-12 w-12 text-yellow-500 mb-4" />
                  <h2 className="text-xl font-semibold mb-2">{t('cv_required')}</h2>
                  <p className="text-muted-foreground mb-6 max-w-md">
                    {t('cv_required_hint')}
                  </p>
                  <Link href={`/${locale}/cv-manager`}>
                    <Button>
                      <FileText className="h-4 w-4 mr-2" />
                      {t('go_to_cv_manager')}
                    </Button>
                  </Link>
                </div>
              </CardContent>
            </Card>
          );
        }
        
        if (loading || cvLoading) {
          return (
            <Card className={className}>
              <CardContent className="py-12">
                <div className="flex flex-col items-center justify-center">
                  <Loader2 className="h-8 w-8 animate-spin text-primary mb-4" />
                  <p className="text-muted-foreground">{t('loading')}</p>
                </div>
              </CardContent>
            </Card>
          );
        }
        
        return (
          <div className={cn('space-y-6', className)}>
            {/* Progress */}
            {currentStep !== 'final' && (
              <Card>
                <CardContent className="py-4">
                  <WizardProgress
                    currentStep={currentStep}
                    completedSteps={completedSteps}
                  />
                </CardContent>
              </Card>
            )}
            
            {/* Error Alert */}
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>{t('error')}</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            
            {/* Step Content */}
            <div className="min-h-[400px]">
              {currentStep === 'job_description' && (
                <JobDescriptionInput
                  value={jobDescription}
                  onChange={setJobDescription}
                  disabled={processing}
                />
              )}
              
              {currentStep === 'prompts' && (
                <PromptSelectionStep
                  selectedIds={selectedPromptIds}
                  onSelectionChange={setSelectedPromptIds}
                  disabled={processing}
                />
              )}
              
              {currentStep === 'ai_config' && (
                <AIConfigurationStep
                  selections={aiSelections}
                  onSelectionsChange={setAISelections}
                  disabled={processing}
                />
              )}
              
              {currentStep === 'settings' && (
                <OutputSettingsStep
                  outputLanguage={outputLanguage}
                  onOutputLanguageChange={setOutputLanguage}
                  toneSetting={toneSetting}
                  onToneSettingChange={setToneSetting}
                  disabled={processing}
                />
              )}
              
              {currentStep === 'processing' && (
                <ProcessingStep
                  status={application?.status || 'draft'}
                  clarificationMessages={clarificationMessages}
                  onStartProcessing={startProcessing}
                  onSendClarification={sendClarification}
                  onContinueToEdit={() => setCurrentStep('editing')}
                  isProcessing={processing}
                  error={error}
                  draftReady={!!draftContent}
                />
              )}
              
              {currentStep === 'editing' && draftContent && (
                <OutputEditor
                  content={draftContent}
                  onChange={updateDraft}
                  onFinalize={finalize}
                  isProcessing={processing}
                />
              )}
              
              {currentStep === 'final' && finalDocuments && (
                <FinalDocumentsStep
                  documents={finalDocuments}
                  onNewApplication={reset}
                />
              )}
            </div>
            
            {/* Navigation Buttons */}
            {currentStep !== 'processing' && currentStep !== 'editing' && currentStep !== 'final' && (
              <div className="flex items-center justify-between pt-4 border-t">
                <Button
                  variant="outline"
                  onClick={goBack}
                  disabled={!canGoBack || processing}
                >
                  <ArrowLeft className="h-4 w-4 mr-2" />
                  {t('back')}
                </Button>
                
                <div className="text-sm text-muted-foreground">
                  {t('step_of', { current: currentStepIndex + 1, total: 4 })}
                </div>
                
                <Button
                  onClick={goNext}
                  disabled={!canGoNext || processing}
                >
                  {currentStepIndex === 3 ? t('start_processing') : t('next')}
                  <ArrowRight className="h-4 w-4 ml-2" />
                </Button>
              </div>
            )}
          </div>
        );
      }
      ```

  26. Create new-application/loading.tsx:
      ```typescript
      // ============================================
      // [F141] src/app/[locale]/new-application/loading.tsx
      // ============================================
      
      import { Skeleton } from '@/components/ui/skeleton';
      import { Card, CardContent, CardHeader } from '@/components/ui/card';
      
      export default function Loading() {
        return (
          <div className="container mx-auto p-6 max-w-4xl space-y-6">
            {/* Header */}
            <div className="space-y-2">
              <Skeleton className="h-8 w-64" />
              <Skeleton className="h-4 w-96" />
            </div>
            
            {/* Progress */}
            <Card>
              <CardContent className="py-4">
                <div className="flex items-center justify-between">
                  {Array.from({ length: 7 }).map((_, i) => (
                    <div key={i} className="flex items-center">
                      <Skeleton className="h-10 w-10 rounded-full" />
                      {i < 6 && <Skeleton className="h-0.5 w-12 mx-2" />}
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
            
            {/* Content */}
            <Card>
              <CardHeader>
                <Skeleton className="h-6 w-48" />
                <Skeleton className="h-4 w-72" />
              </CardHeader>
              <CardContent className="space-y-4">
                <Skeleton className="h-64 w-full" />
                <div className="flex justify-between">
                  <Skeleton className="h-10 w-24" />
                  <Skeleton className="h-10 w-24" />
                </div>
              </CardContent>
            </Card>
          </div>
        );
      }
      ```

  27. Create new-application/page.tsx:
      ```typescript
      // ============================================
      // [F014] src/app/[locale]/new-application/page.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { AuthGuard } from '@/components/auth/AuthGuard';
      import { ApplicationWizard } from '@/components/application/ApplicationWizard';
      import { FileEdit } from 'lucide-react';
      
      export default function NewApplicationPage() {
        const t = useTranslations('application');
        
        return (
          <AuthGuard>
            <div className="container mx-auto p-6 max-w-4xl">
              {/* Header */}
              <div className="mb-6">
                <h1 className="text-2xl font-bold flex items-center gap-2">
                  <FileEdit className="h-6 w-6" />
                  {t('new_application_title')}
                </h1>
                <p className="text-muted-foreground mt-1">
                  {t('new_application_description')}
                </p>
              </div>
              
              {/* Wizard */}
              <ApplicationWizard />
            </div>
          </AuthGuard>
        );
      }
      ```

  28. Add translations to en.json under "application" key:
      ```json
      {
        "application": {
          "new_application_title": "New Job Application",
          "new_application_description": "Create tailored CV, cover letter, and application email for a specific job",
          
          "job_description_title": "Job Description",
          "job_description_hint": "Paste the complete job description including requirements, responsibilities, and qualifications",
          "job_description_placeholder": "Paste the job description here...\n\nInclude:\n- Job title and company\n- Required skills and qualifications\n- Responsibilities\n- Any other relevant information",
          "characters": "Characters",
          "words": "Words",
          "min_chars_required": "Minimum {count} characters required",
          "ready": "Ready",
          
          "select_prompts_title": "Select Prompts",
          "select_prompts_description": "Choose one or more prompts that define how your application documents will be created",
          
          "ai_config_title": "AI Configuration",
          "ai_config_description": "Select which AI model to use for generating your documents",
          "no_ai_keys": "No AI API Keys Configured",
          "no_ai_keys_hint": "You need to add at least one AI API key to use this feature",
          "go_to_settings": "Go to Settings",
          "draft_ai": "Draft AI Model",
          "draft_ai_hint": "This model will analyze your CV and job description to create the initial draft",
          "final_ai": "Final AI Model",
          "final_ai_hint": "This model will polish and format the final documents",
          "use_different_final": "Use Different Model for Final Output",
          "use_different_final_hint": "Optionally use a different (possibly more powerful) model for the final documents",
          "provider": "Provider",
          "model": "Model",
          "select_provider": "Select provider",
          "select_model": "Select model",
          "required": "Required",
          "config_summary": "Configuration Summary",
          "draft": "Draft",
          "final": "Final",
          
          "output_settings_title": "Output Settings",
          "output_settings_description": "Configure the language and tone of your application documents",
          "output_language": "Output Language",
          "response_tone": "Response Tone",
          "tone_preset": "Choose Preset",
          "tone_custom": "Custom Description",
          "tone_custom_placeholder": "Describe the tone you want, e.g., 'Confident but humble, with emphasis on technical expertise'",
          "tone_custom_hint": "Describe in your own words how you want the AI to write",
          
          "ready_to_process": "Ready to Process",
          "ready_to_process_hint": "Your CV and job description will be analyzed by AI to create tailored application documents",
          "start_processing": "Start Processing",
          "processing": "Processing...",
          "processing_hint": "AI is analyzing your CV and the job description",
          "processing_error": "Processing Error",
          "try_again": "Try Again",
          
          "ai_clarification": "AI Clarification",
          "ai_needs_info": "AI Needs More Information",
          "ai_needs_info_hint": "Please answer the AI's questions to continue",
          "type_response": "Type your response...",
          
          "draft_ready": "Draft Ready",
          "draft_ready_hint": "The AI has created a draft. Review and edit before generating final documents.",
          "review_and_edit": "Review & Edit",
          
          "edit_draft": "Edit Draft",
          "edit_draft_description": "Review and edit the AI-generated content before creating final documents",
          "edit": "Edit",
          "preview": "Preview",
          "editor_placeholder": "Content will appear here...",
          "generate_final": "Generate Final Documents",
          "generating": "Generating...",
          
          "documents_ready": "Documents Ready!",
          "documents_ready_hint": "Your tailored application documents have been generated successfully",
          "preview_documents": "Preview Documents",
          "tailored_cv": "Tailored CV",
          "cover_letter": "Cover Letter",
          "cover_letter_short": "Cover Letter",
          "application_email": "Application Email",
          "email": "Email",
          "cv": "CV",
          
          "download_documents": "Download Documents",
          "download_description": "Download your documents in Word or Markdown format",
          "download_all": "Download All (Word)",
          
          "new_application": "Start New Application",
          
          "cv_required": "CV Required",
          "cv_required_hint": "You need to upload your CV before creating a job application",
          "go_to_cv_manager": "Go to CV Manager",
          
          "loading": "Loading...",
          "error": "Error",
          "back": "Back",
          "next": "Next",
          "step_of": "Step {current} of {total}"
        }
      }
      ```

  29. Add translations to fa.json under "application" key:
      ```json
      {
        "application": {
          "new_application_title": "درخواست شغلی جدید",
          "new_application_description": "ایجاد سی‌وی، کاورلتر و ایمیل درخواست اختصاصی برای یک شغل خاص",
          
          "job_description_title": "شرح شغل",
          "job_description_hint": "شرح شغل کامل شامل الزامات، مسئولیت‌ها و صلاحیت‌ها را وارد کنید",
          "job_description_placeholder": "شرح شغل را اینجا بچسبانید...\n\nشامل:\n- عنوان شغل و شرکت\n- مهارت‌ها و صلاحیت‌های مورد نیاز\n- مسئولیت‌ها\n- سایر اطلاعات مرتبط",
          "characters": "کاراکتر",
          "words": "کلمه",
          "min_chars_required": "حداقل {count} کاراکتر لازم است",
          "ready": "آماده",
          
          "select_prompts_title": "انتخاب پرامپت‌ها",
          "select_prompts_description": "یک یا چند پرامپت انتخاب کنید که نحوه ایجاد مستندات را تعیین می‌کنند",
          
          "ai_config_title": "پیکربندی هوش مصنوعی",
          "ai_config_description": "انتخاب کنید کدام مدل هوش مصنوعی برای تولید مستندات استفاده شود",
          "no_ai_keys": "کلید API تنظیم نشده است",
          "no_ai_keys_hint": "برای استفاده از این ویژگی باید حداقل یک کلید API اضافه کنید",
          "go_to_settings": "رفتن به تنظیمات",
          "draft_ai": "مدل AI پیش‌نویس",
          "draft_ai_hint": "این مدل سی‌وی و شرح شغل را تحلیل کرده و پیش‌نویس اولیه را ایجاد می‌کند",
          "final_ai": "مدل AI نهایی",
          "final_ai_hint": "این مدل مستندات نهایی را تکمیل و فرمت می‌کند",
          "use_different_final": "استفاده از مدل متفاوت برای خروجی نهایی",
          "use_different_final_hint": "اختیاری: از یک مدل متفاوت (احتمالاً قوی‌تر) برای مستندات نهایی استفاده کنید",
          "provider": "سرویس‌دهنده",
          "model": "مدل",
          "select_provider": "انتخاب سرویس",
          "select_model": "انتخاب مدل",
          "required": "الزامی",
          "config_summary": "خلاصه پیکربندی",
          "draft": "پیش‌نویس",
          "final": "نهایی",
          
          "output_settings_title": "تنظیمات خروجی",
          "output_settings_description": "زبان و لحن مستندات درخواست را پیکربندی کنید",
          "output_language": "زبان خروجی",
          "response_tone": "لحن پاسخ",
          "tone_preset": "انتخاب از پیش‌فرض",
          "tone_custom": "توضیح سفارشی",
          "tone_custom_placeholder": "لحن مورد نظر را توصیف کنید، مثلاً 'مطمئن اما فروتن، با تأکید بر تخصص فنی'",
          "tone_custom_hint": "با کلمات خودتان توضیح دهید می‌خواهید AI چگونه بنویسد",
          
          "ready_to_process": "آماده پردازش",
          "ready_to_process_hint": "سی‌وی و شرح شغل شما توسط هوش مصنوعی تحلیل خواهد شد",
          "start_processing": "شروع پردازش",
          "processing": "در حال پردازش...",
          "processing_hint": "هوش مصنوعی در حال تحلیل سی‌وی و شرح شغل است",
          "processing_error": "خطا در پردازش",
          "try_again": "تلاش مجدد",
          
          "ai_clarification": "توضیحات هوش مصنوعی",
          "ai_needs_info": "هوش مصنوعی به اطلاعات بیشتری نیاز دارد",
          "ai_needs_info_hint": "لطفاً به سوالات هوش مصنوعی پاسخ دهید",
          "type_response": "پاسخ خود را بنویسید...",
          
          "draft_ready": "پیش‌نویس آماده است",
          "draft_ready_hint": "هوش مصنوعی پیش‌نویس را ایجاد کرده است. قبل از تولید مستندات نهایی بررسی و ویرایش کنید.",
          "review_and_edit": "بررسی و ویرایش",
          
          "edit_draft": "ویرایش پیش‌نویس",
          "edit_draft_description": "محتوای تولید شده توسط AI را قبل از ایجاد مستندات نهایی بررسی و ویرایش کنید",
          "edit": "ویرایش",
          "preview": "پیش‌نمایش",
          "editor_placeholder": "محتوا اینجا نمایش داده می‌شود...",
          "generate_final": "تولید مستندات نهایی",
          "generating": "در حال تولید...",
          
          "documents_ready": "مستندات آماده است!",
          "documents_ready_hint": "مستندات درخواست شغلی شما با موفقیت تولید شد",
          "preview_documents": "پیش‌نمایش مستندات",
          "tailored_cv": "سی‌وی اختصاصی",
          "cover_letter": "کاورلتر",
          "cover_letter_short": "کاورلتر",
          "application_email": "ایمیل درخواست",
          "email": "ایمیل",
          "cv": "سی‌وی",
          
          "download_documents": "دانلود مستندات",
          "download_description": "مستندات را به فرمت Word یا Markdown دانلود کنید",
          "download_all": "دانلود همه (Word)",
          
          "new_application": "شروع درخواست جدید",
          
          "cv_required": "سی‌وی الزامی است",
          "cv_required_hint": "قبل از ایجاد درخواست شغلی باید سی‌وی خود را آپلود کنید",
          "go_to_cv_manager": "رفتن به مدیریت سی‌وی",
          
          "loading": "در حال بارگذاری...",
          "error": "خطا",
          "back": "بازگشت",
          "next": "بعدی",
          "step_of": "مرحله {current} از {total}"
        }
      }
      ```

checkpoint_tests:
  - id: T01
    description: "All application service files exist"
    type: "files_exist"
    files:
      - "src/lib/applications/application-service.ts"
      - "src/lib/applications/application-processor.ts"
      - "src/lib/applications/application-prompts.ts"
      - "src/lib/applications/index.ts"

  - id: T02
    description: "All API route files exist"
    type: "files_exist"
    files:
      - "src/app/api/applications/route.ts"
      - "src/app/api/applications/[id]/route.ts"
      - "src/app/api/applications/[id]/process/route.ts"
      - "src/app/api/applications/[id]/clarify/route.ts"
      - "src/app/api/applications/[id]/finalize/route.ts"

  - id: T03
    description: "useApplication hook exists"
    type: "files_exist"
    files:
      - "src/hooks/useApplication.ts"

  - id: T04
    description: "All wizard component files exist"
    type: "files_exist"
    files:
      - "src/components/application/ApplicationWizard.tsx"
      - "src/components/application/WizardProgress.tsx"
      - "src/components/application/JobDescriptionInput.tsx"
      - "src/components/application/PromptSelectionStep.tsx"
      - "src/components/application/AIConfigurationStep.tsx"
      - "src/components/application/OutputSettingsStep.tsx"
      - "src/components/application/LanguageSelector.tsx"
      - "src/components/application/ToneSelector.tsx"
      - "src/components/application/ProcessingStep.tsx"
      - "src/components/application/OutputEditor.tsx"
      - "src/components/application/FinalDocumentsStep.tsx"
      - "src/components/application/DocumentPreview.tsx"
      - "src/components/application/DownloadPanel.tsx"

  - id: T05
    description: "AIChatInterface component exists"
    type: "files_exist"
    files:
      - "src/components/ai/AIChatInterface.tsx"

  - id: T06
    description: "Page files exist"
    type: "files_exist"
    files:
      - "src/app/[locale]/new-application/page.tsx"
      - "src/app/[locale]/new-application/loading.tsx"

  - id: T07
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T08
    description: "Application service has all CRUD methods"
    type: "grep"
    file: "src/lib/applications/application-service.ts"
    patterns:
      - "createApplication"
      - "getApplication"
      - "updateApplication"
      - "deleteApplication"
      - "saveDraftContent"
      - "saveFinalDocuments"
      - "addClarificationMessage"

  - id: T09
    description: "Application processor uses AI providers"
    type: "grep"
    file: "src/lib/applications/application-processor.ts"
    patterns:
      - "getAIProvider"
      - "processApplication"
      - "generateFinalDocuments"

  - id: T10
    description: "useApplication hook has all state and actions"
    type: "grep"
    file: "src/hooks/useApplication.ts"
    patterns:
      - "jobDescription"
      - "selectedPromptIds"
      - "aiSelections"
      - "createApplication"
      - "startProcessing"
      - "sendClarification"
      - "finalize"

  - id: T11
    description: "ApplicationWizard integrates all steps"
    type: "grep"
    file: "src/components/application/ApplicationWizard.tsx"
    patterns:
      - "JobDescriptionInput"
      - "PromptSelectionStep"
      - "AIConfigurationStep"
      - "OutputSettingsStep"
      - "ProcessingStep"
      - "OutputEditor"
      - "FinalDocumentsStep"

  - id: T12
    description: "Page uses AuthGuard"
    type: "grep"
    file: "src/app/[locale]/new-application/page.tsx"
    patterns:
      - "AuthGuard"
      - "ApplicationWizard"

  - id: T13
    description: "English translations have all application keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "new_application_title"
      - "job_description_title"
      - "select_prompts_title"
      - "ai_config_title"
      - "documents_ready"

  - id: T14
    description: "Farsi translations have all application keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "new_application_title"
      - "job_description_title"
      - "documents_ready"

  - id: T15
    description: "Types include application workflow types"
    type: "grep"
    file: "src/lib/types.ts"
    patterns:
      - "ApplicationStatus"
      - "WizardStep"
      - "AIModelSelection"
      - "ClarificationMessage"
      - "FinalDocuments"

max_retries: 3
خلاصه بلوک B18
فایل‌های ایجاد شده
دسته	تعداد	فایل‌ها
Service Layer	4	application-service, application-processor, application-prompts, index
API Routes	5	route, [id]/route, process, clarify, finalize
React Hook	1	useApplication
Wizard Components	13	ApplicationWizard, WizardProgress, JobDescriptionInput, PromptSelectionStep, AIConfigurationStep, OutputSettingsStep, LanguageSelector, ToneSelector, ProcessingStep, OutputEditor, FinalDocumentsStep, DocumentPreview, DownloadPanel
AI Components	1	AIChatInterface
Pages	2	page.tsx, loading.tsx
Translations	2	en.json, fa.json updates
Types	1	types.ts updates
مجموع	29 فایل	
جریان کار (Workflow)
text

┌─────────────────────────────────────────────────────────────────┐
│                    APPLICATION WIZARD                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  Step 1: Job Description                                          │
│  └── User pastes job description                                  │
│          │                                                        │
│          ▼                                                        │
│  Step 2: Select Prompts                                           │
│  └── User chooses 1+ prompts for CV tailoring style              │
│          │                                                        │
│          ▼                                                        │
│  Step 3: AI Configuration                                         │
│  └── User selects AI provider/model for draft (and optional final)│
│          │                                                        │
│          ▼                                                        │
│  Step 4: Output Settings                                          │
│  └── User selects output language (8 options) and tone           │
│          │                                                        │
│          ▼                                                        │
│  Step 5: Processing                                               │
│  ├── AI analyzes CV + Job Description                            │
│  ├── If clarification needed → Chat interface                    │
│  └── When ready → Draft output                                   │
│          │                                                        │
│          ▼                                                        │
│  Step 6: Edit Draft                                               │
│  └── User reviews and edits AI output with rich text editor      │
│          │                                                        │
│          ▼                                                        │
│  Step 7: Final Documents                                          │
│  ├── AI generates 3 polished documents:                          │
│  │   • Tailored CV                                               │
│  │   • Cover Letter                                              │
│  │   • Application Email                                         │
│  └── Download in Word or Markdown                                │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
ویژگی‌های کلیدی
✅ Wizard چند مرحله‌ای با نمایش پیشرفت

✅ انتخاب چند پرامپت برای استایل‌های مختلف

✅ پیکربندی AI انعطاف‌پذیر — مدل‌های مختلف برای Draft و Final

✅ ۸ زبان خروجی پشتیبانی شده

✅ لحن قابل تنظیم — پیش‌فرض یا سفارشی

✅ حلقه Clarification — AI می‌تواند سوال بپرسد

✅ ویرایشگر Rich Text برای اصلاح Draft

✅ دانلود Word و Markdown برای هر ۳ سند

✅ دوزبانه کامل — فارسی و انگلیسی

آیا می‌خواهی بلوک‌های بعدی (B19 به بعد — Export، Templates، Dashboard، Applications List، Google Auth) را هم بنویسم؟





در فایل بعدی بنویس

claude-opus-4-5-20251101-thinking-32k

Thought for 3 seconds

بلوک B18 — فرایند اصلی اپلیکیشن (New Application Wizard)
B18.yaml — سیستم کامل ایجاد درخواست شغلی
YAML

# blocks/B18.yaml

id: B18
name: "New Application Wizard - Core Workflow"
phase: 3
phase_name: "Core Application Flow"

goal: |
  Create the complete job application workflow - the core feature of the app.
  This is a multi-step wizard that:
  1. Collects job description
  2. Lets user select prompts
  3. Configures AI (provider/model for draft and final)
  4. Sets output language and tone
  5. Processes with AI (with clarification loop if needed)
  6. Shows editable draft output
  7. Generates 3 final documents (Tailored CV, Cover Letter, Application Email)
  8. Allows download in Word and Markdown formats

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13, B14, B15, B16, B17]

files_to_create:
  # Service Layer
  - id: F125
    path: "src/lib/applications/application-service.ts"
    description: "Service for job application CRUD and workflow"

  - id: F126
    path: "src/lib/applications/application-processor.ts"
    description: "AI processing logic for applications"

  - id: F127
    path: "src/lib/applications/application-prompts.ts"
    description: "Prompt templates for application processing"

  - id: F128
    path: "src/lib/applications/index.ts"
    description: "Export all application modules"

  # API Routes
  - id: F129
    path: "src/app/api/applications/route.ts"
    description: "API for applications list and create"

  - id: F130
    path: "src/app/api/applications/[id]/route.ts"
    description: "API for single application CRUD"

  - id: F131
    path: "src/app/api/applications/[id]/process/route.ts"
    description: "API to start AI processing"

  - id: F132
    path: "src/app/api/applications/[id]/clarify/route.ts"
    description: "API for clarification responses"

  - id: F133
    path: "src/app/api/applications/[id]/finalize/route.ts"
    description: "API to generate final documents"

  # React Hook
  - id: F084
    path: "src/hooks/useApplication.ts"
    description: "React hook for application workflow"

  # Wizard Components
  - id: F134
    path: "src/components/application/ApplicationWizard.tsx"
    description: "Main wizard container with step navigation"

  - id: F135
    path: "src/components/application/WizardProgress.tsx"
    description: "Progress indicator for wizard steps"

  - id: F054
    path: "src/components/application/JobDescriptionInput.tsx"
    description: "Step 1: Job description input"

  - id: F136
    path: "src/components/application/PromptSelectionStep.tsx"
    description: "Step 2: Select prompts"

  - id: F137
    path: "src/components/application/AIConfigurationStep.tsx"
    description: "Step 3: Configure AI models"

  - id: F056
    path: "src/components/application/LanguageSelector.tsx"
    description: "Output language selection"

  - id: F055
    path: "src/components/application/ToneSelector.tsx"
    description: "Tone selection (preset or custom)"

  - id: F138
    path: "src/components/application/OutputSettingsStep.tsx"
    description: "Step 4: Language and tone settings"

  - id: F139
    path: "src/components/application/ProcessingStep.tsx"
    description: "Step 5: AI processing with clarification"

  - id: F052
    path: "src/components/ai/AIChatInterface.tsx"
    description: "Chat interface for AI clarification"

  - id: F057
    path: "src/components/application/OutputEditor.tsx"
    description: "Step 6: Edit draft output"

  - id: F140
    path: "src/components/application/FinalDocumentsStep.tsx"
    description: "Step 7: View and download final documents"

  - id: F058
    path: "src/components/application/DocumentPreview.tsx"
    description: "Preview a single document"

  - id: F059
    path: "src/components/application/DownloadPanel.tsx"
    description: "Download buttons for all formats"

  # Page
  - id: F014
    path: "src/app/[locale]/new-application/page.tsx"
    description: "New application page"

  - id: F141
    path: "src/app/[locale]/new-application/loading.tsx"
    description: "Loading state"

files_to_modify:
  - id: F079
    path: "src/lib/types.ts"
    description: "Add application workflow types"

  - id: F087
    path: "src/i18n/en.json"
    description: "Add application translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add application translations"

files_available:
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F028
    path: "src/components/ui/input.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F030
    path: "src/components/ui/dialog.tsx"
    from_block: B02
  - id: F031
    path: "src/components/ui/select.tsx"
    from_block: B02
  - id: F032
    path: "src/components/ui/textarea.tsx"
    from_block: B02
  - id: F033
    path: "src/components/ui/tabs.tsx"
    from_block: B02
  - id: F034
    path: "src/components/ui/badge.tsx"
    from_block: B02
  - id: F063
    path: "src/lib/supabase/client.ts"
    from_block: B06
  - id: F064
    path: "src/lib/supabase/server.ts"
    from_block: B06
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F066
    path: "src/lib/ai/ai-provider.ts"
    from_block: B10
  - id: F070
    path: "src/lib/ai/ai-factory.ts"
    from_block: B10
  - id: F077
    path: "src/lib/encryption.ts"
    from_block: B11
  - id: F081
    path: "src/hooks/useAIKeys.ts"
    from_block: B11
  - id: F082
    path: "src/hooks/useCV.ts"
    from_block: B15
  - id: F047
    path: "src/components/prompts/PromptSelector.tsx"
    from_block: B17
  - id: F083
    path: "src/hooks/usePrompts.ts"
    from_block: B17
  - id: F090
    path: "src/context/AuthContext.tsx"
    from_block: B07
  - id: F092
    path: "src/components/auth/AuthGuard.tsx"
    from_block: B07

commands: []

instructions: |
  1. First, add new types to types.ts:
     ```typescript
     // Add to existing types.ts file
     
     // ============================================
     // Application Workflow Types
     // ============================================
     
     export type ApplicationStatus = 
       | 'draft'           // Initial state, collecting inputs
       | 'processing'      // AI is processing
       | 'clarification'   // AI needs more info
       | 'draft_ready'     // Draft output ready for review
       | 'editing'         // User is editing draft
       | 'finalizing'      // Generating final documents
       | 'completed'       // All done
       | 'error';          // Something went wrong
     
     export type WizardStep = 
       | 'job_description'
       | 'prompts'
       | 'ai_config'
       | 'settings'
       | 'processing'
       | 'editing'
       | 'final';
     
     export interface AIModelSelection {
       provider: AIProviderName;
       model: string;
       role: 'draft' | 'final';
     }
     
     export interface ClarificationMessage {
       id: string;
       role: 'assistant' | 'user';
       content: string;
       timestamp: string;
     }
     
     export interface DraftDocument {
       type: 'cv' | 'cover_letter' | 'email';
       content: string;
       generatedAt: string;
       aiProvider: AIProviderName;
       aiModel: string;
     }
     
     export interface FinalDocuments {
       tailored_cv: string;
       cover_letter: string;
       application_email: string;
       generatedAt: string;
     }
     
     export interface JobApplication {
       id: string;
       user_id: string;
       
       // Inputs
       job_description: string;
       selected_prompt_ids: string[];
       ai_selections: AIModelSelection[];
       output_language: OutputLanguage;
       tone_setting: ToneSetting;
       
       // Processing state
       status: ApplicationStatus;
       current_step: WizardStep;
       clarification_messages: ClarificationMessage[];
       
       // Outputs
       draft_content: string | null;
       draft_documents: DraftDocument[] | null;
       edited_content: string | null;
       final_documents: FinalDocuments | null;
       
       // Metadata
       error_message: string | null;
       created_at: string;
       updated_at: string;
     }
     
     export interface CreateApplicationInput {
       job_description: string;
       selected_prompt_ids: string[];
       ai_selections: AIModelSelection[];
       output_language: OutputLanguage;
       tone_setting: ToneSetting;
     }
     ```

  2. Create application-prompts.ts:
     ```typescript
     // ============================================
     // [F127] src/lib/applications/application-prompts.ts
     // ============================================
     
     import { OutputLanguage, ToneSetting } from '@/lib/types';
     import { SUPPORTED_OUTPUT_LANGUAGES } from '@/lib/constants';
     
     export function buildSystemPrompt(
       selectedPromptTexts: string[],
       outputLanguage: OutputLanguage,
       toneSetting: ToneSetting
     ): string {
       const languageInfo = SUPPORTED_OUTPUT_LANGUAGES.find(l => l.code === outputLanguage);
       const languageName = languageInfo?.label_en || 'English';
       
       const toneInstruction = toneSetting.mode === 'preset'
         ? `Use a ${toneSetting.preset_value} tone.`
         : `Use the following tone: ${toneSetting.custom_text}`;
       
       return `You are an expert career consultant and professional CV writer.

     YOUR TASK:
     Analyze the candidate's CV and the target job description to create tailored application documents.

     SELECTED APPROACH(ES):
     ${selectedPromptTexts.map((text, i) => `--- Approach ${i + 1} ---\n${text}`).join('\n\n')}

     OUTPUT REQUIREMENTS:
     - Language: ${languageName}
     - ${toneInstruction}
     - Be professional, accurate, and compelling
     - Do not fabricate information - only use what's in the CV
     - Highlight relevant experience and skills for the specific job

     PROCESS:
     1. First, analyze both documents carefully
     2. If you need clarification about anything, ASK before proceeding
     3. Once you have all information, create the tailored content

     When ready to produce output, format it clearly with sections marked.`;
     }
     
     export function buildUserPrompt(
       cvContent: string,
       jobDescription: string
     ): string {
       return `Please analyze the following and create tailored application documents:

     ===== CANDIDATE'S CV =====
     ${cvContent}

     ===== TARGET JOB DESCRIPTION =====
     ${jobDescription}

     ===== INSTRUCTIONS =====
     1. First, tell me if you need any clarification
     2. If not, proceed to create:
        - A tailored CV for this specific job
        - A compelling cover letter
        - A professional application email

     Please begin your analysis.`;
     }
     
     export function buildClarificationPrompt(
       previousContext: string,
       userResponse: string
     ): string {
       return `${previousContext}

     User's response to your question:
     ${userResponse}

     Please continue with the analysis. If you need more clarification, ask. Otherwise, proceed to create the documents.`;
     }
     
     export function buildFinalizationPrompt(
       draftContent: string,
       userEdits: string | null,
       outputLanguage: OutputLanguage
     ): string {
       const languageInfo = SUPPORTED_OUTPUT_LANGUAGES.find(l => l.code === outputLanguage);
       const languageName = languageInfo?.label_en || 'English';
       
       const editNote = userEdits 
         ? `\n\nThe user has made the following edits/notes:\n${userEdits}`
         : '';
       
       return `Based on the analysis and draft below, please create the final polished documents.
     
     Output language: ${languageName}
     ${editNote}

     ===== DRAFT CONTENT =====
     ${draftContent}

     ===== REQUIRED OUTPUT FORMAT =====
     Please provide the final documents in this exact format:

     <<<TAILORED_CV>>>
     [The complete tailored CV here]
     <<<END_TAILORED_CV>>>

     <<<COVER_LETTER>>>
     [The complete cover letter here]
     <<<END_COVER_LETTER>>>

     <<<APPLICATION_EMAIL>>>
     [The complete application email here]
     <<<END_APPLICATION_EMAIL>>>

     Make sure each document is complete, professional, and ready to use.`;
     }
     
     export function parseFinalizationResponse(response: string): {
       tailored_cv: string;
       cover_letter: string;
       application_email: string;
     } | null {
       try {
         const cvMatch = response.match(/<<<TAILORED_CV>>>([\s\S]*?)<<<END_TAILORED_CV>>>/);
         const coverMatch = response.match(/<<<COVER_LETTER>>>([\s\S]*?)<<<END_COVER_LETTER>>>/);
         const emailMatch = response.match(/<<<APPLICATION_EMAIL>>>([\s\S]*?)<<<END_APPLICATION_EMAIL>>>/);
         
         if (!cvMatch || !coverMatch || !emailMatch) {
           return null;
         }
         
         return {
           tailored_cv: cvMatch[1].trim(),
           cover_letter: coverMatch[1].trim(),
           application_email: emailMatch[1].trim()
         };
       } catch {
         return null;
       }
     }
     
     export function detectClarificationNeeded(response: string): boolean {
       const clarificationIndicators = [
         /\?$/m,  // Ends with question mark
         /could you (please )?(clarify|explain|provide|tell)/i,
         /I need (more |additional )?(information|details|clarification)/i,
         /can you (please )?(specify|elaborate|describe)/i,
         /what (do you mean|is|are|would)/i,
         /which (one|option|role|position)/i,
         /please (clarify|explain|provide|specify)/i,
       ];
       
       return clarificationIndicators.some(pattern => pattern.test(response));
     }
     ```

  3. Create application-service.ts:
     ```typescript
     // ============================================
     // [F125] src/lib/applications/application-service.ts
     // ============================================
     
     import { SupabaseClient } from '@supabase/supabase-js';
     import { 
       JobApplication, 
       CreateApplicationInput,
       ApplicationStatus,
       WizardStep,
       ClarificationMessage 
     } from '@/lib/types';
     import { generateId } from '@/lib/utils';
     
     export class ApplicationService {
       constructor(private supabase: SupabaseClient) {}
       
       async createApplication(
         userId: string, 
         input: CreateApplicationInput
       ): Promise<JobApplication> {
         const application = {
           user_id: userId,
           job_description: input.job_description,
           selected_prompt_ids: input.selected_prompt_ids,
           ai_selections: input.ai_selections,
           output_language: input.output_language,
           tone_setting: input.tone_setting,
           status: 'draft' as ApplicationStatus,
           current_step: 'job_description' as WizardStep,
           clarification_messages: [],
           draft_content: null,
           draft_documents: null,
           edited_content: null,
           final_documents: null,
           error_message: null
         };
         
         const { data, error } = await this.supabase
           .from('job_applications')
           .insert(application)
           .select()
           .single();
         
         if (error) throw error;
         return this.mapToJobApplication(data);
       }
       
       async getApplication(id: string, userId: string): Promise<JobApplication | null> {
         const { data, error } = await this.supabase
           .from('job_applications')
           .select('*')
           .eq('id', id)
           .eq('user_id', userId)
           .single();
         
         if (error) {
           if (error.code === 'PGRST116') return null;
           throw error;
         }
         
         return this.mapToJobApplication(data);
       }
       
       async getUserApplications(userId: string): Promise<JobApplication[]> {
         const { data, error } = await this.supabase
           .from('job_applications')
           .select('*')
           .eq('user_id', userId)
           .order('created_at', { ascending: false });
         
         if (error) throw error;
         return (data || []).map(this.mapToJobApplication);
       }
       
       async updateApplication(
         id: string, 
         userId: string, 
         updates: Partial<JobApplication>
       ): Promise<JobApplication> {
         // Remove fields that shouldn't be updated directly
         const { id: _, user_id, created_at, ...validUpdates } = updates as any;
         
         const { data, error } = await this.supabase
           .from('job_applications')
           .update(validUpdates)
           .eq('id', id)
           .eq('user_id', userId)
           .select()
           .single();
         
         if (error) throw error;
         return this.mapToJobApplication(data);
       }
       
       async updateStatus(
         id: string, 
         userId: string, 
         status: ApplicationStatus,
         step?: WizardStep
       ): Promise<JobApplication> {
         const updates: any = { status };
         if (step) updates.current_step = step;
         
         return this.updateApplication(id, userId, updates);
       }
       
       async addClarificationMessage(
         id: string,
         userId: string,
         role: 'assistant' | 'user',
         content: string
       ): Promise<JobApplication> {
         const app = await this.getApplication(id, userId);
         if (!app) throw new Error('Application not found');
         
         const message: ClarificationMessage = {
           id: generateId(),
           role,
           content,
           timestamp: new Date().toISOString()
         };
         
         const messages = [...(app.clarification_messages || []), message];
         
         return this.updateApplication(id, userId, { 
           clarification_messages: messages,
           status: role === 'assistant' ? 'clarification' : 'processing'
         });
       }
       
       async saveDraftContent(
         id: string,
         userId: string,
         content: string
       ): Promise<JobApplication> {
         return this.updateApplication(id, userId, {
           draft_content: content,
           status: 'draft_ready',
           current_step: 'editing'
         });
       }
       
       async saveEditedContent(
         id: string,
         userId: string,
         content: string
       ): Promise<JobApplication> {
         return this.updateApplication(id, userId, {
           edited_content: content,
           status: 'editing'
         });
       }
       
       async saveFinalDocuments(
         id: string,
         userId: string,
         documents: {
           tailored_cv: string;
           cover_letter: string;
           application_email: string;
         }
       ): Promise<JobApplication> {
         return this.updateApplication(id, userId, {
           final_documents: {
             ...documents,
             generatedAt: new Date().toISOString()
           },
           status: 'completed',
           current_step: 'final'
         });
       }
       
       async setError(
         id: string,
         userId: string,
         errorMessage: string
       ): Promise<JobApplication> {
         return this.updateApplication(id, userId, {
           status: 'error',
           error_message: errorMessage
         });
       }
       
       async deleteApplication(id: string, userId: string): Promise<void> {
         const { error } = await this.supabase
           .from('job_applications')
           .delete()
           .eq('id', id)
           .eq('user_id', userId);
         
         if (error) throw error;
       }
       
       private mapToJobApplication(data: any): JobApplication {
         return {
           id: data.id,
           user_id: data.user_id,
           job_description: data.job_description,
           selected_prompt_ids: data.selected_prompt_ids || [],
           ai_selections: data.ai_selections || [],
           output_language: data.output_language,
           tone_setting: data.tone_setting,
           status: data.status,
           current_step: data.current_step,
           clarification_messages: data.clarification_messages || [],
           draft_content: data.draft_content,
           draft_documents: data.draft_documents,
           edited_content: data.edited_content,
           final_documents: data.final_documents,
           error_message: data.error_message,
           created_at: data.created_at,
           updated_at: data.updated_at
         };
       }
     }
     
     export function createApplicationService(supabase: SupabaseClient): ApplicationService {
       return new ApplicationService(supabase);
     }
     ```

  4. Create application-processor.ts:
     ```typescript
     // ============================================
     // [F126] src/lib/applications/application-processor.ts
     // ============================================
     
     import { getAIProvider } from '@/lib/ai';
     import { AIProviderConfig, AICompletionOptions } from '@/lib/ai/ai-provider';
     import { 
       JobApplication, 
       AIModelSelection, 
       ComprehensiveCV,
       Prompt,
       OutputLanguage,
       ToneSetting
     } from '@/lib/types';
     import {
       buildSystemPrompt,
       buildUserPrompt,
       buildClarificationPrompt,
       buildFinalizationPrompt,
       parseFinalizationResponse,
       detectClarificationNeeded
     } from './application-prompts';
     
     export interface ProcessingContext {
       application: JobApplication;
       cv: ComprehensiveCV;
       prompts: Prompt[];
       apiKeys: Record<string, string>;  // provider -> decrypted key
     }
     
     export interface ProcessingResult {
       success: boolean;
       needsClarification: boolean;
       content: string;
       error?: string;
     }
     
     export async function processApplication(
       context: ProcessingContext,
       onStream?: (chunk: string) => void
     ): Promise<ProcessingResult> {
       const { application, cv, prompts, apiKeys } = context;
       
       // Get the AI selection for draft (or first selection)
       const draftSelection = application.ai_selections.find(s => s.role === 'draft')
         || application.ai_selections[0];
       
       if (!draftSelection) {
         return { success: false, needsClarification: false, content: '', error: 'No AI model selected' };
       }
       
       const apiKey = apiKeys[draftSelection.provider];
       if (!apiKey) {
         return { success: false, needsClarification: false, content: '', error: `No API key for ${draftSelection.provider}` };
       }
       
       try {
         const provider = getAIProvider(draftSelection.provider);
         
         // Build prompts
         const promptTexts = prompts.map(p => p.prompt_text);
         const systemPrompt = buildSystemPrompt(
           promptTexts,
           application.output_language,
           application.tone_setting
         );
         
         // Build CV content string
         const cvContent = formatCVForPrompt(cv);
         const userPrompt = buildUserPrompt(cvContent, application.job_description);
         
         // Include any previous clarification context
         let messages = [
           { role: 'system' as const, content: systemPrompt },
           { role: 'user' as const, content: userPrompt }
         ];
         
         // Add clarification history if exists
         if (application.clarification_messages && application.clarification_messages.length > 0) {
           for (const msg of application.clarification_messages) {
             messages.push({
               role: msg.role as 'assistant' | 'user',
               content: msg.content
             });
           }
         }
         
         const config: AIProviderConfig = {
           apiKey,
           temperature: 0.7,
           maxTokens: 4096
         };
         
         const options: AICompletionOptions = {
           model: draftSelection.model,
           messages
         };
         
         let response: string;
         
         if (onStream) {
           response = await provider.streamComplete(config, options, onStream);
         } else {
           response = await provider.complete(config, options);
         }
         
         const needsClarification = detectClarificationNeeded(response);
         
         return {
           success: true,
           needsClarification,
           content: response
         };
         
       } catch (error: any) {
         return {
           success: false,
           needsClarification: false,
           content: '',
           error: error.message || 'Processing failed'
         };
       }
     }
     
     export async function generateFinalDocuments(
       context: ProcessingContext,
       draftContent: string,
       userEdits: string | null,
       onStream?: (chunk: string) => void
     ): Promise<{
       success: boolean;
       documents?: {
         tailored_cv: string;
         cover_letter: string;
         application_email: string;
       };
       error?: string;
     }> {
       const { application, apiKeys } = context;
       
       // Get the AI selection for final (or draft selection)
       const finalSelection = application.ai_selections.find(s => s.role === 'final')
         || application.ai_selections.find(s => s.role === 'draft')
         || application.ai_selections[0];
       
       if (!finalSelection) {
         return { success: false, error: 'No AI model selected for finalization' };
       }
       
       const apiKey = apiKeys[finalSelection.provider];
       if (!apiKey) {
         return { success: false, error: `No API key for ${finalSelection.provider}` };
       }
       
       try {
         const provider = getAIProvider(finalSelection.provider);
         
         const finalizationPrompt = buildFinalizationPrompt(
           draftContent,
           userEdits,
           application.output_language
         );
         
         const config: AIProviderConfig = {
           apiKey,
           temperature: 0.3,  // Lower temperature for consistent output
           maxTokens: 8192
         };
         
         const options: AICompletionOptions = {
           model: finalSelection.model,
           messages: [
             { role: 'user', content: finalizationPrompt }
           ]
         };
         
         let response: string;
         
         if (onStream) {
           response = await provider.streamComplete(config, options, onStream);
         } else {
           response = await provider.complete(config, options);
         }
         
         const documents = parseFinalizationResponse(response);
         
         if (!documents) {
           return { 
             success: false, 
             error: 'Failed to parse AI response into documents. The AI may not have followed the required format.'
           };
         }
         
         return { success: true, documents };
         
       } catch (error: any) {
         return {
           success: false,
           error: error.message || 'Finalization failed'
         };
       }
     }
     
     function formatCVForPrompt(cv: ComprehensiveCV): string {
       const sections: string[] = [];
       
       // Personal Info
       if (cv.personal_info) {
         const pi = cv.personal_info;
         sections.push(`PERSONAL INFORMATION:
     Name: ${pi.full_name || 'N/A'}
     Email: ${pi.email || 'N/A'}
     Phone: ${pi.phone || 'N/A'}
     Location: ${pi.location || 'N/A'}
     LinkedIn: ${pi.linkedin_url || 'N/A'}
     Website: ${pi.website_url || 'N/A'}

     Summary:
     ${pi.summary || 'N/A'}`);
       }
       
       // Work Experience
       if (cv.work_experience && cv.work_experience.length > 0) {
         const exp = cv.work_experience.map(e => 
           `- ${e.job_title} at ${e.company}
        ${e.location || ''} | ${e.start_date} - ${e.is_current ? 'Present' : e.end_date}
        ${e.description || ''}
        ${e.achievements?.length ? 'Achievements:\n' + e.achievements.map(a => `  • ${a}`).join('\n') : ''}`
         ).join('\n\n');
         sections.push(`WORK EXPERIENCE:\n${exp}`);
       }
       
       // Education
       if (cv.education && cv.education.length > 0) {
         const edu = cv.education.map(e =>
           `- ${e.degree} from ${e.institution}
        ${e.location || ''} | ${e.start_date} - ${e.end_date}${e.gpa ? ` | GPA: ${e.gpa}` : ''}
        ${e.description || ''}`
         ).join('\n\n');
         sections.push(`EDUCATION:\n${edu}`);
       }
       
       // Skills
       if (cv.skills && cv.skills.length > 0) {
         sections.push(`SKILLS:\n${cv.skills.join(', ')}`);
       }
       
       // Certifications
       if (cv.certifications && cv.certifications.length > 0) {
         const certs = cv.certifications.map(c =>
           `- ${c.name} by ${c.issuer} (${c.date_obtained})`
         ).join('\n');
         sections.push(`CERTIFICATIONS:\n${certs}`);
       }
       
       // Languages
       if (cv.languages && cv.languages.length > 0) {
         const langs = cv.languages.map(l =>
           `- ${l.language}: ${l.proficiency}`
         ).join('\n');
         sections.push(`LANGUAGES:\n${langs}`);
       }
       
       // Projects
       if (cv.projects && cv.projects.length > 0) {
         const projs = cv.projects.map(p =>
           `- ${p.name}: ${p.description}${p.url ? ` (${p.url})` : ''}`
         ).join('\n');
         sections.push(`PROJECTS:\n${projs}`);
       }
       
       return sections.join('\n\n---\n\n');
     }
     ```

  5. Create src/lib/applications/index.ts:
     ```typescript
     // ============================================
     // [F128] src/lib/applications/index.ts
     // ============================================
     
     export * from './application-service';
     export * from './application-processor';
     export * from './application-prompts';
     ```

  6. Create API route for applications list and create:
     ```typescript
     // ============================================
     // [F129] src/app/api/applications/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createApplicationService } from '@/lib/applications';
     
     // GET - List user's applications
     export async function GET(request: NextRequest) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const supabase = createServerSupabaseClient();
         const service = createApplicationService(supabase);
         
         const applications = await service.getUserApplications(userId);
         
         return NextResponse.json({ applications });
         
       } catch (error: any) {
         console.error('GET /api/applications error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to fetch applications' },
           { status: 500 }
         );
       }
     }
     
     // POST - Create new application
     export async function POST(request: NextRequest) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const body = await request.json();
         
         const {
           job_description,
           selected_prompt_ids,
           ai_selections,
           output_language,
           tone_setting
         } = body;
         
         // Validation
         if (!job_description || !selected_prompt_ids?.length || !ai_selections?.length) {
           return NextResponse.json(
             { error: 'Missing required fields' },
             { status: 400 }
           );
         }
         
         const supabase = createServerSupabaseClient();
         const service = createApplicationService(supabase);
         
         const application = await service.createApplication(userId, {
           job_description,
           selected_prompt_ids,
           ai_selections,
           output_language: output_language || 'en',
           tone_setting: tone_setting || { mode: 'preset', preset_value: 'professional', custom_text: null }
         });
         
         return NextResponse.json({ application, success: true });
         
       } catch (error: any) {
         console.error('POST /api/applications error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to create application' },
           { status: 500 }
         );
       }
     }
     ```

  7. Create API route for single application:
     ```typescript
     // ============================================
     // [F130] src/app/api/applications/[id]/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createApplicationService } from '@/lib/applications';
     
     interface RouteParams {
       params: { id: string };
     }
     
     // GET - Get single application
     export async function GET(request: NextRequest, { params }: RouteParams) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const supabase = createServerSupabaseClient();
         const service = createApplicationService(supabase);
         
         const application = await service.getApplication(params.id, userId);
         
         if (!application) {
           return NextResponse.json({ error: 'Not found' }, { status: 404 });
         }
         
         return NextResponse.json({ application });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Failed to fetch application' },
           { status: 500 }
         );
       }
     }
     
     // PUT - Update application
     export async function PUT(request: NextRequest, { params }: RouteParams) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const body = await request.json();
         
         const supabase = createServerSupabaseClient();
         const service = createApplicationService(supabase);
         
         const application = await service.updateApplication(params.id, userId, body);
         
         return NextResponse.json({ application, success: true });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Failed to update application' },
           { status: 500 }
         );
       }
     }
     
     // DELETE - Delete application
     export async function DELETE(request: NextRequest, { params }: RouteParams) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const supabase = createServerSupabaseClient();
         const service = createApplicationService(supabase);
         
         await service.deleteApplication(params.id, userId);
         
         return NextResponse.json({ success: true });
         
       } catch (error: any) {
         return NextResponse.json(
           { error: error.message || 'Failed to delete application' },
           { status: 500 }
         );
       }
     }
     ```

  8. Create API route for processing:
     ```typescript
     // ============================================
     // [F131] src/app/api/applications/[id]/process/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createApplicationService, processApplication } from '@/lib/applications';
     import { createPromptService } from '@/lib/prompts';
     import { createCVService } from '@/lib/cv';
     import { decryptApiKey } from '@/lib/encryption';
     
     interface RouteParams {
       params: { id: string };
     }
     
     export async function POST(request: NextRequest, { params }: RouteParams) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const supabase = createServerSupabaseClient();
         const appService = createApplicationService(supabase);
         const promptService = createPromptService(supabase);
         const cvService = createCVService(supabase);
         
         // Get application
         const application = await appService.getApplication(params.id, userId);
         if (!application) {
           return NextResponse.json({ error: 'Application not found' }, { status: 404 });
         }
         
         // Get user's CV
         const cv = await cvService.getCV(userId);
         if (!cv) {
           return NextResponse.json({ 
             error: 'No CV found. Please upload your CV first.' 
           }, { status: 400 });
         }
         
         // Get selected prompts
         const prompts = await promptService.getPromptsByIds(application.selected_prompt_ids);
         if (prompts.length === 0) {
           return NextResponse.json({ 
             error: 'No prompts selected' 
           }, { status: 400 });
         }
         
         // Get API keys
         const { data: keys } = await supabase
           .from('ai_api_keys')
           .select('provider_name, api_key_encrypted')
           .eq('user_id', userId);
         
         const apiKeys: Record<string, string> = {};
         for (const key of keys || []) {
           try {
             apiKeys[key.provider_name] = decryptApiKey(key.api_key_encrypted);
           } catch {}
         }
         
         // Update status to processing
         await appService.updateStatus(params.id, userId, 'processing', 'processing');
         
         // Process with AI
         const result = await processApplication({
           application,
           cv,
           prompts,
           apiKeys
         });
         
         if (!result.success) {
           await appService.setError(params.id, userId, result.error || 'Processing failed');
           return NextResponse.json({ error: result.error }, { status: 500 });
         }
         
         // Handle result
         if (result.needsClarification) {
           // Save AI's question
           await appService.addClarificationMessage(
             params.id, userId, 'assistant', result.content
           );
           
           return NextResponse.json({
             status: 'clarification',
             message: result.content,
             success: true
           });
         } else {
           // Save draft
           await appService.saveDraftContent(params.id, userId, result.content);
           
           return NextResponse.json({
             status: 'draft_ready',
             content: result.content,
             success: true
           });
         }
         
       } catch (error: any) {
         console.error('POST /api/applications/[id]/process error:', error);
         return NextResponse.json(
           { error: error.message || 'Processing failed' },
           { status: 500 }
         );
       }
     }
     ```

  9. Create API route for clarification:
     ```typescript
     // ============================================
     // [F132] src/app/api/applications/[id]/clarify/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createApplicationService, processApplication } from '@/lib/applications';
     import { createPromptService } from '@/lib/prompts';
     import { createCVService } from '@/lib/cv';
     import { decryptApiKey } from '@/lib/encryption';
     
     interface RouteParams {
       params: { id: string };
     }
     
     export async function POST(request: NextRequest, { params }: RouteParams) {
       try {
         const userId = request.headers.get('x-user-id');
         if (!userId) {
           return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
         }
         
         const { response: userResponse } = await request.json();
         if (!userResponse) {
           return NextResponse.json({ error: 'Response is required' }, { status: 400 });
         }
         
         const supabase = createServerSupabaseClient();
         const appService = createApplicationService(supabase);
         const promptService = createPromptService(supabase);
         const cvService = createCVService(supabase);
         
         // Add user's response
         let application = await appService.addClarificationMessage(
           params.id, userId, 'user', userResponse
         );
         
         // Get updated application with all messages
         application = await appService.getApplication(params.id, userId);
         if (!application) {
           return NextResponse.json({ error: 'Application not found' }, { status: 404 });
         }
         
         // Get CV and prompts
         const cv = await cvService.getCV(userId);
         if (!cv) {
           return NextResponse.json({ error: 'CV not found' }, { status: 400 });
         }
         
         const prompts = await promptService.getPromptsByIds(application.selected_prompt_ids);
         
         // Get API keys
         const { data: keys } = await supabase
           .from('ai_api_keys')
           .select('provider_name, api_key_encrypted')
           .eq('user_id', userId);
         
         const apiKeys: Record<string, string> = {};
         for (const key of keys || []) {
           try {
             apiKeys[key.provider_name] = decryptApiKey(key.api_key_encrypted);
           } catch {}
         }
         
         // Continue processing
         const result = await processApplication({
           application,
           cv,
           prompts,
           apiKeys
         });
         
         if (!result.success) {
           await appService.setError(params.id, userId, result.error || 'Processing failed');
           return NextResponse.json({ error: result.error }, { status: 500 });
         }
         
         if (result.needsClarification) {
           await appService.addClarificationMessage(
             params.id, userId, 'assistant', result.content
           );
           
           return NextResponse.json({
             status: 'clarification',
             message: result.content,
             success: true
           });
         } else {
           await appService.saveDraftContent(params.id, userId, result.content);
           
           return NextResponse.json({
             status: 'draft_ready',
             content: result.content,
             success: true
           });
         }
         
       } catch (error: any) {
         console.error('POST /api/applications/[id]/clarify error:', error);
         return NextResponse.json(
           { error: error.message || 'Clarification failed' },
           { status: 500 }
         );
       }
     }
     ```

  10. Create API route for finalization:
      ```typescript
      // ============================================
      // [F133] src/app/api/applications/[id]/finalize/route.ts
      // ============================================
      
      import { NextRequest, NextResponse } from 'next/server';
      import { createServerSupabaseClient } from '@/lib/supabase/server';
      import { createApplicationService, generateFinalDocuments } from '@/lib/applications';
      import { createPromptService } from '@/lib/prompts';
      import { createCVService } from '@/lib/cv';
      import { decryptApiKey } from '@/lib/encryption';
      
      interface RouteParams {
        params: { id: string };
      }
      
      export async function POST(request: NextRequest, { params }: RouteParams) {
        try {
          const userId = request.headers.get('x-user-id');
          if (!userId) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
          }
          
          const { edited_content } = await request.json();
          
          const supabase = createServerSupabaseClient();
          const appService = createApplicationService(supabase);
          const promptService = createPromptService(supabase);
          const cvService = createCVService(supabase);
          
          // Get application
          const application = await appService.getApplication(params.id, userId);
          if (!application) {
            return NextResponse.json({ error: 'Application not found' }, { status: 404 });
          }
          
          if (!application.draft_content) {
            return NextResponse.json({ error: 'No draft content to finalize' }, { status: 400 });
          }
          
          // Update status
          await appService.updateStatus(params.id, userId, 'finalizing');
          
          // Save edited content if provided
          if (edited_content) {
            await appService.saveEditedContent(params.id, userId, edited_content);
          }
          
          // Get CV
          const cv = await cvService.getCV(userId);
          if (!cv) {
            return NextResponse.json({ error: 'CV not found' }, { status: 400 });
          }
          
          // Get prompts
          const prompts = await promptService.getPromptsByIds(application.selected_prompt_ids);
          
          // Get API keys
          const { data: keys } = await supabase
            .from('ai_api_keys')
            .select('provider_name, api_key_encrypted')
            .eq('user_id', userId);
          
          const apiKeys: Record<string, string> = {};
          for (const key of keys || []) {
            try {
              apiKeys[key.provider_name] = decryptApiKey(key.api_key_encrypted);
            } catch {}
          }
          
          // Generate final documents
          const result = await generateFinalDocuments(
            { application, cv, prompts, apiKeys },
            application.draft_content,
            edited_content || application.edited_content
          );
          
          if (!result.success) {
            await appService.setError(params.id, userId, result.error || 'Finalization failed');
            return NextResponse.json({ error: result.error }, { status: 500 });
          }
          
          // Save final documents
          await appService.saveFinalDocuments(params.id, userId, result.documents!);
          
          return NextResponse.json({
            status: 'completed',
            documents: result.documents,
            success: true
          });
          
        } catch (error: any) {
          console.error('POST /api/applications/[id]/finalize error:', error);
          return NextResponse.json(
            { error: error.message || 'Finalization failed' },
            { status: 500 }
          );
        }
      }
      ```

  11. Create useApplication hook:
      ```typescript
      // ============================================
      // [F084] src/hooks/useApplication.ts
      // ============================================
      
      'use client';
      
      import { useState, useCallback } from 'react';
      import { useAuth } from '@/context/AuthContext';
      import {
        JobApplication,
        CreateApplicationInput,
        WizardStep,
        AIModelSelection,
        OutputLanguage,
        ToneSetting
      } from '@/lib/types';
      
      interface UseApplicationReturn {
        application: JobApplication | null;
        loading: boolean;
        processing: boolean;
        error: string | null;
        
        // Wizard state
        currentStep: WizardStep;
        setCurrentStep: (step: WizardStep) => void;
        
        // Form state
        jobDescription: string;
        setJobDescription: (value: string) => void;
        selectedPromptIds: string[];
        setSelectedPromptIds: (ids: string[]) => void;
        aiSelections: AIModelSelection[];
        setAISelections: (selections: AIModelSelection[]) => void;
        outputLanguage: OutputLanguage;
        setOutputLanguage: (lang: OutputLanguage) => void;
        toneSetting: ToneSetting;
        setToneSetting: (tone: ToneSetting) => void;
        
        // Actions
        createApplication: () => Promise<JobApplication>;
        loadApplication: (id: string) => Promise<void>;
        startProcessing: () => Promise<void>;
        sendClarification: (response: string) => Promise<void>;
        updateDraft: (content: string) => void;
        finalize: () => Promise<void>;
        reset: () => void;
        
        // Computed
        canProceedToNext: boolean;
        draftContent: string | null;
        clarificationMessages: Array<{ role: string; content: string }>;
        finalDocuments: {
          tailored_cv: string;
          cover_letter: string;
          application_email: string;
        } | null;
      }
      
      const initialToneSetting: ToneSetting = {
        mode: 'preset',
        preset_value: 'professional',
        custom_text: null
      };
      
      export function useApplication(): UseApplicationReturn {
        const { user } = useAuth();
        
        // Application state
        const [application, setApplication] = useState<JobApplication | null>(null);
        const [loading, setLoading] = useState(false);
        const [processing, setProcessing] = useState(false);
        const [error, setError] = useState<string | null>(null);
        
        // Wizard state
        const [currentStep, setCurrentStep] = useState<WizardStep>('job_description');
        
        // Form state
        const [jobDescription, setJobDescription] = useState('');
        const [selectedPromptIds, setSelectedPromptIds] = useState<string[]>([]);
        const [aiSelections, setAISelections] = useState<AIModelSelection[]>([]);
        const [outputLanguage, setOutputLanguage] = useState<OutputLanguage>('en');
        const [toneSetting, setToneSetting] = useState<ToneSetting>(initialToneSetting);
        
        // Draft state (local)
        const [localDraftContent, setLocalDraftContent] = useState<string | null>(null);
        
        const createApplication = useCallback(async (): Promise<JobApplication> => {
          if (!user) throw new Error('Not authenticated');
          
          setLoading(true);
          setError(null);
          
          try {
            const res = await fetch('/api/applications', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'x-user-id': user.id
              },
              body: JSON.stringify({
                job_description: jobDescription,
                selected_prompt_ids: selectedPromptIds,
                ai_selections: aiSelections,
                output_language: outputLanguage,
                tone_setting: toneSetting
              })
            });
            
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            
            setApplication(data.application);
            return data.application;
            
          } catch (err: any) {
            setError(err.message);
            throw err;
          } finally {
            setLoading(false);
          }
        }, [user, jobDescription, selectedPromptIds, aiSelections, outputLanguage, toneSetting]);
        
        const loadApplication = useCallback(async (id: string) => {
          if (!user) return;
          
          setLoading(true);
          setError(null);
          
          try {
            const res = await fetch(`/api/applications/${id}`, {
              headers: { 'x-user-id': user.id }
            });
            
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            
            const app = data.application;
            setApplication(app);
            
            // Restore form state from application
            setJobDescription(app.job_description);
            setSelectedPromptIds(app.selected_prompt_ids);
            setAISelections(app.ai_selections);
            setOutputLanguage(app.output_language);
            setToneSetting(app.tone_setting);
            setCurrentStep(app.current_step);
            setLocalDraftContent(app.draft_content);
            
          } catch (err: any) {
            setError(err.message);
          } finally {
            setLoading(false);
          }
        }, [user]);
        
        const startProcessing = useCallback(async () => {
          if (!user || !application) return;
          
          setProcessing(true);
          setError(null);
          setCurrentStep('processing');
          
          try {
            const res = await fetch(`/api/applications/${application.id}/process`, {
              method: 'POST',
              headers: { 'x-user-id': user.id }
            });
            
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            
            if (data.status === 'clarification') {
              setApplication(prev => prev ? {
                ...prev,
                status: 'clarification',
                clarification_messages: [
                  ...(prev.clarification_messages || []),
                  { id: Date.now().toString(), role: 'assistant', content: data.message, timestamp: new Date().toISOString() }
                ]
              } : null);
            } else if (data.status === 'draft_ready') {
              setLocalDraftContent(data.content);
              setApplication(prev => prev ? {
                ...prev,
                status: 'draft_ready',
                draft_content: data.content,
                current_step: 'editing'
              } : null);
              setCurrentStep('editing');
            }
            
          } catch (err: any) {
            setError(err.message);
          } finally {
            setProcessing(false);
          }
        }, [user, application]);
        
        const sendClarification = useCallback(async (response: string) => {
          if (!user || !application) return;
          
          setProcessing(true);
          setError(null);
          
          // Optimistically add user message
          setApplication(prev => prev ? {
            ...prev,
            clarification_messages: [
              ...(prev.clarification_messages || []),
              { id: Date.now().toString(), role: 'user', content: response, timestamp: new Date().toISOString() }
            ]
          } : null);
          
          try {
            const res = await fetch(`/api/applications/${application.id}/clarify`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'x-user-id': user.id
              },
              body: JSON.stringify({ response })
            });
            
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            
            if (data.status === 'clarification') {
              setApplication(prev => prev ? {
                ...prev,
                clarification_messages: [
                  ...(prev.clarification_messages || []),
                  { id: Date.now().toString(), role: 'assistant', content: data.message, timestamp: new Date().toISOString() }
                ]
              } : null);
            } else if (data.status === 'draft_ready') {
              setLocalDraftContent(data.content);
              setApplication(prev => prev ? {
                ...prev,
                status: 'draft_ready',
                draft_content: data.content,
                current_step: 'editing'
              } : null);
              setCurrentStep('editing');
            }
            
          } catch (err: any) {
            setError(err.message);
          } finally {
            setProcessing(false);
          }
        }, [user, application]);
        
        const updateDraft = useCallback((content: string) => {
          setLocalDraftContent(content);
        }, []);
        
        const finalize = useCallback(async () => {
          if (!user || !application) return;
          
          setProcessing(true);
          setError(null);
          
          try {
            const res = await fetch(`/api/applications/${application.id}/finalize`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'x-user-id': user.id
              },
              body: JSON.stringify({
                edited_content: localDraftContent
              })
            });
            
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            
            setApplication(prev => prev ? {
              ...prev,
              status: 'completed',
              current_step: 'final',
              final_documents: {
                ...data.documents,
                generatedAt: new Date().toISOString()
              }
            } : null);
            setCurrentStep('final');
            
          } catch (err: any) {
            setError(err.message);
          } finally {
            setProcessing(false);
          }
        }, [user, application, localDraftContent]);
        
        const reset = useCallback(() => {
          setApplication(null);
          setCurrentStep('job_description');
          setJobDescription('');
          setSelectedPromptIds([]);
          setAISelections([]);
          setOutputLanguage('en');
          setToneSetting(initialToneSetting);
          setLocalDraftContent(null);
          setError(null);
        }, []);
        
        // Computed
        const canProceedToNext = (() => {
          switch (currentStep) {
            case 'job_description':
              return jobDescription.trim().length > 50;
            case 'prompts':
              return selectedPromptIds.length > 0;
            case 'ai_config':
              return aiSelections.length > 0;
            case 'settings':
              return true;
            default:
              return false;
          }
        })();
        
        return {
          application,
          loading,
          processing,
          error,
          currentStep,
          setCurrentStep,
          jobDescription,
          setJobDescription,
          selectedPromptIds,
          setSelectedPromptIds,
          aiSelections,
          setAISelections,
          outputLanguage,
          setOutputLanguage,
          toneSetting,
          setToneSetting,
          createApplication,
          loadApplication,
          startProcessing,
          sendClarification,
          updateDraft,
          finalize,
          reset,
          canProceedToNext,
          draftContent: localDraftContent,
          clarificationMessages: application?.clarification_messages || [],
          finalDocuments: application?.final_documents || null
        };
      }
      ```

  12. Create WizardProgress.tsx:
      ```typescript
      // ============================================
      // [F135] src/components/application/WizardProgress.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { WizardStep } from '@/lib/types';
      import { cn } from '@/lib/utils';
      import { Check, FileText, Sparkles, Settings, Loader2, Edit, Download } from 'lucide-react';
      
      interface WizardProgressProps {
        currentStep: WizardStep;
        completedSteps: WizardStep[];
        onStepClick?: (step: WizardStep) => void;
        className?: string;
      }
      
      const STEPS: { key: WizardStep; icon: React.ElementType }[] = [
        { key: 'job_description', icon: FileText },
        { key: 'prompts', icon: Sparkles },
        { key: 'ai_config', icon: Settings },
        { key: 'settings', icon: Settings },
        { key: 'processing', icon: Loader2 },
        { key: 'editing', icon: Edit },
        { key: 'final', icon: Download }
      ];
      
      export function WizardProgress({
        currentStep,
        completedSteps,
        onStepClick,
        className
      }: WizardProgressProps) {
        const t = useTranslations('application');
        
        const currentIndex = STEPS.findIndex(s => s.key === currentStep);
        
        return (
          <div className={cn('flex items-center justify-between', className)}>
            {STEPS.map((step, index) => {
              const Icon = step.icon;
              const isCompleted = completedSteps.includes(step.key);
              const isCurrent = step.key === currentStep;
              const isClickable = isCompleted && onStepClick;
              
              return (
                <div key={step.key} className="flex items-center">
                  {/* Step circle */}
                  <button
                    onClick={() => isClickable && onStepClick(step.key)}
                    disabled={!isClickable}
                    className={cn(
                      'flex items-center justify-center w-10 h-10 rounded-full border-2 transition-all',
                      isCompleted && 'bg-primary border-primary text-primary-foreground',
                      isCurrent && !isCompleted && 'border-primary text-primary',
                      !isCompleted && !isCurrent && 'border-muted-foreground/30 text-muted-foreground',
                      isClickable && 'cursor-pointer hover:scale-105'
                    )}
                  >
                    {isCompleted ? (
                      <Check className="h-5 w-5" />
                    ) : (
                      <Icon className={cn('h-5 w-5', isCurrent && step.key === 'processing' && 'animate-spin')} />
                    )}
                  </button>
                  
                  {/* Connector line */}
                  {index < STEPS.length - 1 && (
                    <div className={cn(
                      'w-full h-0.5 mx-2 min-w-[20px] max-w-[60px]',
                      index < currentIndex ? 'bg-primary' : 'bg-muted-foreground/30'
                    )} />
                  )}
                </div>
              );
            })}
          </div>
        );
      }
      ```

  13. Create JobDescriptionInput.tsx:
      ```typescript
      // ============================================
      // [F054] src/components/application/JobDescriptionInput.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Textarea } from '@/components/ui/textarea';
      import { Badge } from '@/components/ui/badge';
      import { FileText, AlertCircle } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      interface JobDescriptionInputProps {
        value: string;
        onChange: (value: string) => void;
        minLength?: number;
        disabled?: boolean;
        className?: string;
      }
      
      export function JobDescriptionInput({
        value,
        onChange,
        minLength = 50,
        disabled = false,
        className
      }: JobDescriptionInputProps) {
        const t = useTranslations('application');
        
        const charCount = value.length;
        const wordCount = value.trim().split(/\s+/).filter(Boolean).length;
        const isValid = charCount >= minLength;
        
        return (
          <Card className={className}>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <FileText className="h-5 w-5" />
                {t('job_description_title')}
              </CardTitle>
              <CardDescription>
                {t('job_description_hint')}
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <Textarea
                value={value}
                onChange={(e) => onChange(e.target.value)}
                placeholder={t('job_description_placeholder')}
                rows={12}
                disabled={disabled}
                className="resize-none font-mono text-sm"
                dir="auto"
              />
              
              <div className="flex items-center justify-between text-sm">
                <div className="flex items-center gap-4 text-muted-foreground">
                  <span>{t('characters')}: {charCount}</span>
                  <span>{t('words')}: {wordCount}</span>
                </div>
                
                {!isValid && charCount > 0 && (
                  <Badge variant="outline" className="text-yellow-600 border-yellow-300">
                    <AlertCircle className="h-3 w-3 mr-1" />
                    {t('min_chars_required', { count: minLength })}
                  </Badge>
                )}
                
                {isValid && (
                  <Badge variant="outline" className="text-green-600 border-green-300">
                    {t('ready')}
                  </Badge>
                )}
              </div>
            </CardContent>
          </Card>
        );
      }
      ```

  14. Create LanguageSelector.tsx:
      ```typescript
      // ============================================
      // [F056] src/components/application/LanguageSelector.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { useParams } from 'next/navigation';
      import { OutputLanguage } from '@/lib/types';
      import { SUPPORTED_OUTPUT_LANGUAGES } from '@/lib/constants';
      import { Label } from '@/components/ui/label';
      import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
      import { cn } from '@/lib/utils';
      
      interface LanguageSelectorProps {
        value: OutputLanguage;
        onChange: (value: OutputLanguage) => void;
        disabled?: boolean;
        className?: string;
      }
      
      export function LanguageSelector({
        value,
        onChange,
        disabled = false,
        className
      }: LanguageSelectorProps) {
        const t = useTranslations('application');
        const params = useParams();
        const locale = params.locale as 'en' | 'fa';
        
        return (
          <div className={cn('space-y-3', className)}>
            <Label>{t('output_language')}</Label>
            <RadioGroup
              value={value}
              onValueChange={(v) => onChange(v as OutputLanguage)}
              disabled={disabled}
              className="grid grid-cols-2 md:grid-cols-4 gap-3"
            >
              {SUPPORTED_OUTPUT_LANGUAGES.map((lang) => (
                <div key={lang.code}>
                  <RadioGroupItem
                    value={lang.code}
                    id={`lang-${lang.code}`}
                    className="peer sr-only"
                  />
                  <Label
                    htmlFor={`lang-${lang.code}`}
                    className={cn(
                      'flex items-center justify-center px-3 py-2 border rounded-lg cursor-pointer',
                      'peer-data-[state=checked]:border-primary peer-data-[state=checked]:bg-primary/5',
                      'hover:bg-muted transition-colors',
                      disabled && 'opacity-50 cursor-not-allowed'
                    )}
                  >
                    {locale === 'fa' ? lang.label_fa : lang.label_en}
                  </Label>
                </div>
              ))}
            </RadioGroup>
          </div>
        );
      }
      ```

  15. Create ToneSelector.tsx:
      ```typescript
      // ============================================
      // [F055] src/components/application/ToneSelector.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { useParams } from 'next/navigation';
      import { ToneSetting } from '@/lib/types';
      import { TONE_PRESETS } from '@/lib/constants';
      import { Label } from '@/components/ui/label';
      import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
      import { Textarea } from '@/components/ui/textarea';
      import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
      import { cn } from '@/lib/utils';
      
      interface ToneSelectorProps {
        value: ToneSetting;
        onChange: (value: ToneSetting) => void;
        disabled?: boolean;
        className?: string;
      }
      
      export function ToneSelector({
        value,
        onChange,
        disabled = false,
        className
      }: ToneSelectorProps) {
        const t = useTranslations('application');
        const params = useParams();
        const locale = params.locale as 'en' | 'fa';
        
        const handleModeChange = (mode: 'preset' | 'custom') => {
          onChange({
            mode,
            preset_value: mode === 'preset' ? (value.preset_value || 'professional') : null,
            custom_text: mode === 'custom' ? (value.custom_text || '') : null
          });
        };
        
        const handlePresetChange = (preset: string) => {
          onChange({
            ...value,
            mode: 'preset',
            preset_value: preset
          });
        };
        
        const handleCustomChange = (text: string) => {
          onChange({
            ...value,
            mode: 'custom',
            custom_text: text
          });
        };
        
        return (
          <div className={cn('space-y-3', className)}>
            <Label>{t('response_tone')}</Label>
            
            <Tabs 
              value={value.mode} 
              onValueChange={(v) => handleModeChange(v as 'preset' | 'custom')}
            >
              <TabsList className="grid w-full grid-cols-2">
                <TabsTrigger value="preset" disabled={disabled}>
                  {t('tone_preset')}
                </TabsTrigger>
                <TabsTrigger value="custom" disabled={disabled}>
                  {t('tone_custom')}
                </TabsTrigger>
              </TabsList>
              
              <TabsContent value="preset" className="mt-4">
                <RadioGroup
                  value={value.preset_value || 'professional'}
                  onValueChange={handlePresetChange}
                  disabled={disabled}
                  className="grid grid-cols-2 md:grid-cols-3 gap-3"
                >
                  {TONE_PRESETS.map((tone) => (
                    <div key={tone.value}>
                      <RadioGroupItem
                        value={tone.value}
                        id={`tone-${tone.value}`}
                        className="peer sr-only"
                      />
                      <Label
                        htmlFor={`tone-${tone.value}`}
                        className={cn(
                          'flex items-center justify-center px-3 py-2 border rounded-lg cursor-pointer',
                          'peer-data-[state=checked]:border-primary peer-data-[state=checked]:bg-primary/5',
                          'hover:bg-muted transition-colors',
                          disabled && 'opacity-50 cursor-not-allowed'
                        )}
                      >
                        {locale === 'fa' ? tone.label_fa : tone.label_en}
                      </Label>
                    </div>
                  ))}
                </RadioGroup>
              </TabsContent>
              
              <TabsContent value="custom" className="mt-4">
                <Textarea
                  value={value.custom_text || ''}
                  onChange={(e) => handleCustomChange(e.target.value)}
                  placeholder={t('tone_custom_placeholder')}
                  rows={3}
                  disabled={disabled}
                  dir="auto"
                />
                <p className="text-xs text-muted-foreground mt-2">
                  {t('tone_custom_hint')}
                </p>
              </TabsContent>
            </Tabs>
          </div>
        );
      }
      ```

  (ادامه در پیام بعدی به دلیل محدودیت طول...)
به دلیل طولانی بودن این بلوک، ادامه فایل‌ها را در پیام بعدی می‌نویسم. آیا ادامه دهم؟

فایل‌های باقیمانده:

AIConfigurationStep.tsx
OutputSettingsStep.tsx
ProcessingStep.tsx
AIChatInterface.tsx
OutputEditor.tsx
FinalDocumentsStep.tsx
DocumentPreview.tsx
DownloadPanel.tsx
ApplicationWizard.tsx
new-application/page.tsx
Translations




بلاک ۱۸ را بساز

claude-opus-4-5-20251101-thinking-32k

Thought for 2 seconds

بلوک B17 — مدیریت پرامپت‌ها (CRUD Backend + Frontend)
B17.yaml — سیستم کامل مدیریت پرامپت‌ها
YAML

# blocks/B17.yaml

id: B17
name: "Prompt Management System"
phase: 2
phase_name: "Prompt Management"

goal: |
  Create the complete prompt management system - the heart of the application.
  This includes:
  - API routes for CRUD operations on prompts
  - React hook for prompt state management
  - UI components for listing, creating, editing, and selecting prompts
  - Admin page for managing prompts (no-code management)
  
  Prompts are pre-built templates that define how AI should process CVs and job descriptions.
  Each prompt has titles/descriptions in both English and Farsi.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08]

files_to_create:
  # API Routes
  - id: F024
    path: "src/app/api/prompts/route.ts"
    description: "API route for prompts CRUD (GET all, POST new)"

  - id: F118
    path: "src/app/api/prompts/[id]/route.ts"
    description: "API route for single prompt (GET, PUT, DELETE)"

  # Service Layer
  - id: F119
    path: "src/lib/prompts/prompt-service.ts"
    description: "Prompt service layer for database operations"

  - id: F120
    path: "src/lib/prompts/index.ts"
    description: "Export all prompt modules"

  - id: F121
    path: "src/lib/prompts/default-prompts.ts"
    description: "Default/seed prompts for initial setup"

  # React Hook
  - id: F083
    path: "src/hooks/usePrompts.ts"
    description: "React hook for prompt operations"

  # UI Components
  - id: F045
    path: "src/components/prompts/PromptList.tsx"
    description: "Display list of prompts with filters"

  - id: F046
    path: "src/components/prompts/PromptEditor.tsx"
    description: "Form for creating/editing prompts"

  - id: F047
    path: "src/components/prompts/PromptSelector.tsx"
    description: "Component for selecting prompts in application flow"

  - id: F048
    path: "src/components/prompts/PromptCategoryFilter.tsx"
    description: "Filter prompts by category"

  - id: F122
    path: "src/components/prompts/PromptCard.tsx"
    description: "Card display for a single prompt"

  - id: F123
    path: "src/components/prompts/PromptPreview.tsx"
    description: "Preview full prompt text"

  # Page
  - id: F015
    path: "src/app/[locale]/prompts/page.tsx"
    description: "Prompt management page"

  - id: F124
    path: "src/app/[locale]/prompts/loading.tsx"
    description: "Loading state for prompts page"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add prompt management translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add prompt management translations"

files_available:
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F028
    path: "src/components/ui/input.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F030
    path: "src/components/ui/dialog.tsx"
    from_block: B02
  - id: F031
    path: "src/components/ui/select.tsx"
    from_block: B02
  - id: F032
    path: "src/components/ui/textarea.tsx"
    from_block: B02
  - id: F033
    path: "src/components/ui/tabs.tsx"
    from_block: B02
  - id: F034
    path: "src/components/ui/badge.tsx"
    from_block: B02
  - id: F063
    path: "src/lib/supabase/client.ts"
    from_block: B06
  - id: F064
    path: "src/lib/supabase/server.ts"
    from_block: B06
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F080
    path: "src/lib/utils.ts"
    from_block: B04
  - id: F090
    path: "src/context/AuthContext.tsx"
    from_block: B07
  - id: F092
    path: "src/components/auth/AuthGuard.tsx"
    from_block: B07

commands: []

instructions: |
  1. Create default-prompts.ts (seed data):
     ```typescript
     // ============================================
     // [F121] src/lib/prompts/default-prompts.ts
     // ============================================
     
     import { Prompt } from '@/lib/types';
     
     export const DEFAULT_PROMPTS: Omit<Prompt, 'id' | 'created_at' | 'updated_at'>[] = [
       {
         title_en: "Professional CV Tailoring",
         title_fa: "تنظیم حرفه‌ای سی‌وی",
         description_en: "Tailors your CV to match the job description with professional language and formatting.",
         description_fa: "سی‌وی شما را با زبان و قالب‌بندی حرفه‌ای مطابق شرح شغل تنظیم می‌کند.",
         prompt_text: `You are an expert CV writer and career consultant. Your task is to tailor the candidate's CV to match the job description.

     INPUTS:
     - Candidate's comprehensive CV
     - Target job description
     - Desired output language
     - Tone preference

     INSTRUCTIONS:
     1. Analyze the job description to identify:
        - Required skills and qualifications
        - Key responsibilities
        - Company culture indicators
        - Industry-specific terminology

     2. Review the candidate's CV and identify:
        - Relevant experience that matches the job
        - Transferable skills
        - Achievements that demonstrate required competencies
        - Gaps that need to be addressed

     3. Create a tailored CV that:
        - Highlights the most relevant experience first
        - Uses keywords from the job description
        - Quantifies achievements where possible
        - Matches the tone and style appropriate for the industry
        - Is concise yet comprehensive (ideally 1-2 pages)

     4. If you need clarification on any aspect, ask specific questions.

     5. Output the tailored CV in a clean, professional format.

     Remember: The goal is to present the candidate as the ideal fit for this specific role while remaining truthful about their experience.`,
         category: "cv_tailoring",
         is_active: true,
         sort_order: 1
       },
       {
         title_en: "Technical Role Focus",
         title_fa: "تمرکز بر نقش فنی",
         description_en: "Emphasizes technical skills, projects, and achievements for engineering/IT roles.",
         description_fa: "مهارت‌های فنی، پروژه‌ها و دستاوردها را برای نقش‌های مهندسی/فناوری اطلاعات برجسته می‌کند.",
         prompt_text: `You are a technical recruiter and CV specialist for engineering and IT roles.

     FOCUS AREAS:
     - Technical skills and proficiencies (languages, frameworks, tools)
     - Project experience with technical details
     - Problem-solving achievements with measurable outcomes
     - Certifications and technical education
     - Open source contributions or technical publications

     INSTRUCTIONS:
     1. Parse the job description for:
        - Required tech stack
        - Experience level needed
        - Specific technical challenges mentioned
        - Team structure and methodology (Agile, etc.)

     2. From the CV, extract and prioritize:
        - Matching technical skills (order by relevance)
        - Projects using similar technologies
        - Scale of systems worked on
        - Technical leadership experience

     3. Format the output with:
        - Skills section prominently placed
        - Project descriptions with tech stack tags
        - Metrics (users served, performance improvements, etc.)
        - Clean, ATS-friendly formatting

     Ask clarifying questions if the technical requirements are unclear or if you need more details about specific projects.`,
         category: "cv_tailoring",
         is_active: true,
         sort_order: 2
       },
       {
         title_en: "Executive/Leadership Focus",
         title_fa: "تمرکز بر مدیریت اجرایی",
         description_en: "Crafts CVs for senior leadership positions, emphasizing strategic impact and team leadership.",
         description_fa: "سی‌وی را برای موقعیت‌های مدیریت ارشد با تأکید بر تأثیر استراتژیک و رهبری تیم تنظیم می‌کند.",
         prompt_text: `You are an executive career consultant specializing in C-suite and senior leadership positions.

     FOCUS AREAS:
     - Strategic vision and business impact
     - P&L responsibility and budget management
     - Team building and organizational development
     - Board presentations and stakeholder management
     - Industry thought leadership

     INSTRUCTIONS:
     1. Analyze the role for:
        - Scope of responsibility
        - Reporting structure
        - Strategic priorities
        - Cultural fit indicators

     2. Highlight from the CV:
        - Revenue/growth achievements with numbers
        - Transformation initiatives led
        - Team sizes managed
        - Board-level experience
        - Industry recognition

     3. Craft an executive summary that:
        - Leads with the most impressive achievement
        - Positions the candidate as a strategic leader
        - Uses powerful, confident language
        - Demonstrates industry expertise

     The output should be polished, concise, and appropriate for executive-level review.`,
         category: "cv_tailoring",
         is_active: true,
         sort_order: 3
       },
       {
         title_en: "Cover Letter Generator",
         title_fa: "تولیدکننده کاورلتر",
         description_en: "Creates compelling cover letters that complement the tailored CV.",
         description_fa: "کاورلترهای جذابی ایجاد می‌کند که مکمل سی‌وی تنظیم‌شده هستند.",
         prompt_text: `You are an expert cover letter writer. Create a compelling cover letter based on the candidate's CV and target job.

     STRUCTURE:
     1. Opening paragraph:
        - Hook that captures attention
        - Clear statement of the position applied for
        - Brief indication of why you're a great fit

     2. Body paragraphs (2-3):
        - Match your top qualifications to job requirements
        - Provide specific examples with results
        - Show knowledge of the company
        - Demonstrate cultural fit

     3. Closing paragraph:
        - Reiterate enthusiasm
        - Clear call to action
        - Professional sign-off

     GUIDELINES:
     - Keep it to one page (300-400 words)
     - Use the same tone as the job posting
     - Avoid repeating the CV verbatim
     - Show personality while remaining professional
     - Address it properly (research the hiring manager if possible)

     If the job posting mentions specific values or initiatives, incorporate them naturally.`,
         category: "cover_letter",
         is_active: true,
         sort_order: 10
       },
       {
         title_en: "Application Email",
         title_fa: "ایمیل درخواست",
         description_en: "Writes professional application emails for job submissions.",
         description_fa: "ایمیل‌های درخواست حرفه‌ای برای ارسال درخواست شغلی می‌نویسد.",
         prompt_text: `You are writing a professional job application email. This email will accompany the CV and cover letter.

     EMAIL STRUCTURE:
     1. Subject line: Clear and professional
        Example: "Application for [Position] - [Your Name]"

     2. Greeting: Formal, addressed properly

     3. Body (brief, 3-4 sentences):
        - State the position you're applying for
        - One compelling reason you're a fit
        - Mention attached documents
        - Express enthusiasm

     4. Closing:
        - Thank them for their time
        - Professional signature with contact info

     GUIDELINES:
     - Keep it SHORT - this is not the cover letter
     - Professional but warm tone
     - Easy to read on mobile
     - Include all contact information
     - Mention if referred by someone

     The email should make them want to open the attachments.`,
         category: "email",
         is_active: true,
         sort_order: 20
       },
       {
         title_en: "Career Changer",
         title_fa: "تغییر مسیر شغلی",
         description_en: "Helps candidates transitioning to a new industry or role highlight transferable skills.",
         description_fa: "به متقاضیانی که به صنعت یا نقش جدیدی منتقل می‌شوند کمک می‌کند مهارت‌های قابل انتقال را برجسته کنند.",
         prompt_text: `You are a career transition specialist. Help the candidate present their experience for a new industry/role.

     APPROACH:
     1. Identify transferable skills:
        - Leadership and management
        - Communication and presentation
        - Problem-solving and analytical thinking
        - Project management
        - Technical skills that cross industries

     2. Reframe experience:
        - Use industry-neutral language
        - Focus on outcomes, not industry-specific processes
        - Highlight adaptability and learning agility
        - Emphasize relevant training or education

     3. Address the elephant in the room:
        - Acknowledge the transition positively
        - Show genuine interest in the new field
        - Demonstrate research into the industry
        - Highlight any bridge experiences

     4. Structure the CV to:
        - Lead with a strong summary explaining the transition
        - Group skills by relevance to new role
        - Include any relevant projects, courses, or certifications
        - De-emphasize irrelevant experience without hiding it

     Ask about their motivation for the change and any steps they've taken toward the new field.`,
         category: "cv_tailoring",
         is_active: true,
         sort_order: 4
       },
       {
         title_en: "ATS Optimization",
         title_fa: "بهینه‌سازی ATS",
         description_en: "Optimizes CV format and keywords for Applicant Tracking Systems.",
         description_fa: "فرمت و کلمات کلیدی سی‌وی را برای سیستم‌های ردیابی متقاضیان بهینه می‌کند.",
         prompt_text: `You are an ATS (Applicant Tracking System) optimization expert.

     OBJECTIVE:
     Ensure the CV passes through ATS filters while remaining readable for humans.

     KEY OPTIMIZATIONS:
     1. Keywords:
        - Extract exact keywords from job description
        - Include variations (e.g., "Project Management" and "PM")
        - Place keywords in context, not just listed
        - Include both spelled-out and acronym versions

     2. Formatting:
        - Use standard section headings (Experience, Education, Skills)
        - Avoid tables, columns, headers/footers
        - Use standard fonts
        - No images or graphics
        - Simple bullet points

     3. Structure:
        - Contact info at the top
        - Clear date formats (MM/YYYY)
        - Company name, title, dates in consistent order
        - Avoid creative layouts

     4. Content:
        - Match job title variations
        - Include required qualifications verbatim
        - Quantify achievements with numbers
        - Use industry-standard terminology

     Output the CV in a clean, ATS-friendly format while ensuring it's still engaging for human readers.`,
         category: "cv_tailoring",
         is_active: true,
         sort_order: 5
       }
     ];
     
     export const PROMPT_CATEGORIES = [
       { value: 'cv_tailoring', label_en: 'CV Tailoring', label_fa: 'تنظیم سی‌وی' },
       { value: 'cover_letter', label_en: 'Cover Letter', label_fa: 'کاورلتر' },
       { value: 'email', label_en: 'Application Email', label_fa: 'ایمیل درخواست' },
       { value: 'interview', label_en: 'Interview Prep', label_fa: 'آماده‌سازی مصاحبه' },
       { value: 'general', label_en: 'General', label_fa: 'عمومی' },
     ];
     ```
  
  2. Create prompt-service.ts:
     ```typescript
     // ============================================
     // [F119] src/lib/prompts/prompt-service.ts
     // ============================================
     
     import { SupabaseClient } from '@supabase/supabase-js';
     import { Prompt } from '@/lib/types';
     import { DEFAULT_PROMPTS } from './default-prompts';
     
     export class PromptService {
       constructor(private supabase: SupabaseClient) {}
       
       async getAllPrompts(activeOnly: boolean = false): Promise<Prompt[]> {
         let query = this.supabase
           .from('prompts')
           .select('*')
           .order('sort_order', { ascending: true });
         
         if (activeOnly) {
           query = query.eq('is_active', true);
         }
         
         const { data, error } = await query;
         
         if (error) throw error;
         return data || [];
       }
       
       async getPromptById(id: string): Promise<Prompt | null> {
         const { data, error } = await this.supabase
           .from('prompts')
           .select('*')
           .eq('id', id)
           .single();
         
         if (error) {
           if (error.code === 'PGRST116') return null;
           throw error;
         }
         
         return data;
       }
       
       async getPromptsByCategory(category: string): Promise<Prompt[]> {
         const { data, error } = await this.supabase
           .from('prompts')
           .select('*')
           .eq('category', category)
           .eq('is_active', true)
           .order('sort_order', { ascending: true });
         
         if (error) throw error;
         return data || [];
       }
       
       async getPromptsByIds(ids: string[]): Promise<Prompt[]> {
         if (ids.length === 0) return [];
         
         const { data, error } = await this.supabase
           .from('prompts')
           .select('*')
           .in('id', ids);
         
         if (error) throw error;
         return data || [];
       }
       
       async createPrompt(prompt: Omit<Prompt, 'id' | 'created_at' | 'updated_at'>): Promise<Prompt> {
         const { data, error } = await this.supabase
           .from('prompts')
           .insert(prompt)
           .select()
           .single();
         
         if (error) throw error;
         return data;
       }
       
       async updatePrompt(id: string, updates: Partial<Prompt>): Promise<Prompt> {
         // Remove fields that shouldn't be updated
         const { id: _, created_at, updated_at, ...validUpdates } = updates as any;
         
         const { data, error } = await this.supabase
           .from('prompts')
           .update(validUpdates)
           .eq('id', id)
           .select()
           .single();
         
         if (error) throw error;
         return data;
       }
       
       async deletePrompt(id: string): Promise<void> {
         const { error } = await this.supabase
           .from('prompts')
           .delete()
           .eq('id', id);
         
         if (error) throw error;
       }
       
       async togglePromptActive(id: string): Promise<Prompt> {
         // Get current state
         const prompt = await this.getPromptById(id);
         if (!prompt) throw new Error('Prompt not found');
         
         // Toggle
         return this.updatePrompt(id, { is_active: !prompt.is_active });
       }
       
       async reorderPrompts(orderedIds: string[]): Promise<void> {
         // Update sort_order for each prompt
         const updates = orderedIds.map((id, index) => 
           this.supabase
             .from('prompts')
             .update({ sort_order: index })
             .eq('id', id)
         );
         
         await Promise.all(updates);
       }
       
       async seedDefaultPrompts(): Promise<void> {
         // Check if prompts already exist
         const existing = await this.getAllPrompts();
         if (existing.length > 0) {
           console.log('Prompts already exist, skipping seed');
           return;
         }
         
         // Insert default prompts
         const { error } = await this.supabase
           .from('prompts')
           .insert(DEFAULT_PROMPTS);
         
         if (error) throw error;
         console.log('Default prompts seeded successfully');
       }
       
       async searchPrompts(query: string, locale: 'en' | 'fa' = 'en'): Promise<Prompt[]> {
         const searchField = locale === 'fa' ? 'title_fa' : 'title_en';
         const descField = locale === 'fa' ? 'description_fa' : 'description_en';
         
         const { data, error } = await this.supabase
           .from('prompts')
           .select('*')
           .or(`${searchField}.ilike.%${query}%,${descField}.ilike.%${query}%`)
           .eq('is_active', true)
           .order('sort_order', { ascending: true });
         
         if (error) throw error;
         return data || [];
       }
     }
     
     export function createPromptService(supabase: SupabaseClient): PromptService {
       return new PromptService(supabase);
     }
     ```
  
  3. Create src/lib/prompts/index.ts:
     ```typescript
     // ============================================
     // [F120] src/lib/prompts/index.ts
     // ============================================
     
     export * from './prompt-service';
     export * from './default-prompts';
     ```
  
  4. Create API route for prompts (GET all, POST new):
     ```typescript
     // ============================================
     // [F024] src/app/api/prompts/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createPromptService } from '@/lib/prompts';
     
     // GET - List all prompts
     export async function GET(request: NextRequest) {
       try {
         const { searchParams } = new URL(request.url);
         const activeOnly = searchParams.get('active') === 'true';
         const category = searchParams.get('category');
         const search = searchParams.get('search');
         const locale = (searchParams.get('locale') || 'en') as 'en' | 'fa';
         
         const supabase = createServerSupabaseClient();
         const promptService = createPromptService(supabase);
         
         let prompts;
         
         if (search) {
           prompts = await promptService.searchPrompts(search, locale);
         } else if (category) {
           prompts = await promptService.getPromptsByCategory(category);
         } else {
           prompts = await promptService.getAllPrompts(activeOnly);
         }
         
         return NextResponse.json({ prompts });
         
       } catch (error: any) {
         console.error('GET /api/prompts error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to fetch prompts' },
           { status: 500 }
         );
       }
     }
     
     // POST - Create new prompt
     export async function POST(request: NextRequest) {
       try {
         const body = await request.json();
         
         const {
           title_en,
           title_fa,
           description_en,
           description_fa,
           prompt_text,
           category,
           is_active = true,
           sort_order = 0
         } = body;
         
         // Validation
         if (!title_en || !title_fa || !prompt_text) {
           return NextResponse.json(
             { error: 'title_en, title_fa, and prompt_text are required' },
             { status: 400 }
           );
         }
         
         const supabase = createServerSupabaseClient();
         const promptService = createPromptService(supabase);
         
         const prompt = await promptService.createPrompt({
           title_en,
           title_fa,
           description_en: description_en || '',
           description_fa: description_fa || '',
           prompt_text,
           category: category || 'general',
           is_active,
           sort_order
         });
         
         return NextResponse.json({ prompt, success: true });
         
       } catch (error: any) {
         console.error('POST /api/prompts error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to create prompt' },
           { status: 500 }
         );
       }
     }
     ```
  
  5. Create API route for single prompt:
     ```typescript
     // ============================================
     // [F118] src/app/api/prompts/[id]/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createPromptService } from '@/lib/prompts';
     
     interface RouteParams {
       params: { id: string };
     }
     
     // GET - Get single prompt
     export async function GET(request: NextRequest, { params }: RouteParams) {
       try {
         const { id } = params;
         
         const supabase = createServerSupabaseClient();
         const promptService = createPromptService(supabase);
         
         const prompt = await promptService.getPromptById(id);
         
         if (!prompt) {
           return NextResponse.json(
             { error: 'Prompt not found' },
             { status: 404 }
           );
         }
         
         return NextResponse.json({ prompt });
         
       } catch (error: any) {
         console.error('GET /api/prompts/[id] error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to fetch prompt' },
           { status: 500 }
         );
       }
     }
     
     // PUT - Update prompt
     export async function PUT(request: NextRequest, { params }: RouteParams) {
       try {
         const { id } = params;
         const body = await request.json();
         
         const supabase = createServerSupabaseClient();
         const promptService = createPromptService(supabase);
         
         // Check if prompt exists
         const existing = await promptService.getPromptById(id);
         if (!existing) {
           return NextResponse.json(
             { error: 'Prompt not found' },
             { status: 404 }
           );
         }
         
         const prompt = await promptService.updatePrompt(id, body);
         
         return NextResponse.json({ prompt, success: true });
         
       } catch (error: any) {
         console.error('PUT /api/prompts/[id] error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to update prompt' },
           { status: 500 }
         );
       }
     }
     
     // DELETE - Delete prompt
     export async function DELETE(request: NextRequest, { params }: RouteParams) {
       try {
         const { id } = params;
         
         const supabase = createServerSupabaseClient();
         const promptService = createPromptService(supabase);
         
         await promptService.deletePrompt(id);
         
         return NextResponse.json({ success: true });
         
       } catch (error: any) {
         console.error('DELETE /api/prompts/[id] error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to delete prompt' },
           { status: 500 }
         );
       }
     }
     
     // PATCH - Toggle active status
     export async function PATCH(request: NextRequest, { params }: RouteParams) {
       try {
         const { id } = params;
         
         const supabase = createServerSupabaseClient();
         const promptService = createPromptService(supabase);
         
         const prompt = await promptService.togglePromptActive(id);
         
         return NextResponse.json({ prompt, success: true });
         
       } catch (error: any) {
         console.error('PATCH /api/prompts/[id] error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to toggle prompt' },
           { status: 500 }
         );
       }
     }
     ```
  
  6. Create usePrompts hook:
     ```typescript
     // ============================================
     // [F083] src/hooks/usePrompts.ts
     // ============================================
     
     'use client';
     
     import { useState, useEffect, useCallback } from 'react';
     import { Prompt } from '@/lib/types';
     import { PROMPT_CATEGORIES } from '@/lib/prompts/default-prompts';
     
     interface UsePromptsOptions {
       activeOnly?: boolean;
       category?: string;
       autoFetch?: boolean;
     }
     
     interface UsePromptsReturn {
       prompts: Prompt[];
       loading: boolean;
       error: string | null;
       categories: typeof PROMPT_CATEGORIES;
       
       // Actions
       fetchPrompts: () => Promise<void>;
       searchPrompts: (query: string, locale?: 'en' | 'fa') => Promise<void>;
       createPrompt: (prompt: Omit<Prompt, 'id' | 'created_at' | 'updated_at'>) => Promise<Prompt>;
       updatePrompt: (id: string, updates: Partial<Prompt>) => Promise<Prompt>;
       deletePrompt: (id: string) => Promise<void>;
       togglePromptActive: (id: string) => Promise<Prompt>;
       getPromptsByIds: (ids: string[]) => Promise<Prompt[]>;
     }
     
     export function usePrompts(options: UsePromptsOptions = {}): UsePromptsReturn {
       const { activeOnly = false, category, autoFetch = true } = options;
       
       const [prompts, setPrompts] = useState<Prompt[]>([]);
       const [loading, setLoading] = useState(true);
       const [error, setError] = useState<string | null>(null);
       
       const fetchPrompts = useCallback(async () => {
         setLoading(true);
         setError(null);
         
         try {
           const params = new URLSearchParams();
           if (activeOnly) params.set('active', 'true');
           if (category) params.set('category', category);
           
           const res = await fetch(`/api/prompts?${params}`);
           const data = await res.json();
           
           if (data.error) throw new Error(data.error);
           
           setPrompts(data.prompts || []);
           
         } catch (err: any) {
           setError(err.message);
           setPrompts([]);
         } finally {
           setLoading(false);
         }
       }, [activeOnly, category]);
       
       const searchPrompts = useCallback(async (query: string, locale: 'en' | 'fa' = 'en') => {
         setLoading(true);
         setError(null);
         
         try {
           const params = new URLSearchParams({
             search: query,
             locale
           });
           
           const res = await fetch(`/api/prompts?${params}`);
           const data = await res.json();
           
           if (data.error) throw new Error(data.error);
           
           setPrompts(data.prompts || []);
           
         } catch (err: any) {
           setError(err.message);
         } finally {
           setLoading(false);
         }
       }, []);
       
       const createPrompt = useCallback(async (
         prompt: Omit<Prompt, 'id' | 'created_at' | 'updated_at'>
       ): Promise<Prompt> => {
         const res = await fetch('/api/prompts', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify(prompt)
         });
         
         const data = await res.json();
         if (data.error) throw new Error(data.error);
         
         // Add to local state
         setPrompts(prev => [...prev, data.prompt]);
         
         return data.prompt;
       }, []);
       
       const updatePrompt = useCallback(async (
         id: string,
         updates: Partial<Prompt>
       ): Promise<Prompt> => {
         const res = await fetch(`/api/prompts/${id}`, {
           method: 'PUT',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify(updates)
         });
         
         const data = await res.json();
         if (data.error) throw new Error(data.error);
         
         // Update local state
         setPrompts(prev => prev.map(p => p.id === id ? data.prompt : p));
         
         return data.prompt;
       }, []);
       
       const deletePrompt = useCallback(async (id: string): Promise<void> => {
         const res = await fetch(`/api/prompts/${id}`, {
           method: 'DELETE'
         });
         
         const data = await res.json();
         if (data.error) throw new Error(data.error);
         
         // Remove from local state
         setPrompts(prev => prev.filter(p => p.id !== id));
       }, []);
       
       const togglePromptActive = useCallback(async (id: string): Promise<Prompt> => {
         const res = await fetch(`/api/prompts/${id}`, {
           method: 'PATCH'
         });
         
         const data = await res.json();
         if (data.error) throw new Error(data.error);
         
         // Update local state
         setPrompts(prev => prev.map(p => p.id === id ? data.prompt : p));
         
         return data.prompt;
       }, []);
       
       const getPromptsByIds = useCallback(async (ids: string[]): Promise<Prompt[]> => {
         if (ids.length === 0) return [];
         
         // First check local cache
         const localPrompts = prompts.filter(p => ids.includes(p.id));
         if (localPrompts.length === ids.length) {
           return localPrompts;
         }
         
         // Fetch from API
         const res = await fetch(`/api/prompts?ids=${ids.join(',')}`);
         const data = await res.json();
         
         if (data.error) throw new Error(data.error);
         return data.prompts || [];
       }, [prompts]);
       
       // Auto fetch on mount
       useEffect(() => {
         if (autoFetch) {
           fetchPrompts();
         }
       }, [autoFetch, fetchPrompts]);
       
       return {
         prompts,
         loading,
         error,
         categories: PROMPT_CATEGORIES,
         fetchPrompts,
         searchPrompts,
         createPrompt,
         updatePrompt,
         deletePrompt,
         togglePromptActive,
         getPromptsByIds
       };
     }
     ```
  
  7. Create PromptCard.tsx:
     ```typescript
     // ============================================
     // [F122] src/components/prompts/PromptCard.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { useParams } from 'next/navigation';
     import { Prompt } from '@/lib/types';
     import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
     import { Badge } from '@/components/ui/badge';
     import { Button } from '@/components/ui/button';
     import { 
       Pencil, Trash2, Eye, Power, PowerOff, GripVertical, Check 
     } from 'lucide-react';
     import { cn } from '@/lib/utils';
     import { PROMPT_CATEGORIES } from '@/lib/prompts/default-prompts';
     
     interface PromptCardProps {
       prompt: Prompt;
       onEdit?: (prompt: Prompt) => void;
       onDelete?: (prompt: Prompt) => void;
       onPreview?: (prompt: Prompt) => void;
       onToggleActive?: (prompt: Prompt) => void;
       onSelect?: (prompt: Prompt) => void;
       selected?: boolean;
       selectable?: boolean;
       editable?: boolean;
       draggable?: boolean;
       className?: string;
     }
     
     export function PromptCard({
       prompt,
       onEdit,
       onDelete,
       onPreview,
       onToggleActive,
       onSelect,
       selected = false,
       selectable = false,
       editable = false,
       draggable = false,
       className
     }: PromptCardProps) {
       const params = useParams();
       const locale = params.locale as 'en' | 'fa';
       const t = useTranslations('prompts');
       
       const title = locale === 'fa' ? prompt.title_fa : prompt.title_en;
       const description = locale === 'fa' ? prompt.description_fa : prompt.description_en;
       
       const categoryInfo = PROMPT_CATEGORIES.find(c => c.value === prompt.category);
       const categoryLabel = locale === 'fa' 
         ? categoryInfo?.label_fa 
         : categoryInfo?.label_en;
       
       const handleClick = () => {
         if (selectable && onSelect) {
           onSelect(prompt);
         }
       };
       
       return (
         <Card 
           className={cn(
             'relative transition-all',
             selectable && 'cursor-pointer hover:border-primary',
             selected && 'border-primary ring-2 ring-primary/20',
             !prompt.is_active && 'opacity-60',
             className
           )}
           onClick={handleClick}
         >
           {/* Drag Handle */}
           {draggable && (
             <div className="absolute left-2 top-1/2 -translate-y-1/2 cursor-grab active:cursor-grabbing">
               <GripVertical className="h-5 w-5 text-muted-foreground" />
             </div>
           )}
           
           {/* Selected Indicator */}
           {selected && (
             <div className="absolute top-3 right-3 bg-primary text-primary-foreground rounded-full p-1">
               <Check className="h-4 w-4" />
             </div>
           )}
           
           <CardHeader className={cn(draggable && 'pl-10')}>
             <div className="flex items-start justify-between gap-2">
               <div className="space-y-1 flex-1">
                 <CardTitle className="text-lg">{title}</CardTitle>
                 <CardDescription className="line-clamp-2">
                   {description}
                 </CardDescription>
               </div>
             </div>
             
             <div className="flex items-center gap-2 mt-2">
               <Badge variant="outline">{categoryLabel}</Badge>
               <Badge 
                 variant={prompt.is_active ? 'default' : 'secondary'}
                 className={cn(
                   prompt.is_active 
                     ? 'bg-green-100 text-green-700 hover:bg-green-100' 
                     : ''
                 )}
               >
                 {prompt.is_active ? t('active') : t('inactive')}
               </Badge>
             </div>
           </CardHeader>
           
           {editable && (
             <CardContent className={cn(draggable && 'pl-10')}>
               <div className="flex items-center gap-2">
                 <Button 
                   variant="ghost" 
                   size="sm"
                   onClick={(e) => { e.stopPropagation(); onPreview?.(prompt); }}
                 >
                   <Eye className="h-4 w-4 mr-1" />
                   {t('preview')}
                 </Button>
                 <Button 
                   variant="ghost" 
                   size="sm"
                   onClick={(e) => { e.stopPropagation(); onEdit?.(prompt); }}
                 >
                   <Pencil className="h-4 w-4 mr-1" />
                   {t('edit')}
                 </Button>
                 <Button 
                   variant="ghost" 
                   size="sm"
                   onClick={(e) => { e.stopPropagation(); onToggleActive?.(prompt); }}
                 >
                   {prompt.is_active ? (
                     <>
                       <PowerOff className="h-4 w-4 mr-1" />
                       {t('deactivate')}
                     </>
                   ) : (
                     <>
                       <Power className="h-4 w-4 mr-1" />
                       {t('activate')}
                     </>
                   )}
                 </Button>
                 <Button 
                   variant="ghost" 
                   size="sm"
                   className="text-destructive hover:text-destructive"
                   onClick={(e) => { e.stopPropagation(); onDelete?.(prompt); }}
                 >
                   <Trash2 className="h-4 w-4 mr-1" />
                   {t('delete')}
                 </Button>
               </div>
             </CardContent>
           )}
         </Card>
       );
     }
     ```
  
  8. Create PromptPreview.tsx:
     ```typescript
     // ============================================
     // [F123] src/components/prompts/PromptPreview.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { useParams } from 'next/navigation';
     import { Prompt } from '@/lib/types';
     import {
       Dialog,
       DialogContent,
       DialogHeader,
       DialogTitle,
       DialogDescription,
     } from '@/components/ui/dialog';
     import { Badge } from '@/components/ui/badge';
     import { ScrollArea } from '@/components/ui/scroll-area';
     import { PROMPT_CATEGORIES } from '@/lib/prompts/default-prompts';
     
     interface PromptPreviewProps {
       prompt: Prompt | null;
       open: boolean;
       onClose: () => void;
     }
     
     export function PromptPreview({ prompt, open, onClose }: PromptPreviewProps) {
       const params = useParams();
       const locale = params.locale as 'en' | 'fa';
       const t = useTranslations('prompts');
       
       if (!prompt) return null;
       
       const title = locale === 'fa' ? prompt.title_fa : prompt.title_en;
       const description = locale === 'fa' ? prompt.description_fa : prompt.description_en;
       
       const categoryInfo = PROMPT_CATEGORIES.find(c => c.value === prompt.category);
       const categoryLabel = locale === 'fa' 
         ? categoryInfo?.label_fa 
         : categoryInfo?.label_en;
       
       return (
         <Dialog open={open} onOpenChange={onClose}>
           <DialogContent className="max-w-3xl max-h-[90vh]">
             <DialogHeader>
               <div className="flex items-center gap-2 mb-2">
                 <Badge variant="outline">{categoryLabel}</Badge>
                 <Badge variant={prompt.is_active ? 'default' : 'secondary'}>
                   {prompt.is_active ? t('active') : t('inactive')}
                 </Badge>
               </div>
               <DialogTitle>{title}</DialogTitle>
               <DialogDescription>{description}</DialogDescription>
             </DialogHeader>
             
             <div className="mt-4">
               <h4 className="text-sm font-medium mb-2">{t('prompt_text')}</h4>
               <ScrollArea className="h-[400px] rounded-md border p-4 bg-muted/50">
                 <pre className="text-sm whitespace-pre-wrap font-mono">
                   {prompt.prompt_text}
                 </pre>
               </ScrollArea>
             </div>
           </DialogContent>
         </Dialog>
       );
     }
     ```
  
  9. Create PromptEditor.tsx:
     ```typescript
     // ============================================
     // [F046] src/components/prompts/PromptEditor.tsx
     // ============================================
     
     'use client';
     
     import { useState, useEffect } from 'react';
     import { useTranslations } from 'next-intl';
     import { Prompt } from '@/lib/types';
     import { PROMPT_CATEGORIES } from '@/lib/prompts/default-prompts';
     import {
       Dialog,
       DialogContent,
       DialogHeader,
       DialogTitle,
       DialogFooter,
     } from '@/components/ui/dialog';
     import { Button } from '@/components/ui/button';
     import { Input } from '@/components/ui/input';
     import { Label } from '@/components/ui/label';
     import { Textarea } from '@/components/ui/textarea';
     import {
       Select,
       SelectContent,
       SelectItem,
       SelectTrigger,
       SelectValue,
     } from '@/components/ui/select';
     import { Switch } from '@/components/ui/switch';
     import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
     import { Loader2 } from 'lucide-react';
     
     interface PromptEditorProps {
       prompt?: Prompt | null;  // null = create new
       open: boolean;
       onClose: () => void;
       onSave: (prompt: Omit<Prompt, 'id' | 'created_at' | 'updated_at'>) => Promise<void>;
     }
     
     const emptyPrompt = {
       title_en: '',
       title_fa: '',
       description_en: '',
       description_fa: '',
       prompt_text: '',
       category: 'general',
       is_active: true,
       sort_order: 0
     };
     
     export function PromptEditor({ prompt, open, onClose, onSave }: PromptEditorProps) {
       const t = useTranslations('prompts');
       const [formData, setFormData] = useState(emptyPrompt);
       const [saving, setSaving] = useState(false);
       const [activeTab, setActiveTab] = useState<'en' | 'fa'>('en');
       
       // Reset form when prompt changes
       useEffect(() => {
         if (prompt) {
           setFormData({
             title_en: prompt.title_en,
             title_fa: prompt.title_fa,
             description_en: prompt.description_en,
             description_fa: prompt.description_fa,
             prompt_text: prompt.prompt_text,
             category: prompt.category,
             is_active: prompt.is_active,
             sort_order: prompt.sort_order
           });
         } else {
           setFormData(emptyPrompt);
         }
       }, [prompt, open]);
       
       const handleChange = (field: string, value: any) => {
         setFormData(prev => ({ ...prev, [field]: value }));
       };
       
       const handleSubmit = async () => {
         // Validation
         if (!formData.title_en || !formData.title_fa || !formData.prompt_text) {
           return;
         }
         
         setSaving(true);
         try {
           await onSave(formData);
           onClose();
         } finally {
           setSaving(false);
         }
       };
       
       const isEditing = prompt !== null && prompt !== undefined;
       
       return (
         <Dialog open={open} onOpenChange={onClose}>
           <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
             <DialogHeader>
               <DialogTitle>
                 {isEditing ? t('edit_prompt') : t('create_prompt')}
               </DialogTitle>
             </DialogHeader>
             
             <div className="space-y-6 py-4">
               {/* Title and Description - Bilingual */}
               <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as 'en' | 'fa')}>
                 <TabsList className="grid w-full grid-cols-2">
                   <TabsTrigger value="en">English</TabsTrigger>
                   <TabsTrigger value="fa">فارسی</TabsTrigger>
                 </TabsList>
                 
                 <TabsContent value="en" className="space-y-4 mt-4">
                   <div className="grid gap-2">
                     <Label htmlFor="title_en">{t('title')} (English) *</Label>
                     <Input
                       id="title_en"
                       value={formData.title_en}
                       onChange={(e) => handleChange('title_en', e.target.value)}
                       placeholder="Professional CV Tailoring"
                     />
                   </div>
                   <div className="grid gap-2">
                     <Label htmlFor="description_en">{t('description')} (English)</Label>
                     <Textarea
                       id="description_en"
                       value={formData.description_en}
                       onChange={(e) => handleChange('description_en', e.target.value)}
                       placeholder="A brief description of what this prompt does..."
                       rows={2}
                     />
                   </div>
                 </TabsContent>
                 
                 <TabsContent value="fa" className="space-y-4 mt-4" dir="rtl">
                   <div className="grid gap-2">
                     <Label htmlFor="title_fa">{t('title')} (فارسی) *</Label>
                     <Input
                       id="title_fa"
                       value={formData.title_fa}
                       onChange={(e) => handleChange('title_fa', e.target.value)}
                       placeholder="تنظیم حرفه‌ای سی‌وی"
                     />
                   </div>
                   <div className="grid gap-2">
                     <Label htmlFor="description_fa">{t('description')} (فارسی)</Label>
                     <Textarea
                       id="description_fa"
                       value={formData.description_fa}
                       onChange={(e) => handleChange('description_fa', e.target.value)}
                       placeholder="توضیح کوتاهی درباره عملکرد این پرامپت..."
                       rows={2}
                     />
                   </div>
                 </TabsContent>
               </Tabs>
               
               {/* Category */}
               <div className="grid gap-2">
                 <Label htmlFor="category">{t('category')}</Label>
                 <Select
                   value={formData.category}
                   onValueChange={(v) => handleChange('category', v)}
                 >
                   <SelectTrigger>
                     <SelectValue />
                   </SelectTrigger>
                   <SelectContent>
                     {PROMPT_CATEGORIES.map((cat) => (
                       <SelectItem key={cat.value} value={cat.value}>
                         {cat.label_en} / {cat.label_fa}
                       </SelectItem>
                     ))}
                   </SelectContent>
                 </Select>
               </div>
               
               {/* Prompt Text */}
               <div className="grid gap-2">
                 <Label htmlFor="prompt_text">{t('prompt_text')} *</Label>
                 <Textarea
                   id="prompt_text"
                   value={formData.prompt_text}
                   onChange={(e) => handleChange('prompt_text', e.target.value)}
                   placeholder="You are an expert CV writer..."
                   rows={12}
                   className="font-mono text-sm"
                 />
                 <p className="text-xs text-muted-foreground">
                   {t('prompt_text_hint')}
                 </p>
               </div>
               
               {/* Active Status */}
               <div className="flex items-center justify-between">
                 <div>
                   <Label htmlFor="is_active">{t('active_status')}</Label>
                   <p className="text-sm text-muted-foreground">
                     {t('active_status_hint')}
                   </p>
                 </div>
                 <Switch
                   id="is_active"
                   checked={formData.is_active}
                   onCheckedChange={(v) => handleChange('is_active', v)}
                 />
               </div>
             </div>
             
             <DialogFooter>
               <Button variant="outline" onClick={onClose} disabled={saving}>
                 {t('cancel')}
               </Button>
               <Button onClick={handleSubmit} disabled={saving}>
                 {saving ? (
                   <>
                     <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                     {t('saving')}
                   </>
                 ) : (
                   t('save')
                 )}
               </Button>
             </DialogFooter>
           </DialogContent>
         </Dialog>
       );
     }
     ```
  
  10. Create PromptCategoryFilter.tsx:
      ```typescript
      // ============================================
      // [F048] src/components/prompts/PromptCategoryFilter.tsx
      // ============================================
      
      'use client';
      
      import { useTranslations } from 'next-intl';
      import { useParams } from 'next/navigation';
      import { PROMPT_CATEGORIES } from '@/lib/prompts/default-prompts';
      import { Badge } from '@/components/ui/badge';
      import { cn } from '@/lib/utils';
      
      interface PromptCategoryFilterProps {
        selectedCategory: string | null;
        onCategoryChange: (category: string | null) => void;
        className?: string;
      }
      
      export function PromptCategoryFilter({
        selectedCategory,
        onCategoryChange,
        className
      }: PromptCategoryFilterProps) {
        const params = useParams();
        const locale = params.locale as 'en' | 'fa';
        const t = useTranslations('prompts');
        
        return (
          <div className={cn('flex flex-wrap gap-2', className)}>
            <Badge
              variant={selectedCategory === null ? 'default' : 'outline'}
              className="cursor-pointer"
              onClick={() => onCategoryChange(null)}
            >
              {t('all_categories')}
            </Badge>
            {PROMPT_CATEGORIES.map((cat) => (
              <Badge
                key={cat.value}
                variant={selectedCategory === cat.value ? 'default' : 'outline'}
                className="cursor-pointer"
                onClick={() => onCategoryChange(cat.value)}
              >
                {locale === 'fa' ? cat.label_fa : cat.label_en}
              </Badge>
            ))}
          </div>
        );
      }
      ```
  
  11. Create PromptList.tsx:
      ```typescript
      // ============================================
      // [F045] src/components/prompts/PromptList.tsx
      // ============================================
      
      'use client';
      
      import { useState } from 'react';
      import { useTranslations } from 'next-intl';
      import { Prompt } from '@/lib/types';
      import { PromptCard } from './PromptCard';
      import { PromptCategoryFilter } from './PromptCategoryFilter';
      import { Input } from '@/components/ui/input';
      import { Search, Loader2 } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      interface PromptListProps {
        prompts: Prompt[];
        loading?: boolean;
        editable?: boolean;
        selectable?: boolean;
        selectedIds?: string[];
        onEdit?: (prompt: Prompt) => void;
        onDelete?: (prompt: Prompt) => void;
        onPreview?: (prompt: Prompt) => void;
        onToggleActive?: (prompt: Prompt) => void;
        onSelect?: (prompt: Prompt) => void;
        onSearch?: (query: string) => void;
        className?: string;
      }
      
      export function PromptList({
        prompts,
        loading = false,
        editable = false,
        selectable = false,
        selectedIds = [],
        onEdit,
        onDelete,
        onPreview,
        onToggleActive,
        onSelect,
        onSearch,
        className
      }: PromptListProps) {
        const t = useTranslations('prompts');
        const [searchQuery, setSearchQuery] = useState('');
        const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
        
        // Filter prompts locally
        const filteredPrompts = prompts.filter(prompt => {
          // Category filter
          if (selectedCategory && prompt.category !== selectedCategory) {
            return false;
          }
          
          // Search filter (client-side for immediate feedback)
          if (searchQuery) {
            const query = searchQuery.toLowerCase();
            return (
              prompt.title_en.toLowerCase().includes(query) ||
              prompt.title_fa.includes(searchQuery) ||
              prompt.description_en.toLowerCase().includes(query) ||
              prompt.description_fa.includes(searchQuery)
            );
          }
          
          return true;
        });
        
        const handleSearchChange = (value: string) => {
          setSearchQuery(value);
          onSearch?.(value);
        };
        
        return (
          <div className={cn('space-y-4', className)}>
            {/* Search and Filter */}
            <div className="space-y-3">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder={t('search_prompts')}
                  value={searchQuery}
                  onChange={(e) => handleSearchChange(e.target.value)}
                  className="pl-10"
                />
              </div>
              
              <PromptCategoryFilter
                selectedCategory={selectedCategory}
                onCategoryChange={setSelectedCategory}
              />
            </div>
            
            {/* Loading State */}
            {loading && (
              <div className="flex items-center justify-center py-12">
                <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
              </div>
            )}
            
            {/* Empty State */}
            {!loading && filteredPrompts.length === 0 && (
              <div className="text-center py-12">
                <p className="text-muted-foreground">{t('no_prompts_found')}</p>
              </div>
            )}
            
            {/* Prompt Grid */}
            {!loading && filteredPrompts.length > 0 && (
              <div className="grid gap-4 md:grid-cols-2">
                {filteredPrompts.map((prompt) => (
                  <PromptCard
                    key={prompt.id}
                    prompt={prompt}
                    editable={editable}
                    selectable={selectable}
                    selected={selectedIds.includes(prompt.id)}
                    onEdit={onEdit}
                    onDelete={onDelete}
                    onPreview={onPreview}
                    onToggleActive={onToggleActive}
                    onSelect={onSelect}
                  />
                ))}
              </div>
            )}
          </div>
        );
      }
      ```
  
  12. Create PromptSelector.tsx (for use in application flow):
      ```typescript
      // ============================================
      // [F047] src/components/prompts/PromptSelector.tsx
      // ============================================
      
      'use client';
      
      import { useState, useCallback, useEffect } from 'react';
      import { useTranslations } from 'next-intl';
      import { Prompt } from '@/lib/types';
      import { usePrompts } from '@/hooks/usePrompts';
      import { PromptList } from './PromptList';
      import { PromptPreview } from './PromptPreview';
      import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
      import { Badge } from '@/components/ui/badge';
      import { Button } from '@/components/ui/button';
      import { FileText, X } from 'lucide-react';
      import { cn } from '@/lib/utils';
      
      interface PromptSelectorProps {
        selectedIds: string[];
        onSelectionChange: (ids: string[]) => void;
        maxSelection?: number;  // null = unlimited
        className?: string;
      }
      
      export function PromptSelector({
        selectedIds,
        onSelectionChange,
        maxSelection = null,
        className
      }: PromptSelectorProps) {
        const t = useTranslations('prompts');
        const { prompts, loading } = usePrompts({ activeOnly: true });
        const [previewPrompt, setPreviewPrompt] = useState<Prompt | null>(null);
        
        const handleSelect = useCallback((prompt: Prompt) => {
          const isSelected = selectedIds.includes(prompt.id);
          
          if (isSelected) {
            // Deselect
            onSelectionChange(selectedIds.filter(id => id !== prompt.id));
          } else {
            // Select (check max)
            if (maxSelection && selectedIds.length >= maxSelection) {
              // Replace last selection
              onSelectionChange([...selectedIds.slice(0, -1), prompt.id]);
            } else {
              onSelectionChange([...selectedIds, prompt.id]);
            }
          }
        }, [selectedIds, maxSelection, onSelectionChange]);
        
        const handleRemove = useCallback((id: string) => {
          onSelectionChange(selectedIds.filter(i => i !== id));
        }, [selectedIds, onSelectionChange]);
        
        // Get selected prompt objects
        const selectedPrompts = prompts.filter(p => selectedIds.includes(p.id));
        
        return (
          <div className={cn('space-y-4', className)}>
            {/* Selected Prompts */}
            {selectedPrompts.length > 0 && (
              <Card>
                <CardHeader className="pb-3">
                  <CardTitle className="text-base flex items-center gap-2">
                    <FileText className="h-4 w-4" />
                    {t('selected_prompts')} ({selectedPrompts.length})
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="flex flex-wrap gap-2">
                    {selectedPrompts.map((prompt, index) => (
                      <Badge
                        key={prompt.id}
                        variant="secondary"
                        className="px-3 py-1.5"
                      >
                        <span className="mr-1 text-xs text-muted-foreground">
                          {index + 1}.
                        </span>
                        {prompt.title_en}
                        <button
                          onClick={() => handleRemove(prompt.id)}
                          className="ml-2 hover:text-destructive"
                        >
                          <X className="h-3 w-3" />
                        </button>
                      </Badge>
                    ))}
                  </div>
                </CardContent>
              </Card>
            )}
            
            {/* Prompt List */}
            <Card>
              <CardHeader>
                <CardTitle>{t('available_prompts')}</CardTitle>
                <CardDescription>
                  {maxSelection 
                    ? t('select_up_to', { count: maxSelection })
                    : t('select_prompts_hint')
                  }
                </CardDescription>
              </CardHeader>
              <CardContent>
                <PromptList
                  prompts={prompts}
                  loading={loading}
                  selectable
                  selectedIds={selectedIds}
                  onSelect={handleSelect}
                  onPreview={setPreviewPrompt}
                />
              </CardContent>
            </Card>
            
            {/* Preview Dialog */}
            <PromptPreview
              prompt={previewPrompt}
              open={previewPrompt !== null}
              onClose={() => setPreviewPrompt(null)}
            />
          </div>
        );
      }
      ```
  
  13. Create prompts/loading.tsx:
      ```typescript
      // ============================================
      // [F124] src/app/[locale]/prompts/loading.tsx
      // ============================================
      
      import { Skeleton } from '@/components/ui/skeleton';
      import { Card, CardContent, CardHeader } from '@/components/ui/card';
      
      export default function Loading() {
        return (
          <div className="container mx-auto p-6 space-y-6">
            {/* Header */}
            <div className="flex items-center justify-between">
              <div className="space-y-2">
                <Skeleton className="h-8 w-48" />
                <Skeleton className="h-4 w-72" />
              </div>
              <Skeleton className="h-10 w-32" />
            </div>
            
            {/* Search and filter */}
            <Skeleton className="h-10 w-full" />
            <div className="flex gap-2">
              {Array.from({ length: 5 }).map((_, i) => (
                <Skeleton key={i} className="h-6 w-20" />
              ))}
            </div>
            
            {/* Cards grid */}
            <div className="grid gap-4 md:grid-cols-2">
              {Array.from({ length: 4 }).map((_, i) => (
                <Card key={i}>
                  <CardHeader>
                    <Skeleton className="h-6 w-3/4" />
                    <Skeleton className="h-4 w-full" />
                  </CardHeader>
                  <CardContent>
                    <Skeleton className="h-8 w-full" />
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        );
      }
      ```
  
  14. Create prompts/page.tsx:
      ```typescript
      // ============================================
      // [F015] src/app/[locale]/prompts/page.tsx
      // ============================================
      
      'use client';
      
      import { useState } from 'react';
      import { useTranslations } from 'next-intl';
      import { AuthGuard } from '@/components/auth/AuthGuard';
      import { usePrompts } from '@/hooks/usePrompts';
      import { PromptList } from '@/components/prompts/PromptList';
      import { PromptEditor } from '@/components/prompts/PromptEditor';
      import { PromptPreview } from '@/components/prompts/PromptPreview';
      import { Button } from '@/components/ui/button';
      import { useToast } from '@/components/ui/use-toast';
      import {
        AlertDialog,
        AlertDialogAction,
        AlertDialogCancel,
        AlertDialogContent,
        AlertDialogDescription,
        AlertDialogFooter,
        AlertDialogHeader,
        AlertDialogTitle,
      } from '@/components/ui/alert-dialog';
      import { Prompt } from '@/lib/types';
      import { FileText, Plus, Loader2 } from 'lucide-react';
      
      export default function PromptsPage() {
        const t = useTranslations('prompts');
        const { toast } = useToast();
        
        const {
          prompts,
          loading,
          error,
          createPrompt,
          updatePrompt,
          deletePrompt,
          togglePromptActive,
          searchPrompts
        } = usePrompts();
        
        // UI state
        const [editorOpen, setEditorOpen] = useState(false);
        const [editingPrompt, setEditingPrompt] = useState<Prompt | null>(null);
        const [previewPrompt, setPreviewPrompt] = useState<Prompt | null>(null);
        const [deletePrompt_, setDeletePrompt] = useState<Prompt | null>(null);
        const [actionLoading, setActionLoading] = useState(false);
        
        // Handlers
        const handleCreate = () => {
          setEditingPrompt(null);
          setEditorOpen(true);
        };
        
        const handleEdit = (prompt: Prompt) => {
          setEditingPrompt(prompt);
          setEditorOpen(true);
        };
        
        const handleSave = async (data: Omit<Prompt, 'id' | 'created_at' | 'updated_at'>) => {
          try {
            if (editingPrompt) {
              await updatePrompt(editingPrompt.id, data);
              toast({ title: t('prompt_updated') });
            } else {
              await createPrompt(data);
              toast({ title: t('prompt_created') });
            }
          } catch (err: any) {
            toast({
              variant: 'destructive',
              title: t('save_error'),
              description: err.message
            });
            throw err;
          }
        };
        
        const handleDelete = async () => {
          if (!deletePrompt_) return;
          
          setActionLoading(true);
          try {
            await deletePrompt(deletePrompt_.id);
            toast({ title: t('prompt_deleted') });
            setDeletePrompt(null);
          } catch (err: any) {
            toast({
              variant: 'destructive',
              title: t('delete_error'),
              description: err.message
            });
          } finally {
            setActionLoading(false);
          }
        };
        
        const handleToggleActive = async (prompt: Prompt) => {
          try {
            await togglePromptActive(prompt.id);
            toast({
              title: prompt.is_active ? t('prompt_deactivated') : t('prompt_activated')
            });
          } catch (err: any) {
            toast({
              variant: 'destructive',
              title: t('toggle_error'),
              description: err.message
            });
          }
        };
        
        return (
          <AuthGuard>
            <div className="container mx-auto p-6 max-w-5xl">
              {/* Header */}
              <div className="flex items-center justify-between mb-6">
                <div>
                  <h1 className="text-2xl font-bold flex items-center gap-2">
                    <FileText className="h-6 w-6" />
                    {t('title')}
                  </h1>
                  <p className="text-muted-foreground mt-1">
                    {t('description')}
                  </p>
                </div>
                
                <Button onClick={handleCreate}>
                  <Plus className="h-4 w-4 mr-2" />
                  {t('create_prompt')}
                </Button>
              </div>
              
              {/* Error State */}
              {error && (
                <div className="mb-6 p-4 bg-destructive/10 text-destructive rounded-lg">
                  {error}
                </div>
              )}
              
              {/* Prompt List */}
              <PromptList
                prompts={prompts}
                loading={loading}
                editable
                onEdit={handleEdit}
                onDelete={setDeletePrompt}
                onPreview={setPreviewPrompt}
                onToggleActive={handleToggleActive}
                onSearch={searchPrompts}
              />
              
              {/* Editor Dialog */}
              <PromptEditor
                prompt={editingPrompt}
                open={editorOpen}
                onClose={() => {
                  setEditorOpen(false);
                  setEditingPrompt(null);
                }}
                onSave={handleSave}
              />
              
              {/* Preview Dialog */}
              <PromptPreview
                prompt={previewPrompt}
                open={previewPrompt !== null}
                onClose={() => setPreviewPrompt(null)}
              />
              
              {/* Delete Confirmation */}
              <AlertDialog 
                open={deletePrompt_ !== null} 
                onOpenChange={() => setDeletePrompt(null)}
              >
                <AlertDialogContent>
                  <AlertDialogHeader>
                    <AlertDialogTitle>{t('delete_confirm_title')}</AlertDialogTitle>
                    <AlertDialogDescription>
                      {t('delete_confirm_description', { 
                        title: deletePrompt_?.title_en 
                      })}
                    </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                    <AlertDialogCancel disabled={actionLoading}>
                      {t('cancel')}
                    </AlertDialogCancel>
                    <AlertDialogAction
                      onClick={handleDelete}
                      disabled={actionLoading}
                      className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                    >
                      {actionLoading ? (
                        <Loader2 className="h-4 w-4 animate-spin" />
                      ) : (
                        t('delete')
                      )}
                    </AlertDialogAction>
                  </AlertDialogFooter>
                </AlertDialogContent>
              </AlertDialog>
            </div>
          </AuthGuard>
        );
      }
      ```
  
  15. Add translations to en.json under "prompts" key:
      ```json
      {
        "prompts": {
          "title": "Prompt Management",
          "description": "Create and manage prompts for CV tailoring",
          "create_prompt": "Create Prompt",
          "edit_prompt": "Edit Prompt",
          "search_prompts": "Search prompts...",
          "all_categories": "All",
          "no_prompts_found": "No prompts found",
          "active": "Active",
          "inactive": "Inactive",
          "preview": "Preview",
          "edit": "Edit",
          "delete": "Delete",
          "activate": "Activate",
          "deactivate": "Deactivate",
          "title_label": "Title",
          "description_label": "Description",
          "category": "Category",
          "prompt_text": "Prompt Text",
          "prompt_text_hint": "This is the instruction sent to the AI. Use clear, detailed instructions.",
          "active_status": "Active",
          "active_status_hint": "Only active prompts are available for selection",
          "save": "Save",
          "saving": "Saving...",
          "cancel": "Cancel",
          "prompt_created": "Prompt created successfully",
          "prompt_updated": "Prompt updated successfully",
          "prompt_deleted": "Prompt deleted successfully",
          "prompt_activated": "Prompt activated",
          "prompt_deactivated": "Prompt deactivated",
          "save_error": "Failed to save prompt",
          "delete_error": "Failed to delete prompt",
          "toggle_error": "Failed to toggle prompt status",
          "delete_confirm_title": "Delete Prompt?",
          "delete_confirm_description": "Are you sure you want to delete \"{title}\"? This action cannot be undone.",
          "selected_prompts": "Selected Prompts",
          "available_prompts": "Available Prompts",
          "select_prompts_hint": "Select one or more prompts to use",
          "select_up_to": "Select up to {count} prompts"
        }
      }
      ```
  
  16. Add translations to fa.json under "prompts" key:
      ```json
      {
        "prompts": {
          "title": "مدیریت پرامپت‌ها",
          "description": "ایجاد و مدیریت پرامپت‌ها برای تنظیم سی‌وی",
          "create_prompt": "ایجاد پرامپت",
          "edit_prompt": "ویرایش پرامپت",
          "search_prompts": "جستجوی پرامپت‌ها...",
          "all_categories": "همه",
          "no_prompts_found": "پرامپتی یافت نشد",
          "active": "فعال",
          "inactive": "غیرفعال",
          "preview": "پیش‌نمایش",
          "edit": "ویرایش",
          "delete": "حذف",
          "activate": "فعال‌سازی",
          "deactivate": "غیرفعال‌سازی",
          "title_label": "عنوان",
          "description_label": "توضیحات",
          "category": "دسته‌بندی",
          "prompt_text": "متن پرامپت",
          "prompt_text_hint": "این دستوری است که به هوش مصنوعی ارسال می‌شود. از دستورالعمل‌های واضح و دقیق استفاده کنید.",
          "active_status": "فعال",
          "active_status_hint": "فقط پرامپت‌های فعال برای انتخاب در دسترس هستند",
          "save": "ذخیره",
          "saving": "در حال ذخیره...",
          "cancel": "انصراف",
          "prompt_created": "پرامپت با موفقیت ایجاد شد",
          "prompt_updated": "پرامپت با موفقیت به‌روزرسانی شد",
          "prompt_deleted": "پرامپت با موفقیت حذف شد",
          "prompt_activated": "پرامپت فعال شد",
          "prompt_deactivated": "پرامپت غیرفعال شد",
          "save_error": "ذخیره پرامپت ناموفق بود",
          "delete_error": "حذف پرامپت ناموفق بود",
          "toggle_error": "تغییر وضعیت پرامپت ناموفق بود",
          "delete_confirm_title": "حذف پرامپت؟",
          "delete_confirm_description": "آیا مطمئن هستید که می‌خواهید \"{title}\" را حذف کنید؟ این عمل قابل بازگشت نیست.",
          "selected_prompts": "پرامپت‌های انتخاب‌شده",
          "available_prompts": "پرامپت‌های موجود",
          "select_prompts_hint": "یک یا چند پرامپت برای استفاده انتخاب کنید",
          "select_up_to": "حداکثر {count} پرامپت انتخاب کنید"
        }
      }
      ```

checkpoint_tests:
  - id: T01
    description: "All prompt service files exist"
    type: "files_exist"
    files:
      - "src/lib/prompts/prompt-service.ts"
      - "src/lib/prompts/default-prompts.ts"
      - "src/lib/prompts/index.ts"

  - id: T02
    description: "All prompt API route files exist"
    type: "files_exist"
    files:
      - "src/app/api/prompts/route.ts"
      - "src/app/api/prompts/[id]/route.ts"

  - id: T03
    description: "usePrompts hook exists"
    type: "files_exist"
    files:
      - "src/hooks/usePrompts.ts"

  - id: T04
    description: "All prompt component files exist"
    type: "files_exist"
    files:
      - "src/components/prompts/PromptList.tsx"
      - "src/components/prompts/PromptEditor.tsx"
      - "src/components/prompts/PromptSelector.tsx"
      - "src/components/prompts/PromptCategoryFilter.tsx"
      - "src/components/prompts/PromptCard.tsx"
      - "src/components/prompts/PromptPreview.tsx"

  - id: T05
    description: "Prompts page exists"
    type: "files_exist"
    files:
      - "src/app/[locale]/prompts/page.tsx"
      - "src/app/[locale]/prompts/loading.tsx"

  - id: T06
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T07
    description: "Prompt service has all CRUD methods"
    type: "grep"
    file: "src/lib/prompts/prompt-service.ts"
    patterns:
      - "getAllPrompts"
      - "getPromptById"
      - "createPrompt"
      - "updatePrompt"
      - "deletePrompt"
      - "togglePromptActive"
      - "seedDefaultPrompts"

  - id: T08
    description: "API route has GET, POST methods"
    type: "grep"
    file: "src/app/api/prompts/route.ts"
    patterns:
      - "export async function GET"
      - "export async function POST"

  - id: T09
    description: "Single prompt API has GET, PUT, DELETE, PATCH"
    type: "grep"
    file: "src/app/api/prompts/[id]/route.ts"
    patterns:
      - "export async function GET"
      - "export async function PUT"
      - "export async function DELETE"
      - "export async function PATCH"

  - id: T10
    description: "usePrompts exports all functions"
    type: "grep"
    file: "src/hooks/usePrompts.ts"
    patterns:
      - "export function usePrompts"
      - "fetchPrompts"
      - "createPrompt"
      - "updatePrompt"
      - "deletePrompt"
      - "togglePromptActive"

  - id: T11
    description: "PromptEditor has bilingual support"
    type: "grep"
    file: "src/components/prompts/PromptEditor.tsx"
    patterns:
      - "title_en"
      - "title_fa"
      - "TabsList"
      - "English"
      - "فارسی"

  - id: T12
    description: "PromptSelector uses usePrompts hook"
    type: "grep"
    file: "src/components/prompts/PromptSelector.tsx"
    patterns:
      - "usePrompts"
      - "selectedIds"
      - "onSelectionChange"

  - id: T13
    description: "Default prompts include seed data"
    type: "grep"
    file: "src/lib/prompts/default-prompts.ts"
    patterns:
      - "DEFAULT_PROMPTS"
      - "Professional CV Tailoring"
      - "Cover Letter Generator"
      - "PROMPT_CATEGORIES"

  - id: T14
    description: "Prompts page uses AuthGuard"
    type: "grep"
    file: "src/app/[locale]/prompts/page.tsx"
    patterns:
      - "AuthGuard"
      - "<AuthGuard>"

  - id: T15
    description: "English translations have all prompt keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "prompts"
      - "create_prompt"
      - "edit_prompt"
      - "prompt_created"
      - "selected_prompts"

  - id: T16
    description: "Farsi translations have all prompt keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "prompts"
      - "create_prompt"
      - "مدیریت پرامپت"

max_retries: 3
خلاصه بلوک B17
جزء	تعداد فایل	توضیح
Service Layer	3	prompt-service, default-prompts, index
API Routes	2	CRUD برای لیست و تک‌پرامپت
React Hook	1	usePrompts با تمام عملیات
UI Components	6	List, Editor, Selector, Card, Preview, CategoryFilter
Pages	2	page.tsx + loading.tsx
Translations	2	en.json + fa.json updates
مجموع	16 فایل	
ویژگی‌های کلیدی
✅ CRUD کامل بدون کدنویسی — ادمین می‌تواند از UI پرامپت‌ها را مدیریت کند

✅ دوزبانه — عنوان و توضیحات به فارسی و انگلیسی

✅ دسته‌بندی — فیلتر بر اساس نوع (CV, Cover Letter, Email)

✅ جستجو — جستجوی متنی در عناوین و توضیحات

✅ پرامپت‌های پیش‌فرض — seed data با ۷ پرامپت آماده

✅ فعال/غیرفعال — کنترل دسترسی کاربران به پرامپت‌ها

✅ PromptSelector — کامپوننت آماده برای استفاده در فرایند اصلی اپلیکیشن

آیا می‌خواهی بلوک B18 (فرایند اصلی اپلیکیشن — New Application) را هم بنویسم؟





b17 رو بنویس

claude-opus-4-5-20251101-thinking-32k

Thought for 1 second

ادامه بلوک‌های B14 تا B16
B14.yaml — ادامه CVFieldDisplay.tsx و سایر فایل‌ها
YAML

# ادامه instructions برای B14

  7. Create CVFieldDisplay.tsx (ادامه):
     ```typescript
     // ادامه CVFieldDisplay.tsx از قسمت Skills
     
           {/* Skills */}
           <Card>
             <CardHeader className="flex flex-row items-center justify-between">
               <CardTitle className="flex items-center gap-2 text-lg">
                 <Code className="h-5 w-5" />
                 {t('skills')}
               </CardTitle>
               <FieldStatusBadge isComplete={isFieldComplete('skills')} />
             </CardHeader>
             <CardContent>
               <SkillsEditor
                 skills={cv.skills || []}
                 onChange={handleSkillsChange}
               />
             </CardContent>
           </Card>
           
           {/* Languages */}
           {(cv.languages || []).length > 0 && (
             <Card>
               <CardHeader>
                 <CardTitle className="flex items-center gap-2 text-lg">
                   <Languages className="h-5 w-5" />
                   {t('languages')}
                 </CardTitle>
               </CardHeader>
               <CardContent>
                 <div className="flex flex-wrap gap-2">
                   {cv.languages!.map((lang, index) => (
                     <Badge key={index} variant="outline">
                       {lang.language} — {lang.proficiency}
                     </Badge>
                   ))}
                 </div>
               </CardContent>
             </Card>
           )}
           
           {/* Certifications */}
           {(cv.certifications || []).length > 0 && (
             <Card>
               <CardHeader>
                 <CardTitle className="flex items-center gap-2 text-lg">
                   <Award className="h-5 w-5" />
                   {t('certifications')}
                 </CardTitle>
               </CardHeader>
               <CardContent>
                 <div className="space-y-3">
                   {cv.certifications!.map((cert) => (
                     <div key={cert.id} className="p-3 bg-muted/50 rounded-lg">
                       <h4 className="font-medium">{cert.name}</h4>
                       <p className="text-sm text-muted-foreground">
                         {cert.issuer} • {cert.date_obtained}
                       </p>
                     </div>
                   ))}
                 </div>
               </CardContent>
             </Card>
           )}
           
           {/* Projects */}
           {(cv.projects || []).length > 0 && (
             <Card>
               <CardHeader>
                 <CardTitle className="flex items-center gap-2 text-lg">
                   <FolderOpen className="h-5 w-5" />
                   {t('projects')}
                 </CardTitle>
               </CardHeader>
               <CardContent>
                 <div className="space-y-3">
                   {cv.projects!.map((project) => (
                     <div key={project.id} className="p-3 bg-muted/50 rounded-lg">
                       <h4 className="font-medium">{project.name}</h4>
                       <p className="text-sm mt-1">{project.description}</p>
                       {project.url && (
                         <a 
                           href={project.url} 
                           target="_blank" 
                           rel="noopener noreferrer"
                           className="text-xs text-primary hover:underline mt-1 inline-block"
                         >
                           {project.url}
                         </a>
                       )}
                     </div>
                   ))}
                 </div>
               </CardContent>
             </Card>
           )}
           
           {/* Edit Dialogs */}
           <PersonalInfoForm
             info={cv.personal_info || {}}
             open={editingPersonalInfo}
             onClose={() => setEditingPersonalInfo(false)}
             onSave={handlePersonalInfoSave}
           />
           
           <WorkExperienceForm
             experience={editingExperience || undefined}
             open={editingExperience !== null || addingExperience}
             onClose={() => {
               setEditingExperience(null);
               setAddingExperience(false);
             }}
             onSave={handleExperienceSave}
           />
           
           <EducationForm
             education={editingEducation || undefined}
             open={editingEducation !== null || addingEducation}
             onClose={() => {
               setEditingEducation(null);
               setAddingEducation(false);
             }}
             onSave={handleEducationSave}
           />
         </div>
       );
     }
     ```
  
  8. Create CVCompletionForm.tsx:
     ```typescript
     // ============================================
     // [F043] src/components/cv/CVCompletionForm.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { CVFieldStatus } from '@/lib/types';
     import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
     import { Button } from '@/components/ui/button';
     import { AlertTriangle, ArrowRight } from 'lucide-react';
     
     interface CVCompletionFormProps {
       incompleteFields: CVFieldStatus[];
       onFieldClick: (fieldName: string) => void;
       className?: string;
     }
     
     export function CVCompletionForm({
       incompleteFields,
       onFieldClick,
       className
     }: CVCompletionFormProps) {
       const t = useTranslations('cv');
       
       if (incompleteFields.length === 0) {
         return null;
       }
       
       const getFieldLabel = (fieldName: string): string => {
         const labels: Record<string, string> = {
           'personal_info.full_name': t('full_name'),
           'personal_info.email': t('email'),
           'personal_info.phone': t('phone'),
           'personal_info.summary': t('summary'),
           'work_experience': t('work_experience'),
           'education': t('education'),
           'skills': t('skills'),
         };
         return labels[fieldName] || fieldName;
       };
       
       const getFieldSection = (fieldName: string): string => {
         if (fieldName.startsWith('personal_info')) return 'personal';
         return fieldName;
       };
       
       return (
         <Card className={className}>
           <CardHeader>
             <CardTitle className="flex items-center gap-2 text-yellow-600">
               <AlertTriangle className="h-5 w-5" />
               {t('incomplete_fields')}
             </CardTitle>
             <CardDescription>
               {t('complete_fields_hint')}
             </CardDescription>
           </CardHeader>
           <CardContent>
             <ul className="space-y-2">
               {incompleteFields.map((field) => (
                 <li key={field.field_name}>
                   <Button
                     variant="ghost"
                     className="w-full justify-between text-left h-auto py-3"
                     onClick={() => onFieldClick(getFieldSection(field.field_name))}
                   >
                     <span className="flex items-center gap-2">
                       <span className="w-2 h-2 rounded-full bg-yellow-500" />
                       {getFieldLabel(field.field_name)}
                     </span>
                     <ArrowRight className="h-4 w-4" />
                   </Button>
                 </li>
               ))}
             </ul>
           </CardContent>
         </Card>
       );
     }
     ```
  
  9. Create CVPreview.tsx:
     ```typescript
     // ============================================
     // [F044] src/components/cv/CVPreview.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { ComprehensiveCV } from '@/lib/types';
     import { Card, CardContent } from '@/components/ui/card';
     import { Separator } from '@/components/ui/separator';
     import { cn, isRTL } from '@/lib/utils';
     import { 
       Mail, Phone, MapPin, Linkedin, Globe, 
       Briefcase, GraduationCap, Award, Code, Languages as LanguagesIcon
     } from 'lucide-react';
     
     interface CVPreviewProps {
       cv: Partial<ComprehensiveCV>;
       locale: 'en' | 'fa';
       className?: string;
     }
     
     export function CVPreview({ cv, locale, className }: CVPreviewProps) {
       const t = useTranslations('cv');
       const rtl = isRTL(locale);
       
       const formatDate = (date: string | null | undefined): string => {
         if (!date) return '';
         const [year, month] = date.split('-');
         return locale === 'fa' 
           ? `${year}/${month}`
           : new Date(date).toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
       };
       
       return (
         <Card className={cn('overflow-hidden', className)}>
           <CardContent className={cn(
             'p-8 max-w-3xl mx-auto',
             rtl && 'text-right'
           )} dir={rtl ? 'rtl' : 'ltr'}>
             
             {/* Header / Personal Info */}
             <header className="mb-8">
               <h1 className="text-3xl font-bold mb-2">
                 {cv.personal_info?.full_name || t('your_name')}
               </h1>
               
               {cv.personal_info?.summary && (
                 <p className="text-muted-foreground mt-3 leading-relaxed">
                   {cv.personal_info.summary}
                 </p>
               )}
               
               <div className={cn(
                 'flex flex-wrap gap-4 mt-4 text-sm text-muted-foreground',
                 rtl && 'flex-row-reverse'
               )}>
                 {cv.personal_info?.email && (
                   <span className="flex items-center gap-1">
                     <Mail className="h-4 w-4" />
                     {cv.personal_info.email}
                   </span>
                 )}
                 {cv.personal_info?.phone && (
                   <span className="flex items-center gap-1">
                     <Phone className="h-4 w-4" />
                     {cv.personal_info.phone}
                   </span>
                 )}
                 {cv.personal_info?.location && (
                   <span className="flex items-center gap-1">
                     <MapPin className="h-4 w-4" />
                     {cv.personal_info.location}
                   </span>
                 )}
                 {cv.personal_info?.linkedin_url && (
                   <span className="flex items-center gap-1">
                     <Linkedin className="h-4 w-4" />
                     LinkedIn
                   </span>
                 )}
                 {cv.personal_info?.website_url && (
                   <span className="flex items-center gap-1">
                     <Globe className="h-4 w-4" />
                     Website
                   </span>
                 )}
               </div>
             </header>
             
             <Separator className="my-6" />
             
             {/* Work Experience */}
             {(cv.work_experience || []).length > 0 && (
               <section className="mb-8">
                 <h2 className="text-xl font-semibold flex items-center gap-2 mb-4">
                   <Briefcase className="h-5 w-5" />
                   {t('work_experience')}
                 </h2>
                 <div className="space-y-6">
                   {cv.work_experience!.map((exp) => (
                     <div key={exp.id}>
                       <div className="flex justify-between items-start flex-wrap gap-2">
                         <div>
                           <h3 className="font-semibold">{exp.job_title}</h3>
                           <p className="text-muted-foreground">{exp.company}</p>
                         </div>
                         <div className="text-sm text-muted-foreground">
                           {formatDate(exp.start_date)} — {exp.is_current ? t('present') : formatDate(exp.end_date)}
                         </div>
                       </div>
                       {exp.description && (
                         <p className="mt-2 text-sm">{exp.description}</p>
                       )}
                       {exp.achievements && exp.achievements.length > 0 && (
                         <ul className="mt-2 space-y-1">
                           {exp.achievements.map((achievement, i) => (
                             <li key={i} className="text-sm flex items-start gap-2">
                               <span className="text-primary mt-1.5">•</span>
                               {achievement}
                             </li>
                           ))}
                         </ul>
                       )}
                     </div>
                   ))}
                 </div>
               </section>
             )}
             
             {/* Education */}
             {(cv.education || []).length > 0 && (
               <section className="mb-8">
                 <h2 className="text-xl font-semibold flex items-center gap-2 mb-4">
                   <GraduationCap className="h-5 w-5" />
                   {t('education')}
                 </h2>
                 <div className="space-y-4">
                   {cv.education!.map((edu) => (
                     <div key={edu.id}>
                       <div className="flex justify-between items-start flex-wrap gap-2">
                         <div>
                           <h3 className="font-semibold">{edu.degree}</h3>
                           <p className="text-muted-foreground">{edu.institution}</p>
                         </div>
                         <div className="text-sm text-muted-foreground">
                           {formatDate(edu.start_date)} — {formatDate(edu.end_date)}
                           {edu.gpa && ` • GPA: ${edu.gpa}`}
                         </div>
                       </div>
                       {edu.description && (
                         <p className="mt-1 text-sm">{edu.description}</p>
                       )}
                     </div>
                   ))}
                 </div>
               </section>
             )}
             
             {/* Skills */}
             {(cv.skills || []).length > 0 && (
               <section className="mb-8">
                 <h2 className="text-xl font-semibold flex items-center gap-2 mb-4">
                   <Code className="h-5 w-5" />
                   {t('skills')}
                 </h2>
                 <div className="flex flex-wrap gap-2">
                   {cv.skills!.map((skill, i) => (
                     <span 
                       key={i}
                       className="px-3 py-1 bg-muted rounded-full text-sm"
                     >
                       {skill}
                     </span>
                   ))}
                 </div>
               </section>
             )}
             
             {/* Languages */}
             {(cv.languages || []).length > 0 && (
               <section className="mb-8">
                 <h2 className="text-xl font-semibold flex items-center gap-2 mb-4">
                   <LanguagesIcon className="h-5 w-5" />
                   {t('languages')}
                 </h2>
                 <div className="flex flex-wrap gap-4">
                   {cv.languages!.map((lang, i) => (
                     <span key={i} className="text-sm">
                       <span className="font-medium">{lang.language}</span>
                       <span className="text-muted-foreground"> — {lang.proficiency}</span>
                     </span>
                   ))}
                 </div>
               </section>
             )}
             
             {/* Certifications */}
             {(cv.certifications || []).length > 0 && (
               <section className="mb-8">
                 <h2 className="text-xl font-semibold flex items-center gap-2 mb-4">
                   <Award className="h-5 w-5" />
                   {t('certifications')}
                 </h2>
                 <div className="space-y-2">
                   {cv.certifications!.map((cert) => (
                     <div key={cert.id} className="flex justify-between items-center">
                       <div>
                         <span className="font-medium">{cert.name}</span>
                         <span className="text-muted-foreground"> — {cert.issuer}</span>
                       </div>
                       <span className="text-sm text-muted-foreground">
                         {formatDate(cert.date_obtained)}
                       </span>
                     </div>
                   ))}
                 </div>
               </section>
             )}
             
           </CardContent>
         </Card>
       );
     }
     ```
  
  10. Add translations to en.json under "cv" key (append to existing):
      ```json
      {
        "cv": {
          "field_complete": "Complete",
          "field_incomplete": "Incomplete",
          "extraction_summary": "Extraction Summary",
          "fields_complete": "{count} of {total} fields complete",
          "ai_confidence": "AI Confidence",
          "confidence_high": "High",
          "confidence_medium": "Medium",
          "confidence_low": "Low",
          "personal_info": "Personal Information",
          "work_experience": "Work Experience",
          "education": "Education",
          "skills": "Skills",
          "certifications": "Certifications",
          "languages": "Languages",
          "projects": "Projects",
          "full_name": "Full Name",
          "email": "Email",
          "phone": "Phone",
          "location": "Location",
          "linkedin": "LinkedIn",
          "website": "Website",
          "summary": "Professional Summary",
          "edit_personal_info": "Edit Personal Information",
          "full_name_placeholder": "John Doe",
          "location_placeholder": "City, Country",
          "summary_placeholder": "Brief professional summary...",
          "job_title": "Job Title",
          "company": "Company",
          "start_date": "Start Date",
          "end_date": "End Date",
          "current_position": "I currently work here",
          "present": "Present",
          "description": "Description",
          "description_placeholder": "Describe your role and responsibilities...",
          "achievements": "Key Achievements",
          "add_achievement_placeholder": "Add an achievement...",
          "add_experience": "Add Experience",
          "edit_experience": "Edit Experience",
          "no_experience_added": "No work experience added yet",
          "degree": "Degree",
          "institution": "Institution",
          "gpa": "GPA",
          "degree_placeholder": "Bachelor of Science in...",
          "institution_placeholder": "University name",
          "add_education": "Add Education",
          "edit_education": "Edit Education",
          "no_education_added": "No education added yet",
          "add_skill_placeholder": "Type a skill and press Enter",
          "no_skills_added": "No skills added yet",
          "incomplete_fields": "Incomplete Fields",
          "complete_fields_hint": "Complete these fields to improve your CV",
          "your_name": "Your Name",
          "save": "Save",
          "cancel": "Cancel"
        }
      }
      ```
  
  11. Add same translations to fa.json:
      ```json
      {
        "cv": {
          "field_complete": "کامل",
          "field_incomplete": "ناقص",
          "extraction_summary": "خلاصه استخراج",
          "fields_complete": "{count} از {total} فیلد کامل",
          "ai_confidence": "اطمینان هوش مصنوعی",
          "confidence_high": "بالا",
          "confidence_medium": "متوسط",
          "confidence_low": "پایین",
          "personal_info": "اطلاعات شخصی",
          "work_experience": "سوابق کاری",
          "education": "تحصیلات",
          "skills": "مهارت‌ها",
          "certifications": "گواهینامه‌ها",
          "languages": "زبان‌ها",
          "projects": "پروژه‌ها",
          "full_name": "نام کامل",
          "email": "ایمیل",
          "phone": "تلفن",
          "location": "موقعیت",
          "linkedin": "لینکدین",
          "website": "وب‌سایت",
          "summary": "خلاصه حرفه‌ای",
          "edit_personal_info": "ویرایش اطلاعات شخصی",
          "full_name_placeholder": "نام و نام خانوادگی",
          "location_placeholder": "شهر، کشور",
          "summary_placeholder": "خلاصه‌ای از تجربیات حرفه‌ای...",
          "job_title": "عنوان شغلی",
          "company": "شرکت",
          "start_date": "تاریخ شروع",
          "end_date": "تاریخ پایان",
          "current_position": "در حال حاضر اینجا کار می‌کنم",
          "present": "تاکنون",
          "description": "توضیحات",
          "description_placeholder": "نقش و مسئولیت‌های خود را شرح دهید...",
          "achievements": "دستاوردهای کلیدی",
          "add_achievement_placeholder": "یک دستاورد اضافه کنید...",
          "add_experience": "افزودن تجربه",
          "edit_experience": "ویرایش تجربه",
          "no_experience_added": "هنوز سابقه کاری اضافه نشده",
          "degree": "مدرک",
          "institution": "موسسه آموزشی",
          "gpa": "معدل",
          "degree_placeholder": "کارشناسی در رشته...",
          "institution_placeholder": "نام دانشگاه",
          "add_education": "افزودن تحصیلات",
          "edit_education": "ویرایش تحصیلات",
          "no_education_added": "هنوز تحصیلاتی اضافه نشده",
          "add_skill_placeholder": "مهارت را تایپ کنید و Enter بزنید",
          "no_skills_added": "هنوز مهارتی اضافه نشده",
          "incomplete_fields": "فیلدهای ناقص",
          "complete_fields_hint": "این فیلدها را تکمیل کنید تا سی‌وی بهتری داشته باشید",
          "your_name": "نام شما",
          "save": "ذخیره",
          "cancel": "انصراف"
        }
      }
      ```

checkpoint_tests:
  - id: T01
    description: "All CV field component files exist"
    type: "files_exist"
    files:
      - "src/components/cv/CVFieldDisplay.tsx"
      - "src/components/cv/CVCompletionForm.tsx"
      - "src/components/cv/CVPreview.tsx"
      - "src/components/cv/FieldStatusBadge.tsx"
      - "src/components/cv/WorkExperienceForm.tsx"
      - "src/components/cv/EducationForm.tsx"
      - "src/components/cv/SkillsEditor.tsx"
      - "src/components/cv/PersonalInfoForm.tsx"
      - "src/components/cv/ConfidenceIndicator.tsx"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "CVFieldDisplay shows all CV sections"
    type: "grep"
    file: "src/components/cv/CVFieldDisplay.tsx"
    patterns:
      - "personal_info"
      - "work_experience"
      - "education"
      - "skills"
      - "FieldStatusBadge"
      - "ConfidenceIndicator"

  - id: T04
    description: "CVPreview supports RTL"
    type: "grep"
    file: "src/components/cv/CVPreview.tsx"
    patterns:
      - "isRTL"
      - "dir="
      - "rtl"

  - id: T05
    description: "SkillsEditor uses tag-based input"
    type: "grep"
    file: "src/components/cv/SkillsEditor.tsx"
    patterns:
      - "Badge"
      - "addSkill"
      - "removeSkill"

  - id: T06
    description: "Forms use Dialog component"
    type: "grep"
    file: "src/components/cv/PersonalInfoForm.tsx"
    patterns:
      - "Dialog"
      - "DialogContent"
      - "onSave"

  - id: T07
    description: "Uses i18n for translations"
    type: "grep"
    file: "src/components/cv/CVFieldDisplay.tsx"
    patterns:
      - "useTranslations"

  - id: T08
    description: "English translations have all CV field keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "field_complete"
      - "extraction_summary"
      - "add_experience"
      - "confidence_high"

  - id: T09
    description: "Farsi translations have all CV field keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "field_complete"
      - "extraction_summary"
      - "confidence_high"

max_retries: 3
B15.yaml — API Route سی‌وی + ذخیره در Supabase
YAML

# blocks/B15.yaml

id: B15
name: "CV API Routes and Database Integration"
phase: 1
phase_name: "CV Management"

goal: |
  Create API routes for CV CRUD operations and a React hook for CV state management.
  CVs are stored in Supabase. Each user has one comprehensive CV.
  This integrates with the AI extraction from B12.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13, B14]

files_to_create:
  - id: F022
    path: "src/app/api/cv/route.ts"
    description: "API route for CV CRUD (GET, POST, PUT)"

  - id: F082
    path: "src/hooks/useCV.ts"
    description: "React hook for CV operations"

  - id: F116
    path: "src/lib/cv/cv-service.ts"
    description: "CV service layer for database operations"

files_to_modify:
  - id: F109
    path: "src/lib/cv/index.ts"
    description: "Export CV service"

files_available:
  - id: F063
    path: "src/lib/supabase/client.ts"
    from_block: B06
  - id: F064
    path: "src/lib/supabase/server.ts"
    from_block: B06
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F090
    path: "src/context/AuthContext.tsx"
    from_block: B07
  - id: F074
    path: "src/lib/cv/cv-extractor.ts"
    from_block: B12
  - id: F108
    path: "src/lib/cv/cv-validator.ts"
    from_block: B12

commands: []

instructions: |
  1. Create cv-service.ts:
     ```typescript
     // ============================================
     // [F116] src/lib/cv/cv-service.ts
     // ============================================
     
     import { SupabaseClient } from '@supabase/supabase-js';
     import { ComprehensiveCV } from '@/lib/types';
     
     export class CVService {
       constructor(private supabase: SupabaseClient) {}
       
       async getCV(userId: string): Promise<ComprehensiveCV | null> {
         const { data, error } = await this.supabase
           .from('comprehensive_cvs')
           .select('*')
           .eq('user_id', userId)
           .single();
         
         if (error) {
           if (error.code === 'PGRST116') {
             // No rows returned - CV doesn't exist
             return null;
           }
           throw error;
         }
         
         return this.mapDatabaseToCV(data);
       }
       
       async createCV(userId: string, cv: Partial<ComprehensiveCV>): Promise<ComprehensiveCV> {
         const dbData = this.mapCVToDatabase(userId, cv);
         
         const { data, error } = await this.supabase
           .from('comprehensive_cvs')
           .insert(dbData)
           .select()
           .single();
         
         if (error) throw error;
         return this.mapDatabaseToCV(data);
       }
       
       async updateCV(userId: string, cv: Partial<ComprehensiveCV>): Promise<ComprehensiveCV> {
         const dbData = this.mapCVToDatabase(userId, cv);
         
         const { data, error } = await this.supabase
           .from('comprehensive_cvs')
           .update(dbData)
           .eq('user_id', userId)
           .select()
           .single();
         
         if (error) throw error;
         return this.mapDatabaseToCV(data);
       }
       
       async upsertCV(userId: string, cv: Partial<ComprehensiveCV>): Promise<ComprehensiveCV> {
         const dbData = this.mapCVToDatabase(userId, cv);
         
         const { data, error } = await this.supabase
           .from('comprehensive_cvs')
           .upsert(dbData, { onConflict: 'user_id' })
           .select()
           .single();
         
         if (error) throw error;
         return this.mapDatabaseToCV(data);
       }
       
       async deleteCV(userId: string): Promise<void> {
         const { error } = await this.supabase
           .from('comprehensive_cvs')
           .delete()
           .eq('user_id', userId);
         
         if (error) throw error;
       }
       
       async updateCVField(
         userId: string, 
         fieldPath: string, 
         value: any
       ): Promise<ComprehensiveCV> {
         // Get current CV
         const currentCV = await this.getCV(userId);
         if (!currentCV) {
           throw new Error('CV not found');
         }
         
         // Update the specific field
         const updatedCV = this.setNestedValue(currentCV, fieldPath, value);
         
         // Save back to database
         return this.updateCV(userId, updatedCV);
       }
       
       // Helper: Map database row to ComprehensiveCV type
       private mapDatabaseToCV(row: any): ComprehensiveCV {
         return {
           id: row.id,
           user_id: row.user_id,
           personal_info: row.personal_info || {},
           work_experience: row.work_experience || [],
           education: row.education || [],
           skills: row.skills || [],
           certifications: row.certifications || [],
           languages: row.languages || [],
           projects: row.projects || [],
           additional_sections: row.additional_sections || [],
           raw_text: row.raw_text || '',
           created_at: row.created_at,
           updated_at: row.updated_at,
         };
       }
       
       // Helper: Map ComprehensiveCV to database format
       private mapCVToDatabase(userId: string, cv: Partial<ComprehensiveCV>): any {
         return {
           user_id: userId,
           personal_info: cv.personal_info || {},
           work_experience: cv.work_experience || [],
           education: cv.education || [],
           skills: cv.skills || [],
           certifications: cv.certifications || [],
           languages: cv.languages || [],
           projects: cv.projects || [],
           additional_sections: cv.additional_sections || [],
           raw_text: cv.raw_text || '',
         };
       }
       
       // Helper: Set nested object value by path string
       private setNestedValue(obj: any, path: string, value: any): any {
         const clone = JSON.parse(JSON.stringify(obj));
         const keys = path.split('.');
         let current = clone;
         
         for (let i = 0; i < keys.length - 1; i++) {
           if (!(keys[i] in current)) {
             current[keys[i]] = {};
           }
           current = current[keys[i]];
         }
         
         current[keys[keys.length - 1]] = value;
         return clone;
       }
     }
     
     // Factory function
     export function createCVService(supabase: SupabaseClient): CVService {
       return new CVService(supabase);
     }
     ```
  
  2. Create src/app/api/cv/route.ts:
     ```typescript
     // ============================================
     // [F022] src/app/api/cv/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { createCVService } from '@/lib/cv/cv-service';
     import { ComprehensiveCV } from '@/lib/types';
     
     // GET - Retrieve user's CV
     export async function GET(request: NextRequest) {
       try {
         const userId = request.headers.get('x-user-id');
         
         if (!userId) {
           return NextResponse.json(
             { error: 'Unauthorized' },
             { status: 401 }
           );
         }
         
         const supabase = createServerSupabaseClient();
         const cvService = createCVService(supabase);
         
         const cv = await cvService.getCV(userId);
         
         return NextResponse.json({ cv });
         
       } catch (error: any) {
         console.error('GET /api/cv error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to fetch CV' },
           { status: 500 }
         );
       }
     }
     
     // POST - Create or replace CV
     export async function POST(request: NextRequest) {
       try {
         const userId = request.headers.get('x-user-id');
         
         if (!userId) {
           return NextResponse.json(
             { error: 'Unauthorized' },
             { status: 401 }
           );
         }
         
         const body = await request.json();
         const cvData: Partial<ComprehensiveCV> = body.cv;
         
         if (!cvData) {
           return NextResponse.json(
             { error: 'CV data is required' },
             { status: 400 }
           );
         }
         
         const supabase = createServerSupabaseClient();
         const cvService = createCVService(supabase);
         
         const cv = await cvService.upsertCV(userId, cvData);
         
         return NextResponse.json({ cv, success: true });
         
       } catch (error: any) {
         console.error('POST /api/cv error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to save CV' },
           { status: 500 }
         );
       }
     }
     
     // PUT - Update specific fields of CV
     export async function PUT(request: NextRequest) {
       try {
         const userId = request.headers.get('x-user-id');
         
         if (!userId) {
           return NextResponse.json(
             { error: 'Unauthorized' },
             { status: 401 }
           );
         }
         
         const body = await request.json();
         const { fieldPath, value, updates } = body;
         
         const supabase = createServerSupabaseClient();
         const cvService = createCVService(supabase);
         
         let cv;
         
         if (fieldPath && value !== undefined) {
           // Update single field
           cv = await cvService.updateCVField(userId, fieldPath, value);
         } else if (updates) {
           // Update multiple fields
           cv = await cvService.updateCV(userId, updates);
         } else {
           return NextResponse.json(
             { error: 'Either fieldPath/value or updates is required' },
             { status: 400 }
           );
         }
         
         return NextResponse.json({ cv, success: true });
         
       } catch (error: any) {
         console.error('PUT /api/cv error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to update CV' },
           { status: 500 }
         );
       }
     }
     
     // DELETE - Delete user's CV
     export async function DELETE(request: NextRequest) {
       try {
         const userId = request.headers.get('x-user-id');
         
         if (!userId) {
           return NextResponse.json(
             { error: 'Unauthorized' },
             { status: 401 }
           );
         }
         
         const supabase = createServerSupabaseClient();
         const cvService = createCVService(supabase);
         
         await cvService.deleteCV(userId);
         
         return NextResponse.json({ success: true });
         
       } catch (error: any) {
         console.error('DELETE /api/cv error:', error);
         return NextResponse.json(
           { error: error.message || 'Failed to delete CV' },
           { status: 500 }
         );
       }
     }
     ```
  
  3. Create hooks/useCV.ts:
     ```typescript
     // ============================================
     // [F082] src/hooks/useCV.ts
     // ============================================
     
     'use client';
     
     import { useState, useEffect, useCallback } from 'react';
     import { useAuth } from '@/context/AuthContext';
     import { 
       ComprehensiveCV, 
       CVFieldStatus, 
       CVExtractionResult,
       AIProviderName 
     } from '@/lib/types';
     import { validateExtractedCV, getCompletionPercentage } from '@/lib/cv/cv-validator';
     
     interface UseCVReturn {
       cv: ComprehensiveCV | null;
       loading: boolean;
       saving: boolean;
       error: string | null;
       fieldStatuses: CVFieldStatus[];
       completionPercentage: number;
       
       // Actions
       fetchCV: () => Promise<void>;
       saveCV: (cvData: Partial<ComprehensiveCV>) => Promise<void>;
       updateCV: (updates: Partial<ComprehensiveCV>) => Promise<void>;
       updateField: (fieldPath: string, value: any) => Promise<void>;
       deleteCV: () => Promise<void>;
       
       // AI Extraction
       extractFromFile: (
         file: File,
         provider: AIProviderName,
         model: string
       ) => Promise<CVExtractionResult>;
       
       extractFromText: (
         text: string,
         provider: AIProviderName,
         model: string
       ) => Promise<CVExtractionResult>;
       
       applyExtraction: (result: CVExtractionResult) => Promise<void>;
     }
     
     export function useCV(): UseCVReturn {
       const { user } = useAuth();
       
       const [cv, setCV] = useState<ComprehensiveCV | null>(null);
       const [loading, setLoading] = useState(true);
       const [saving, setSaving] = useState(false);
       const [error, setError] = useState<string | null>(null);
       
       // Derived state
       const fieldStatuses = cv ? validateExtractedCV(cv) : [];
       const completionPercentage = getCompletionPercentage(fieldStatuses);
       
       // Fetch CV on mount
       useEffect(() => {
         if (user) {
           fetchCV();
         } else {
           setCV(null);
           setLoading(false);
         }
       }, [user?.id]);
       
       const fetchCV = useCallback(async () => {
         if (!user) return;
         
         setLoading(true);
         setError(null);
         
         try {
           const res = await fetch('/api/cv', {
             headers: { 'x-user-id': user.id }
           });
           
           const data = await res.json();
           
           if (data.error) {
             throw new Error(data.error);
           }
           
           setCV(data.cv);
           
         } catch (err: any) {
           setError(err.message);
           setCV(null);
         } finally {
           setLoading(false);
         }
       }, [user]);
       
       const saveCV = useCallback(async (cvData: Partial<ComprehensiveCV>) => {
         if (!user) return;
         
         setSaving(true);
         setError(null);
         
         try {
           const res = await fetch('/api/cv', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'x-user-id': user.id
             },
             body: JSON.stringify({ cv: cvData })
           });
           
           const data = await res.json();
           
           if (data.error) {
             throw new Error(data.error);
           }
           
           setCV(data.cv);
           
         } catch (err: any) {
           setError(err.message);
           throw err;
         } finally {
           setSaving(false);
         }
       }, [user]);
       
       const updateCV = useCallback(async (updates: Partial<ComprehensiveCV>) => {
         if (!user) return;
         
         setSaving(true);
         setError(null);
         
         try {
           const res = await fetch('/api/cv', {
             method: 'PUT',
             headers: {
               'Content-Type': 'application/json',
               'x-user-id': user.id
             },
             body: JSON.stringify({ updates })
           });
           
           const data = await res.json();
           
           if (data.error) {
             throw new Error(data.error);
           }
           
           setCV(data.cv);
           
         } catch (err: any) {
           setError(err.message);
           throw err;
         } finally {
           setSaving(false);
         }
       }, [user]);
       
       const updateField = useCallback(async (fieldPath: string, value: any) => {
         if (!user) return;
         
         setSaving(true);
         setError(null);
         
         try {
           const res = await fetch('/api/cv', {
             method: 'PUT',
             headers: {
               'Content-Type': 'application/json',
               'x-user-id': user.id
             },
             body: JSON.stringify({ fieldPath, value })
           });
           
           const data = await res.json();
           
           if (data.error) {
             throw new Error(data.error);
           }
           
           setCV(data.cv);
           
         } catch (err: any) {
           setError(err.message);
           throw err;
         } finally {
           setSaving(false);
         }
       }, [user]);
       
       const deleteCV = useCallback(async () => {
         if (!user) return;
         
         setSaving(true);
         setError(null);
         
         try {
           const res = await fetch('/api/cv', {
             method: 'DELETE',
             headers: { 'x-user-id': user.id }
           });
           
           const data = await res.json();
           
           if (data.error) {
             throw new Error(data.error);
           }
           
           setCV(null);
           
         } catch (err: any) {
           setError(err.message);
           throw err;
         } finally {
           setSaving(false);
         }
       }, [user]);
       
       const extractFromFile = useCallback(async (
         file: File,
         provider: AIProviderName,
         model: string
       ): Promise<CVExtractionResult> => {
         if (!user) throw new Error('Not authenticated');
         
         const formData = new FormData();
         formData.append('file', file);
         formData.append('provider', provider);
         formData.append('model', model);
         
         const res = await fetch('/api/cv/extract', {
           method: 'POST',
           headers: { 'x-user-id': user.id },
           body: formData
         });
         
         const result = await res.json();
         
         if (!res.ok || !result.success) {
           throw new Error(result.extractionNotes || 'Extraction failed');
         }
         
         return result;
       }, [user]);
       
       const extractFromText = useCallback(async (
         text: string,
         provider: AIProviderName,
         model: string
       ): Promise<CVExtractionResult> => {
         if (!user) throw new Error('Not authenticated');
         
         const formData = new FormData();
         formData.append('rawText', text);
         formData.append('provider', provider);
         formData.append('model', model);
         
         const res = await fetch('/api/cv/extract', {
           method: 'POST',
           headers: { 'x-user-id': user.id },
           body: formData
         });
         
         const result = await res.json();
         
         if (!res.ok || !result.success) {
           throw new Error(result.extractionNotes || 'Extraction failed');
         }
         
         return result;
       }, [user]);
       
       const applyExtraction = useCallback(async (result: CVExtractionResult) => {
         await saveCV(result.cv);
       }, [saveCV]);
       
       return {
         cv,
         loading,
         saving,
         error,
         fieldStatuses,
         completionPercentage,
         fetchCV,
         saveCV,
         updateCV,
         updateField,
         deleteCV,
         extractFromFile,
         extractFromText,
         applyExtraction,
       };
     }
     ```
  
  4. Update src/lib/cv/index.ts:
     ```typescript
     // ============================================
     // [F109] src/lib/cv/index.ts (updated)
     // ============================================
     
     export * from './cv-extractor';
     export * from './cv-extraction-prompt';
     export * from './cv-validator';
     export * from './cv-service';
     ```

checkpoint_tests:
  - id: T01
    description: "API route and hook files exist"
    type: "files_exist"
    files:
      - "src/app/api/cv/route.ts"
      - "src/hooks/useCV.ts"
      - "src/lib/cv/cv-service.ts"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "CV API route has all CRUD methods"
    type: "grep"
    file: "src/app/api/cv/route.ts"
    patterns:
      - "export async function GET"
      - "export async function POST"
      - "export async function PUT"
      - "export async function DELETE"
      - "createCVService"

  - id: T04
    description: "CV service has all methods"
    type: "grep"
    file: "src/lib/cv/cv-service.ts"
    patterns:
      - "getCV"
      - "createCV"
      - "updateCV"
      - "upsertCV"
      - "deleteCV"
      - "updateCVField"

  - id: T05
    description: "useCV hook exports all functions"
    type: "grep"
    file: "src/hooks/useCV.ts"
    patterns:
      - "export function useCV"
      - "fetchCV"
      - "saveCV"
      - "updateCV"
      - "updateField"
      - "extractFromFile"
      - "extractFromText"
      - "applyExtraction"

  - id: T06
    description: "useCV uses auth context"
    type: "grep"
    file: "src/hooks/useCV.ts"
    patterns:
      - "useAuth"
      - "user.id"

  - id: T07
    description: "CV index exports cv-service"
    type: "grep"
    file: "src/lib/cv/index.ts"
    patterns:
      - "cv-service"

max_retries: 3
B16.yaml — صفحه مدیریت سی‌وی (یکپارچه‌سازی)
YAML

# blocks/B16.yaml

id: B16
name: "CV Manager Page (Full Integration)"
phase: 1
phase_name: "CV Management"

goal: |
  Create the complete CV Manager page that integrates all CV components.
  Users can upload/enter their CV, see AI-extracted fields, complete missing info,
  preview their CV, and save to database.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13, B14, B15]

files_to_create:
  - id: F013
    path: "src/app/[locale]/cv-manager/page.tsx"
    description: "Main CV Manager page"

  - id: F103
    path: "src/app/[locale]/cv-manager/loading.tsx"
    description: "Loading state for CV Manager"

  - id: F117
    path: "src/components/cv/CVManagerTabs.tsx"
    description: "Tab navigation for CV Manager workflow"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add CV Manager page translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add CV Manager page translations"

files_available:
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F033
    path: "src/components/ui/tabs.tsx"
    from_block: B02
  - id: F035
    path: "src/components/ui/toast.tsx"
    from_block: B02
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F092
    path: "src/components/auth/AuthGuard.tsx"
    from_block: B07
  - id: F041
    path: "src/components/cv/CVUploader.tsx"
    from_block: B13
  - id: F042
    path: "src/components/cv/CVFieldDisplay.tsx"
    from_block: B14
  - id: F043
    path: "src/components/cv/CVCompletionForm.tsx"
    from_block: B14
  - id: F044
    path: "src/components/cv/CVPreview.tsx"
    from_block: B14
  - id: F082
    path: "src/hooks/useCV.ts"
    from_block: B15

commands: []

instructions: |
  1. Create CVManagerTabs.tsx:
     ```typescript
     // ============================================
     // [F117] src/components/cv/CVManagerTabs.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
     import { Upload, ListChecks, Eye } from 'lucide-react';
     import { cn } from '@/lib/utils';
     
     type CVTab = 'upload' | 'fields' | 'preview';
     
     interface CVManagerTabsProps {
       activeTab: CVTab;
       onTabChange: (tab: CVTab) => void;
       hasCV: boolean;
       completionPercentage: number;
       disabled?: boolean;
       className?: string;
     }
     
     export function CVManagerTabs({
       activeTab,
       onTabChange,
       hasCV,
       completionPercentage,
       disabled = false,
       className
     }: CVManagerTabsProps) {
       const t = useTranslations('cv_manager');
       
       return (
         <Tabs 
           value={activeTab} 
           onValueChange={(v) => onTabChange(v as CVTab)}
           className={className}
         >
           <TabsList className="grid w-full grid-cols-3">
             <TabsTrigger 
               value="upload" 
               disabled={disabled}
               className="flex items-center gap-2"
             >
               <Upload className="h-4 w-4" />
               <span className="hidden sm:inline">{t('upload_tab')}</span>
             </TabsTrigger>
             
             <TabsTrigger 
               value="fields" 
               disabled={disabled || !hasCV}
               className="flex items-center gap-2"
             >
               <ListChecks className="h-4 w-4" />
               <span className="hidden sm:inline">{t('fields_tab')}</span>
               {hasCV && completionPercentage < 100 && (
                 <span className={cn(
                   'text-xs px-1.5 py-0.5 rounded-full',
                   completionPercentage >= 70 
                     ? 'bg-green-100 text-green-700' 
                     : 'bg-yellow-100 text-yellow-700'
                 )}>
                   {completionPercentage}%
                 </span>
               )}
             </TabsTrigger>
             
             <TabsTrigger 
               value="preview" 
               disabled={disabled || !hasCV}
               className="flex items-center gap-2"
             >
               <Eye className="h-4 w-4" />
               <span className="hidden sm:inline">{t('preview_tab')}</span>
             </TabsTrigger>
           </TabsList>
         </Tabs>
       );
     }
     ```
  
  2. Create cv-manager/loading.tsx:
     ```typescript
     // ============================================
     // [F103] src/app/[locale]/cv-manager/loading.tsx
     // ============================================
     
     import { Skeleton } from '@/components/ui/skeleton';
     import { Card, CardContent, CardHeader } from '@/components/ui/card';
     
     export default function Loading() {
       return (
         <div className="container mx-auto p-6 space-y-6">
           {/* Header skeleton */}
           <div className="space-y-2">
             <Skeleton className="h-8 w-64" />
             <Skeleton className="h-4 w-96" />
           </div>
           
           {/* Tabs skeleton */}
           <Skeleton className="h-10 w-full" />
           
           {/* Content skeleton */}
           <Card>
             <CardHeader>
               <Skeleton className="h-6 w-48" />
             </CardHeader>
             <CardContent className="space-y-4">
               <Skeleton className="h-32 w-full" />
               <Skeleton className="h-10 w-32" />
             </CardContent>
           </Card>
         </div>
       );
     }
     ```
  
  3. Create cv-manager/page.tsx:
     ```typescript
     // ============================================
     // [F013] src/app/[locale]/cv-manager/page.tsx
     // ============================================
     
     'use client';
     
     import { useState, useEffect } from 'react';
     import { useTranslations } from 'next-intl';
     import { useParams } from 'next/navigation';
     import { AuthGuard } from '@/components/auth/AuthGuard';
     import { CVUploader } from '@/components/cv/CVUploader';
     import { CVFieldDisplay } from '@/components/cv/CVFieldDisplay';
     import { CVCompletionForm } from '@/components/cv/CVCompletionForm';
     import { CVPreview } from '@/components/cv/CVPreview';
     import { CVManagerTabs } from '@/components/cv/CVManagerTabs';
     import { useCV } from '@/hooks/useCV';
     import { Button } from '@/components/ui/button';
     import { Card, CardContent } from '@/components/ui/card';
     import { useToast } from '@/components/ui/use-toast';
     import { CVExtractionResult, ComprehensiveCV } from '@/lib/types';
     import { 
       FileText, Save, Trash2, CheckCircle, AlertCircle, Loader2 
     } from 'lucide-react';
     import { cn } from '@/lib/utils';
     
     type CVTab = 'upload' | 'fields' | 'preview';
     
     export default function CVManagerPage() {
       const t = useTranslations('cv_manager');
       const params = useParams();
       const locale = params.locale as 'en' | 'fa';
       const { toast } = useToast();
       
       const {
         cv,
         loading,
         saving,
         error,
         fieldStatuses,
         completionPercentage,
         saveCV,
         updateCV,
         deleteCV,
         applyExtraction
       } = useCV();
       
       const [activeTab, setActiveTab] = useState<CVTab>('upload');
       const [pendingExtraction, setPendingExtraction] = useState<CVExtractionResult | null>(null);
       
       // Switch to fields tab when CV is loaded or extracted
       useEffect(() => {
         if (cv && activeTab === 'upload') {
           setActiveTab('fields');
         }
       }, [cv]);
       
       // Handle extraction complete
       const handleExtractionComplete = async (result: CVExtractionResult) => {
         setPendingExtraction(result);
         
         try {
           await applyExtraction(result);
           
           toast({
             title: t('extraction_success'),
             description: t('extraction_success_desc'),
           });
           
           setActiveTab('fields');
           
         } catch (err: any) {
           toast({
             variant: 'destructive',
             title: t('extraction_error'),
             description: err.message,
           });
         } finally {
           setPendingExtraction(null);
         }
       };
       
       // Handle CV update from field display
       const handleCVUpdate = async (updates: Partial<ComprehensiveCV>) => {
         try {
           await updateCV(updates);
           
           toast({
             title: t('saved'),
             description: t('changes_saved'),
           });
           
         } catch (err: any) {
           toast({
             variant: 'destructive',
             title: t('save_error'),
             description: err.message,
           });
         }
       };
       
       // Handle delete CV
       const handleDeleteCV = async () => {
         if (!confirm(t('delete_confirm'))) return;
         
         try {
           await deleteCV();
           setActiveTab('upload');
           
           toast({
             title: t('deleted'),
             description: t('cv_deleted'),
           });
           
         } catch (err: any) {
           toast({
             variant: 'destructive',
             title: t('delete_error'),
             description: err.message,
           });
         }
       };
       
       // Get incomplete fields
       const incompleteFields = fieldStatuses.filter(s => !s.is_complete);
       
       return (
         <AuthGuard>
           <div className="container mx-auto p-6 max-w-5xl">
             {/* Header */}
             <div className="mb-6">
               <h1 className="text-2xl font-bold flex items-center gap-2">
                 <FileText className="h-6 w-6" />
                 {t('title')}
               </h1>
               <p className="text-muted-foreground mt-1">
                 {t('description')}
               </p>
             </div>
             
             {/* Error Display */}
             {error && (
               <Card className="mb-6 border-destructive">
                 <CardContent className="py-4">
                   <div className="flex items-center gap-2 text-destructive">
                     <AlertCircle className="h-5 w-5" />
                     <span>{error}</span>
                   </div>
                 </CardContent>
               </Card>
             )}
             
             {/* Loading State */}
             {loading ? (
               <Card>
                 <CardContent className="py-12">
                   <div className="flex flex-col items-center justify-center gap-3">
                     <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
                     <p className="text-muted-foreground">{t('loading')}</p>
                   </div>
                 </CardContent>
               </Card>
             ) : (
               <>
                 {/* Tab Navigation */}
                 <CVManagerTabs
                   activeTab={activeTab}
                   onTabChange={setActiveTab}
                   hasCV={cv !== null}
                   completionPercentage={completionPercentage}
                   disabled={saving}
                   className="mb-6"
                 />
                 
                 {/* Tab Content */}
                 <div className="space-y-6">
                   
                   {/* Upload Tab */}
                   {activeTab === 'upload' && (
                     <CVUploader
                       onExtractionComplete={handleExtractionComplete}
                       existingCV={cv}
                       disabled={saving}
                     />
                   )}
                   
                   {/* Fields Tab */}
                   {activeTab === 'fields' && cv && (
                     <>
                       {/* Incomplete Fields Warning */}
                       {incompleteFields.length > 0 && (
                         <CVCompletionForm
                           incompleteFields={incompleteFields}
                           onFieldClick={(section) => {
                             // Scroll to section or open edit modal
                             console.log('Navigate to section:', section);
                           }}
                         />
                       )}
                       
                       {/* Field Display */}
                       <CVFieldDisplay
                         cv={cv}
                         fieldStatuses={fieldStatuses}
                         confidence={pendingExtraction?.confidence || 85}
                         onUpdate={handleCVUpdate}
                       />
                     </>
                   )}
                   
                   {/* Preview Tab */}
                   {activeTab === 'preview' && cv && (
                     <CVPreview
                       cv={cv}
                       locale={locale}
                     />
                   )}
                   
                 </div>
                 
                 {/* Action Bar */}
                 {cv && (
                   <div className="mt-8 flex items-center justify-between border-t pt-6">
                     <div className="flex items-center gap-2 text-sm text-muted-foreground">
                       <CheckCircle className={cn(
                         'h-4 w-4',
                         completionPercentage === 100 ? 'text-green-500' : 'text-yellow-500'
                       )} />
                       <span>
                         {t('completion', { percent: completionPercentage })}
                       </span>
                     </div>
                     
                     <div className="flex items-center gap-3">
                       <Button
                         variant="outline"
                         onClick={handleDeleteCV}
                         disabled={saving}
                       >
                         <Trash2 className="h-4 w-4 mr-2" />
                         {t('delete_cv')}
                       </Button>
                       
                       <Button
                         onClick={() => saveCV(cv)}
                         disabled={saving}
                       >
                         {saving ? (
                           <>
                             <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                             {t('saving')}
                           </>
                         ) : (
                           <>
                             <Save className="h-4 w-4 mr-2" />
                             {t('save_cv')}
                           </>
                         )}
                       </Button>
                     </div>
                   </div>
                 )}
               </>
             )}
           </div>
         </AuthGuard>
       );
     }
     ```
  
  4. Add translations to en.json under "cv_manager" key:
     ```json
     {
       "cv_manager": {
         "title": "My Comprehensive CV",
         "description": "Upload, edit, and manage your comprehensive CV",
         "upload_tab": "Upload",
         "fields_tab": "Edit Fields",
         "preview_tab": "Preview",
         "loading": "Loading your CV...",
         "extraction_success": "CV Extracted Successfully",
         "extraction_success_desc": "Your CV has been processed. Please review the extracted information.",
         "extraction_error": "Extraction Failed",
         "saved": "Saved",
         "changes_saved": "Your changes have been saved.",
         "save_error": "Save Failed",
         "delete_confirm": "Are you sure you want to delete your CV? This action cannot be undone.",
         "deleted": "Deleted",
         "cv_deleted": "Your CV has been deleted.",
         "delete_error": "Delete Failed",
         "completion": "{percent}% complete",
         "save_cv": "Save CV",
         "saving": "Saving...",
         "delete_cv": "Delete CV"
       }
     }
     ```
  
  5. Add same translations to fa.json:
     ```json
     {
       "cv_manager": {
         "title": "سی‌وی جامع من",
         "description": "آپلود، ویرایش و مدیریت سی‌وی جامع شما",
         "upload_tab": "آپلود",
         "fields_tab": "ویرایش فیلدها",
         "preview_tab": "پیش‌نمایش",
         "loading": "در حال بارگذاری سی‌وی...",
         "extraction_success": "سی‌وی با موفقیت استخراج شد",
         "extraction_success_desc": "سی‌وی شما پردازش شد. لطفاً اطلاعات استخراج‌شده را بررسی کنید.",
         "extraction_error": "استخراج ناموفق بود",
         "saved": "ذخیره شد",
         "changes_saved": "تغییرات شما ذخیره شد.",
         "save_error": "ذخیره ناموفق بود",
         "delete_confirm": "آیا مطمئن هستید که می‌خواهید سی‌وی خود را حذف کنید؟ این عمل قابل بازگشت نیست.",
         "deleted": "حذف شد",
         "cv_deleted": "سی‌وی شما حذف شد.",
         "delete_error": "حذف ناموفق بود",
         "completion": "{percent}% تکمیل",
         "save_cv": "ذخیره سی‌وی",
         "saving": "در حال ذخیره...",
         "delete_cv": "حذف سی‌وی"
       }
     }
     ```

checkpoint_tests:
  - id: T01
    description: "CV Manager page files exist"
    type: "files_exist"
    files:
      - "src/app/[locale]/cv-manager/page.tsx"
      - "src/app/[locale]/cv-manager/loading.tsx"
      - "src/components/cv/CVManagerTabs.tsx"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "CV Manager page uses AuthGuard"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "AuthGuard"
      - "<AuthGuard>"

  - id: T04
    description: "CV Manager page uses all CV components"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "CVUploader"
      - "CVFieldDisplay"
      - "CVCompletionForm"
      - "CVPreview"
      - "CVManagerTabs"

  - id: T05
    description: "CV Manager page uses useCV hook"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "useCV"
      - "saveCV"
      - "updateCV"
      - "applyExtraction"

  - id: T06
    description: "CV Manager has tab navigation"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "activeTab"
      - "setActiveTab"
      - "upload"
      - "fields"
      - "preview"

  - id: T07
    description: "Uses toast notifications"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "useToast"
      - "toast({"

  - id: T08
    description: "CV Manager uses i18n"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "useTranslations"
      - "cv_manager"

  - id: T09
    description: "English translations have CV Manager keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "cv_manager"
      - "upload_tab"
      - "fields_tab"
      - "preview_tab"
      - "extraction_success"

  - id: T10
    description: "Farsi translations have CV Manager keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "cv_manager"
      - "extraction_success"

  - id: T11
    description: "Loading component exists with skeleton"
    type: "grep"
    file: "src/app/[locale]/cv-manager/loading.tsx"
    patterns:
      - "export default function Loading"
      - "Skeleton"

max_retries: 3
خلاصه بلوک‌های اصلاح‌شده B10-B16
بلوک	نام	توضیح تغییرات
B10	AI Provider Interface	جدید - از B19 منتقل شد، شامل OpenAI/Anthropic/Google providers
B11	API Key Management	جدید - رمزنگاری و مدیریت کلیدهای AI
B12	AI CV Extractor	جدید - استخراج فیلدهای CV با هوش مصنوعی به جای regex
B13	CV Uploader	اصلاح‌شده - یکپارچه با AI extraction، شامل AIModelPicker
B14	CV Field Display	اصلاح‌شده - شامل ConfidenceIndicator برای نمایش اطمینان AI
B15	CV API & Database	جدید - سرویس و API routes برای CRUD سی‌وی
B16	CV Manager Page	اصلاح‌شده - یکپارچه‌سازی کامل با AI extraction
نمودار وابستگی جدید
text

B01 → B02 → B03 → B04 → B05 → B06 → B07 → B08
                    │                    │
                    └─────────┬──────────┘
                              │
                    ┌─────────┴──────────┐
                    ▼                    ▼
                  B09                  B10 (AI Providers)
                    │                    │
                    │                    ▼
                    │                  B11 (AI Key Mgmt)
                    │                    │
                    └────────┬───────────┘
                             ▼
                           B12 (AI CV Extractor)
                             │
                             ▼
                           B13 (CV Uploader + AI)
                             │
                             ▼
                           B14 (CV Field Display)
                             │
                             ▼
                           B15 (CV API & DB)
                             │
                             ▼
                           B16 (CV Manager Page)
آیا می‌خواهی بلوک‌های B17 به بعد (مدیریت پرامپت‌ها، فرایند اصلی اپلیکیشن، و...) را هم بنویسم؟





ادامه بده

claude-opus-4-5-20251101
بلوک‌های B13 تا B16 — اصلاح‌شده برای AI Extraction
B13.yaml — کامپوننت آپلود سی‌وی (اصلاح‌شده)
YAML

# blocks/B13.yaml

id: B13
name: "CV Uploader Component"
phase: 1
phase_name: "CV Management"

goal: |
  Create a component that allows users to upload their CV file (Word or Markdown)
  or enter CV text directly. The component integrates with AI-powered extraction.
  Users must select an AI provider/model for extraction before uploading.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12]

files_to_create:
  - id: F041
    path: "src/components/cv/CVUploader.tsx"
    description: "Main CV upload component with AI extraction integration"

  - id: F097
    path: "src/components/cv/FileDropZone.tsx"
    description: "Reusable drag-and-drop file upload zone"

  - id: F098
    path: "src/components/cv/TextInputMode.tsx"
    description: "Textarea for direct CV text input"

  - id: F111
    path: "src/components/cv/AIModelPicker.tsx"
    description: "Component to select AI provider and model for extraction"

  - id: F112
    path: "src/components/cv/ExtractionProgress.tsx"
    description: "Shows extraction progress and status"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add CV upload translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add CV upload translations"

files_available:
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F028
    path: "src/components/ui/input.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F031
    path: "src/components/ui/select.tsx"
    from_block: B02
  - id: F032
    path: "src/components/ui/textarea.tsx"
    from_block: B02
  - id: F033
    path: "src/components/ui/tabs.tsx"
    from_block: B02
  - id: F034
    path: "src/components/ui/badge.tsx"
    from_block: B02
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F080
    path: "src/lib/utils.ts"
    from_block: B04
  - id: F090
    path: "src/context/AuthContext.tsx"
    from_block: B07
  - id: F072
    path: "src/lib/parsers/docx-parser.ts"
    from_block: B09
  - id: F073
    path: "src/lib/parsers/markdown-parser.ts"
    from_block: B09
  - id: F095
    path: "src/lib/parsers/index.ts"
    from_block: B09
  - id: F081
    path: "src/hooks/useAIKeys.ts"
    from_block: B11
  - id: F074
    path: "src/lib/cv/cv-extractor.ts"
    from_block: B12

commands: []

instructions: |
  1. Create FileDropZone.tsx:
     ```typescript
     // ============================================
     // [F097] src/components/cv/FileDropZone.tsx
     // ============================================
     
     'use client';
     
     import { useState, useCallback, useRef } from 'react';
     import { useTranslations } from 'next-intl';
     import { Upload, File, AlertCircle, X } from 'lucide-react';
     import { cn } from '@/lib/utils';
     import { MAX_FILE_SIZE_MB, MAX_FILE_SIZE_BYTES } from '@/lib/constants';
     
     interface FileDropZoneProps {
       onFileSelect: (file: File) => void;
       acceptedTypes?: string[];  // e.g., ['.docx', '.md']
       maxSizeMB?: number;
       disabled?: boolean;
       className?: string;
     }
     
     export function FileDropZone({
       onFileSelect,
       acceptedTypes = ['.docx', '.md', '.txt'],
       maxSizeMB = MAX_FILE_SIZE_MB,
       disabled = false,
       className
     }: FileDropZoneProps) {
       const t = useTranslations('cv');
       const [isDragging, setIsDragging] = useState(false);
       const [error, setError] = useState<string | null>(null);
       const [selectedFile, setSelectedFile] = useState<File | null>(null);
       const inputRef = useRef<HTMLInputElement>(null);
       
       const validateFile = useCallback((file: File): string | null => {
         // Check file extension
         const ext = '.' + file.name.split('.').pop()?.toLowerCase();
         if (!acceptedTypes.includes(ext)) {
           return t('invalid_format', { formats: acceptedTypes.join(', ') });
         }
         
         // Check file size
         const maxBytes = maxSizeMB * 1024 * 1024;
         if (file.size > maxBytes) {
           return t('file_too_large', { max: maxSizeMB });
         }
         
         return null;
       }, [acceptedTypes, maxSizeMB, t]);
       
       const handleFile = useCallback((file: File) => {
         const validationError = validateFile(file);
         if (validationError) {
           setError(validationError);
           setSelectedFile(null);
           return;
         }
         
         setError(null);
         setSelectedFile(file);
         onFileSelect(file);
       }, [validateFile, onFileSelect]);
       
       const handleDrop = useCallback((e: React.DragEvent) => {
         e.preventDefault();
         setIsDragging(false);
         
         if (disabled) return;
         
         const file = e.dataTransfer.files[0];
         if (file) {
           handleFile(file);
         }
       }, [disabled, handleFile]);
       
       const handleDragOver = useCallback((e: React.DragEvent) => {
         e.preventDefault();
         if (!disabled) {
           setIsDragging(true);
         }
       }, [disabled]);
       
       const handleDragLeave = useCallback((e: React.DragEvent) => {
         e.preventDefault();
         setIsDragging(false);
       }, []);
       
       const handleClick = useCallback(() => {
         if (!disabled) {
           inputRef.current?.click();
         }
       }, [disabled]);
       
       const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
         const file = e.target.files?.[0];
         if (file) {
           handleFile(file);
         }
       }, [handleFile]);
       
       const clearFile = useCallback(() => {
         setSelectedFile(null);
         setError(null);
         if (inputRef.current) {
           inputRef.current.value = '';
         }
       }, []);
       
       return (
         <div className={className}>
           <div
             onClick={handleClick}
             onDrop={handleDrop}
             onDragOver={handleDragOver}
             onDragLeave={handleDragLeave}
             className={cn(
               'border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors',
               isDragging && 'border-primary bg-primary/5',
               !isDragging && !error && 'border-muted-foreground/25 hover:border-primary/50',
               error && 'border-destructive bg-destructive/5',
               disabled && 'opacity-50 cursor-not-allowed',
               selectedFile && !error && 'border-green-500 bg-green-50 dark:bg-green-950'
             )}
           >
             <input
               ref={inputRef}
               type="file"
               accept={acceptedTypes.join(',')}
               onChange={handleInputChange}
               className="hidden"
               disabled={disabled}
             />
             
             {selectedFile && !error ? (
               <div className="flex items-center justify-center gap-3">
                 <File className="h-8 w-8 text-green-600" />
                 <div className="text-left">
                   <p className="font-medium text-green-700 dark:text-green-400">
                     {selectedFile.name}
                   </p>
                   <p className="text-sm text-muted-foreground">
                     {(selectedFile.size / 1024).toFixed(1)} KB
                   </p>
                 </div>
                 <button
                   onClick={(e) => { e.stopPropagation(); clearFile(); }}
                   className="p-1 hover:bg-muted rounded"
                 >
                   <X className="h-4 w-4" />
                 </button>
               </div>
             ) : (
               <>
                 <Upload className={cn(
                   'h-12 w-12 mx-auto mb-4',
                   error ? 'text-destructive' : 'text-muted-foreground'
                 )} />
                 <p className="text-lg font-medium mb-1">
                   {t('drag_drop_text')}
                 </p>
                 <p className="text-sm text-muted-foreground mb-2">
                   {t('or_click')}
                 </p>
                 <p className="text-xs text-muted-foreground">
                   {t('supported_formats')}: {acceptedTypes.join(', ')} • 
                   {t('max_file_size')}: {maxSizeMB}MB
                 </p>
               </>
             )}
           </div>
           
           {error && (
             <div className="flex items-center gap-2 mt-2 text-destructive text-sm">
               <AlertCircle className="h-4 w-4" />
               {error}
             </div>
           )}
         </div>
       );
     }
     ```
  
  2. Create TextInputMode.tsx:
     ```typescript
     // ============================================
     // [F098] src/components/cv/TextInputMode.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { Textarea } from '@/components/ui/textarea';
     import { Button } from '@/components/ui/button';
     import { X } from 'lucide-react';
     
     interface TextInputModeProps {
       value: string;
       onChange: (value: string) => void;
       disabled?: boolean;
       className?: string;
     }
     
     export function TextInputMode({
       value,
       onChange,
       disabled = false,
       className
     }: TextInputModeProps) {
       const t = useTranslations('cv');
       
       return (
         <div className={className}>
           <div className="relative">
             <Textarea
               value={value}
               onChange={(e) => onChange(e.target.value)}
               placeholder={t('text_placeholder')}
               disabled={disabled}
               rows={15}
               className="resize-none font-mono text-sm"
               dir="auto"
             />
             
             {value && (
               <Button
                 variant="ghost"
                 size="sm"
                 onClick={() => onChange('')}
                 className="absolute top-2 right-2"
                 disabled={disabled}
               >
                 <X className="h-4 w-4" />
               </Button>
             )}
           </div>
           
           <div className="flex justify-between mt-2 text-xs text-muted-foreground">
             <span>{t('character_count')}: {value.length}</span>
             <span>{t('word_count')}: {value.split(/\s+/).filter(Boolean).length}</span>
           </div>
         </div>
       );
     }
     ```
  
  3. Create AIModelPicker.tsx:
     ```typescript
     // ============================================
     // [F111] src/components/cv/AIModelPicker.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { useAIKeys } from '@/hooks/useAIKeys';
     import { AIProviderName, AIModel } from '@/lib/types';
     import { SUPPORTED_AI_PROVIDERS } from '@/lib/constants';
     import {
       Select,
       SelectContent,
       SelectItem,
       SelectTrigger,
       SelectValue,
     } from '@/components/ui/select';
     import { Badge } from '@/components/ui/badge';
     import { AlertCircle, CheckCircle, Settings } from 'lucide-react';
     import Link from 'next/link';
     
     interface AIModelPickerProps {
       selectedProvider: AIProviderName | null;
       selectedModel: string | null;
       onProviderChange: (provider: AIProviderName) => void;
       onModelChange: (model: string) => void;
       disabled?: boolean;
       className?: string;
     }
     
     export function AIModelPicker({
       selectedProvider,
       selectedModel,
       onProviderChange,
       onModelChange,
       disabled = false,
       className
     }: AIModelPickerProps) {
       const t = useTranslations('ai_keys');
       const { keys, loading, hasValidKey, getModelsForProvider, getValidProviders } = useAIKeys();
       
       const validProviders = getValidProviders();
       const hasAnyValidKey = validProviders.length > 0;
       
       const availableModels = selectedProvider 
         ? getModelsForProvider(selectedProvider) 
         : [];
       
       if (loading) {
         return (
           <div className={className}>
             <div className="animate-pulse h-10 bg-muted rounded" />
           </div>
         );
       }
       
       if (!hasAnyValidKey) {
         return (
           <div className={className}>
             <div className="flex items-center gap-2 p-4 bg-yellow-50 dark:bg-yellow-950 border border-yellow-200 dark:border-yellow-800 rounded-lg">
               <AlertCircle className="h-5 w-5 text-yellow-600" />
               <div className="flex-1">
                 <p className="text-sm font-medium text-yellow-800 dark:text-yellow-200">
                   {t('no_keys_configured')}
                 </p>
                 <p className="text-xs text-yellow-700 dark:text-yellow-300">
                   {t('add_key_to_extract')}
                 </p>
               </div>
               <Link href="/settings">
                 <Badge variant="outline" className="cursor-pointer hover:bg-yellow-100">
                   <Settings className="h-3 w-3 mr-1" />
                   {t('go_to_settings')}
                 </Badge>
               </Link>
             </div>
           </div>
         );
       }
       
       return (
         <div className={className}>
           <div className="grid grid-cols-2 gap-4">
             {/* Provider Selection */}
             <div>
               <label className="text-sm font-medium mb-1.5 block">
                 {t('provider')}
               </label>
               <Select
                 value={selectedProvider || ''}
                 onValueChange={(v) => {
                   onProviderChange(v as AIProviderName);
                   onModelChange('');  // Reset model when provider changes
                 }}
                 disabled={disabled}
               >
                 <SelectTrigger>
                   <SelectValue placeholder={t('select_provider')} />
                 </SelectTrigger>
                 <SelectContent>
                   {SUPPORTED_AI_PROVIDERS.map((provider) => {
                     const isValid = hasValidKey(provider.name);
                     return (
                       <SelectItem
                         key={provider.name}
                         value={provider.name}
                         disabled={!isValid}
                       >
                         <div className="flex items-center gap-2">
                           {isValid ? (
                             <CheckCircle className="h-3 w-3 text-green-500" />
                           ) : (
                             <AlertCircle className="h-3 w-3 text-muted-foreground" />
                           )}
                           {provider.label}
                         </div>
                       </SelectItem>
                     );
                   })}
                 </SelectContent>
               </Select>
             </div>
             
             {/* Model Selection */}
             <div>
               <label className="text-sm font-medium mb-1.5 block">
                 {t('model')}
               </label>
               <Select
                 value={selectedModel || ''}
                 onValueChange={onModelChange}
                 disabled={disabled || !selectedProvider || availableModels.length === 0}
               >
                 <SelectTrigger>
                   <SelectValue placeholder={t('select_model')} />
                 </SelectTrigger>
                 <SelectContent>
                   {availableModels.map((model) => (
                     <SelectItem key={model.model_id} value={model.model_id}>
                       {model.model_name}
                     </SelectItem>
                   ))}
                 </SelectContent>
               </Select>
             </div>
           </div>
         </div>
       );
     }
     ```
  
  4. Create ExtractionProgress.tsx:
     ```typescript
     // ============================================
     // [F112] src/components/cv/ExtractionProgress.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { Loader2, CheckCircle, AlertCircle, FileText } from 'lucide-react';
     import { cn } from '@/lib/utils';
     
     type ExtractionStatus = 'idle' | 'parsing' | 'extracting' | 'success' | 'error';
     
     interface ExtractionProgressProps {
       status: ExtractionStatus;
       errorMessage?: string;
       fileName?: string;
       className?: string;
     }
     
     export function ExtractionProgress({
       status,
       errorMessage,
       fileName,
       className
     }: ExtractionProgressProps) {
       const t = useTranslations('cv');
       
       if (status === 'idle') {
         return null;
       }
       
       const statusConfig = {
         parsing: {
           icon: <Loader2 className="h-5 w-5 animate-spin text-blue-500" />,
           text: t('parsing_file'),
           bgColor: 'bg-blue-50 dark:bg-blue-950 border-blue-200'
         },
         extracting: {
           icon: <Loader2 className="h-5 w-5 animate-spin text-purple-500" />,
           text: t('extracting_with_ai'),
           bgColor: 'bg-purple-50 dark:bg-purple-950 border-purple-200'
         },
         success: {
           icon: <CheckCircle className="h-5 w-5 text-green-500" />,
           text: t('extraction_complete'),
           bgColor: 'bg-green-50 dark:bg-green-950 border-green-200'
         },
         error: {
           icon: <AlertCircle className="h-5 w-5 text-red-500" />,
           text: errorMessage || t('extraction_error'),
           bgColor: 'bg-red-50 dark:bg-red-950 border-red-200'
         }
       };
       
       const config = statusConfig[status];
       
       return (
         <div className={cn(
           'flex items-center gap-3 p-4 rounded-lg border',
           config.bgColor,
           className
         )}>
           {config.icon}
           <div className="flex-1">
             <p className="font-medium">{config.text}</p>
             {fileName && status !== 'error' && (
               <p className="text-sm text-muted-foreground flex items-center gap-1">
                 <FileText className="h-3 w-3" />
                 {fileName}
               </p>
             )}
           </div>
         </div>
       );
     }
     ```
  
  5. Create CVUploader.tsx:
     ```typescript
     // ============================================
     // [F041] src/components/cv/CVUploader.tsx
     // ============================================
     
     'use client';
     
     import { useState, useCallback } from 'react';
     import { useTranslations } from 'next-intl';
     import { useAuth } from '@/context/AuthContext';
     import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
     import { Button } from '@/components/ui/button';
     import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
     import { FileDropZone } from './FileDropZone';
     import { TextInputMode } from './TextInputMode';
     import { AIModelPicker } from './AIModelPicker';
     import { ExtractionProgress } from './ExtractionProgress';
     import { AIProviderName, CVExtractionResult, ComprehensiveCV } from '@/lib/types';
     import { Upload, FileText, Sparkles } from 'lucide-react';
     
     type ExtractionStatus = 'idle' | 'parsing' | 'extracting' | 'success' | 'error';
     
     interface CVUploaderProps {
       onExtractionComplete: (result: CVExtractionResult) => void;
       existingCV?: Partial<ComprehensiveCV> | null;
       disabled?: boolean;
       className?: string;
     }
     
     export function CVUploader({
       onExtractionComplete,
       existingCV,
       disabled = false,
       className
     }: CVUploaderProps) {
       const t = useTranslations('cv');
       const { user } = useAuth();
       
       // State
       const [activeTab, setActiveTab] = useState<'upload' | 'text'>('upload');
       const [selectedFile, setSelectedFile] = useState<File | null>(null);
       const [textInput, setTextInput] = useState('');
       const [selectedProvider, setSelectedProvider] = useState<AIProviderName | null>(null);
       const [selectedModel, setSelectedModel] = useState<string | null>(null);
       const [status, setStatus] = useState<ExtractionStatus>('idle');
       const [errorMessage, setErrorMessage] = useState<string>('');
       
       const canExtract = 
         (activeTab === 'upload' ? selectedFile !== null : textInput.trim().length > 0) &&
         selectedProvider !== null &&
         selectedModel !== null;
       
       const handleFileSelect = useCallback((file: File) => {
         setSelectedFile(file);
         setStatus('idle');
         setErrorMessage('');
       }, []);
       
       const handleExtract = useCallback(async () => {
         if (!canExtract || !user) return;
         
         setStatus('parsing');
         setErrorMessage('');
         
         try {
           const formData = new FormData();
           
           if (activeTab === 'upload' && selectedFile) {
             formData.append('file', selectedFile);
           } else {
             formData.append('rawText', textInput);
           }
           
           formData.append('provider', selectedProvider!);
           formData.append('model', selectedModel!);
           
           setStatus('extracting');
           
           const response = await fetch('/api/cv/extract', {
             method: 'POST',
             headers: {
               'x-user-id': user.id
             },
             body: formData
           });
           
           const result: CVExtractionResult = await response.json();
           
           if (!response.ok || !result.success) {
             throw new Error(result.extractionNotes || 'Extraction failed');
           }
           
           setStatus('success');
           onExtractionComplete(result);
           
         } catch (error: any) {
           setStatus('error');
           setErrorMessage(error.message || t('extraction_error'));
         }
       }, [
         canExtract, 
         user, 
         activeTab, 
         selectedFile, 
         textInput, 
         selectedProvider, 
         selectedModel, 
         onExtractionComplete,
         t
       ]);
       
       const isProcessing = status === 'parsing' || status === 'extracting';
       
       return (
         <Card className={className}>
           <CardHeader>
             <CardTitle className="flex items-center gap-2">
               <Upload className="h-5 w-5" />
               {t('upload_cv')}
             </CardTitle>
             <CardDescription>
               {existingCV 
                 ? t('upload_description_replace')
                 : t('upload_description')
               }
             </CardDescription>
           </CardHeader>
           
           <CardContent className="space-y-6">
             {/* AI Model Selection - Required First */}
             <div className="p-4 bg-muted/50 rounded-lg">
               <h3 className="text-sm font-medium mb-3 flex items-center gap-2">
                 <Sparkles className="h-4 w-4" />
                 {t('select_ai_for_extraction')}
               </h3>
               <AIModelPicker
                 selectedProvider={selectedProvider}
                 selectedModel={selectedModel}
                 onProviderChange={setSelectedProvider}
                 onModelChange={setSelectedModel}
                 disabled={disabled || isProcessing}
               />
             </div>
             
             {/* Upload Tabs */}
             <Tabs 
               value={activeTab} 
               onValueChange={(v) => setActiveTab(v as 'upload' | 'text')}
             >
               <TabsList className="grid w-full grid-cols-2">
                 <TabsTrigger value="upload" disabled={isProcessing}>
                   <Upload className="h-4 w-4 mr-2" />
                   {t('upload_tab')}
                 </TabsTrigger>
                 <TabsTrigger value="text" disabled={isProcessing}>
                   <FileText className="h-4 w-4 mr-2" />
                   {t('text_tab')}
                 </TabsTrigger>
               </TabsList>
               
               <TabsContent value="upload" className="mt-4">
                 <FileDropZone
                   onFileSelect={handleFileSelect}
                   acceptedTypes={['.docx', '.md', '.txt']}
                   disabled={disabled || isProcessing}
                 />
               </TabsContent>
               
               <TabsContent value="text" className="mt-4">
                 <TextInputMode
                   value={textInput}
                   onChange={setTextInput}
                   disabled={disabled || isProcessing}
                 />
               </TabsContent>
             </Tabs>
             
             {/* Extraction Progress */}
             <ExtractionProgress
               status={status}
               errorMessage={errorMessage}
               fileName={selectedFile?.name}
             />
             
             {/* Extract Button */}
             <Button
               onClick={handleExtract}
               disabled={!canExtract || isProcessing || disabled}
               className="w-full"
               size="lg"
             >
               {isProcessing ? (
                 <>
                   <Sparkles className="h-4 w-4 mr-2 animate-pulse" />
                   {t('extracting')}
                 </>
               ) : (
                 <>
                   <Sparkles className="h-4 w-4 mr-2" />
                   {t('extract_with_ai')}
                 </>
               )}
             </Button>
           </CardContent>
         </Card>
       );
     }
     ```
  
  6. Add translations to en.json under "cv" key:
     ```json
     {
       "cv": {
         "upload_cv": "Upload Your CV",
         "upload_description": "Upload your comprehensive CV to get started",
         "upload_description_replace": "Upload a new CV to replace your existing one",
         "upload_tab": "Upload File",
         "text_tab": "Paste Text",
         "drag_drop_text": "Drag and drop your CV here",
         "or_click": "or click to browse",
         "supported_formats": "Supported formats",
         "max_file_size": "Max size",
         "file_too_large": "File is too large. Maximum size is {max}MB",
         "invalid_format": "Invalid file format. Supported: {formats}",
         "text_placeholder": "Paste your CV content here...",
         "character_count": "Characters",
         "word_count": "Words",
         "select_ai_for_extraction": "Select AI for CV Extraction",
         "parsing_file": "Parsing file...",
         "extracting_with_ai": "Extracting information with AI...",
         "extraction_complete": "Extraction complete!",
         "extraction_error": "Extraction failed. Please try again.",
         "extracting": "Extracting...",
         "extract_with_ai": "Extract with AI"
       },
       "ai_keys": {
         "no_keys_configured": "No AI API keys configured",
         "add_key_to_extract": "Add an API key in Settings to extract CV with AI",
         "go_to_settings": "Settings",
         "provider": "AI Provider",
         "model": "Model",
         "select_provider": "Select provider",
         "select_model": "Select model"
       }
     }
     ```
  
  7. Add same translations to fa.json:
     ```json
     {
       "cv": {
         "upload_cv": "آپلود سی‌وی",
         "upload_description": "سی‌وی جامع خود را آپلود کنید",
         "upload_description_replace": "یک سی‌وی جدید آپلود کنید تا جایگزین موجود شود",
         "upload_tab": "آپلود فایل",
         "text_tab": "ورود متن",
         "drag_drop_text": "فایل سی‌وی را اینجا بکشید و رها کنید",
         "or_click": "یا کلیک کنید",
         "supported_formats": "فرمت‌های پشتیبانی",
         "max_file_size": "حداکثر حجم",
         "file_too_large": "فایل بیش از حد بزرگ است. حداکثر {max} مگابایت",
         "invalid_format": "فرمت فایل نامعتبر است. پشتیبانی: {formats}",
         "text_placeholder": "محتوای سی‌وی خود را اینجا بچسبانید...",
         "character_count": "کاراکتر",
         "word_count": "کلمه",
         "select_ai_for_extraction": "انتخاب هوش مصنوعی برای استخراج",
         "parsing_file": "در حال پردازش فایل...",
         "extracting_with_ai": "در حال استخراج اطلاعات با هوش مصنوعی...",
         "extraction_complete": "استخراج کامل شد!",
         "extraction_error": "استخراج ناموفق بود. دوباره تلاش کنید.",
         "extracting": "در حال استخراج...",
         "extract_with_ai": "استخراج با هوش مصنوعی"
       },
       "ai_keys": {
         "no_keys_configured": "کلید API تنظیم نشده است",
         "add_key_to_extract": "برای استخراج سی‌وی، کلید API را در تنظیمات اضافه کنید",
         "go_to_settings": "تنظیمات",
         "provider": "سرویس هوش مصنوعی",
         "model": "مدل",
         "select_provider": "انتخاب سرویس",
         "select_model": "انتخاب مدل"
       }
     }
     ```

checkpoint_tests:
  - id: T01
    description: "All CV uploader component files exist"
    type: "files_exist"
    files:
      - "src/components/cv/CVUploader.tsx"
      - "src/components/cv/FileDropZone.tsx"
      - "src/components/cv/TextInputMode.tsx"
      - "src/components/cv/AIModelPicker.tsx"
      - "src/components/cv/ExtractionProgress.tsx"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "CVUploader integrates with AI extraction"
    type: "grep"
    file: "src/components/cv/CVUploader.tsx"
    patterns:
      - "AIModelPicker"
      - "/api/cv/extract"
      - "CVExtractionResult"
      - "selectedProvider"
      - "selectedModel"

  - id: T04
    description: "FileDropZone implements drag and drop"
    type: "grep"
    file: "src/components/cv/FileDropZone.tsx"
    patterns:
      - "onDragOver"
      - "onDrop"
      - "onFileSelect"

  - id: T05
    description: "AIModelPicker uses useAIKeys hook"
    type: "grep"
    file: "src/components/cv/AIModelPicker.tsx"
    patterns:
      - "useAIKeys"
      - "getValidProviders"
      - "getModelsForProvider"

  - id: T06
    description: "Uses i18n for translations"
    type: "grep"
    file: "src/components/cv/CVUploader.tsx"
    patterns:
      - "useTranslations"

  - id: T07
    description: "English translations have CV keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "extract_with_ai"
      - "extracting_with_ai"
      - "select_ai_for_extraction"

  - id: T08
    description: "Farsi translations have CV keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "extract_with_ai"
      - "select_ai_for_extraction"

max_retries: 3
B14.yaml — نمایش و تکمیل فیلدهای سی‌وی
YAML

# blocks/B14.yaml

id: B14
name: "CV Field Display and Completion Forms"
phase: 1
phase_name: "CV Management"

goal: |
  Create components to display AI-extracted CV fields, highlight incomplete fields,
  show confidence scores, and provide forms to complete or edit information.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13]

files_to_create:
  - id: F042
    path: "src/components/cv/CVFieldDisplay.tsx"
    description: "Display extracted fields with completeness indicators"

  - id: F043
    path: "src/components/cv/CVCompletionForm.tsx"
    description: "Form to fill in missing CV fields"

  - id: F044
    path: "src/components/cv/CVPreview.tsx"
    description: "Preview the complete CV in a readable format"

  - id: F099
    path: "src/components/cv/FieldStatusBadge.tsx"
    description: "Badge showing complete/incomplete status"

  - id: F100
    path: "src/components/cv/WorkExperienceForm.tsx"
    description: "Form for adding/editing work experience entries"

  - id: F101
    path: "src/components/cv/EducationForm.tsx"
    description: "Form for adding/editing education entries"

  - id: F113
    path: "src/components/cv/SkillsEditor.tsx"
    description: "Tag-based editor for skills"

  - id: F114
    path: "src/components/cv/PersonalInfoForm.tsx"
    description: "Form for editing personal information"

  - id: F115
    path: "src/components/cv/ConfidenceIndicator.tsx"
    description: "Shows AI extraction confidence score"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add field display and form translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add field display and form translations"

files_available:
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F028
    path: "src/components/ui/input.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F030
    path: "src/components/ui/dialog.tsx"
    from_block: B02
  - id: F032
    path: "src/components/ui/textarea.tsx"
    from_block: B02
  - id: F034
    path: "src/components/ui/badge.tsx"
    from_block: B02
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F108
    path: "src/lib/cv/cv-validator.ts"
    from_block: B12

commands: []

instructions: |
  1. Create FieldStatusBadge.tsx:
     ```typescript
     // ============================================
     // [F099] src/components/cv/FieldStatusBadge.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { Badge } from '@/components/ui/badge';
     import { CheckCircle, AlertCircle } from 'lucide-react';
     import { cn } from '@/lib/utils';
     
     interface FieldStatusBadgeProps {
       isComplete: boolean;
       size?: 'sm' | 'md';
       showText?: boolean;
       className?: string;
     }
     
     export function FieldStatusBadge({
       isComplete,
       size = 'sm',
       showText = true,
       className
     }: FieldStatusBadgeProps) {
       const t = useTranslations('cv');
       
       const iconSize = size === 'sm' ? 'h-3 w-3' : 'h-4 w-4';
       
       if (isComplete) {
         return (
           <Badge 
             variant="outline" 
             className={cn(
               'bg-green-50 text-green-700 border-green-200 dark:bg-green-950 dark:text-green-300',
               className
             )}
           >
             <CheckCircle className={cn(iconSize, showText && 'mr-1')} />
             {showText && t('field_complete')}
           </Badge>
         );
       }
       
       return (
         <Badge 
           variant="outline" 
           className={cn(
             'bg-yellow-50 text-yellow-700 border-yellow-200 dark:bg-yellow-950 dark:text-yellow-300',
             className
           )}
         >
           <AlertCircle className={cn(iconSize, showText && 'mr-1')} />
           {showText && t('field_incomplete')}
         </Badge>
       );
     }
     ```
  
  2. Create ConfidenceIndicator.tsx:
     ```typescript
     // ============================================
     // [F115] src/components/cv/ConfidenceIndicator.tsx
     // ============================================
     
     'use client';
     
     import { useTranslations } from 'next-intl';
     import { cn } from '@/lib/utils';
     import { Sparkles } from 'lucide-react';
     
     interface ConfidenceIndicatorProps {
       confidence: number;  // 0-100
       className?: string;
     }
     
     export function ConfidenceIndicator({ confidence, className }: ConfidenceIndicatorProps) {
       const t = useTranslations('cv');
       
       const getColor = () => {
         if (confidence >= 80) return 'text-green-600 bg-green-100';
         if (confidence >= 60) return 'text-yellow-600 bg-yellow-100';
         return 'text-red-600 bg-red-100';
       };
       
       const getLabel = () => {
         if (confidence >= 80) return t('confidence_high');
         if (confidence >= 60) return t('confidence_medium');
         return t('confidence_low');
       };
       
       return (
         <div className={cn('flex items-center gap-2', className)}>
           <div className={cn(
             'flex items-center gap-1.5 px-2 py-1 rounded-full text-sm font-medium',
             getColor()
           )}>
             <Sparkles className="h-3.5 w-3.5" />
             <span>{confidence}%</span>
           </div>
           <span className="text-xs text-muted-foreground">
             {t('ai_confidence')}: {getLabel()}
           </span>
         </div>
       );
     }
     ```
  
  3. Create PersonalInfoForm.tsx:
     ```typescript
     // ============================================
     // [F114] src/components/cv/PersonalInfoForm.tsx
     // ============================================
     
     'use client';
     
     import { useState } from 'react';
     import { useTranslations } from 'next-intl';
     import { PersonalInfo } from '@/lib/types';
     import { Button } from '@/components/ui/button';
     import { Input } from '@/components/ui/input';
     import { Textarea } from '@/components/ui/textarea';
     import { Label } from '@/components/ui/label';
     import {
       Dialog,
       DialogContent,
       DialogHeader,
       DialogTitle,
       DialogFooter,
     } from '@/components/ui/dialog';
     
     interface PersonalInfoFormProps {
       info: Partial<PersonalInfo>;
       open: boolean;
       onClose: () => void;
       onSave: (info: PersonalInfo) => void;
     }
     
     export function PersonalInfoForm({
       info,
       open,
       onClose,
       onSave
     }: PersonalInfoFormProps) {
       const t = useTranslations('cv');
       const [formData, setFormData] = useState<Partial<PersonalInfo>>(info);
       
       const handleChange = (field: keyof PersonalInfo, value: string) => {
         setFormData(prev => ({ ...prev, [field]: value }));
       };
       
       const handleSubmit = () => {
         onSave(formData as PersonalInfo);
         onClose();
       };
       
       return (
         <Dialog open={open} onOpenChange={onClose}>
           <DialogContent className="max-w-lg">
             <DialogHeader>
               <DialogTitle>{t('edit_personal_info')}</DialogTitle>
             </DialogHeader>
             
             <div className="grid gap-4 py-4">
               <div className="grid gap-2">
                 <Label htmlFor="full_name">{t('full_name')} *</Label>
                 <Input
                   id="full_name"
                   value={formData.full_name || ''}
                   onChange={(e) => handleChange('full_name', e.target.value)}
                   placeholder={t('full_name_placeholder')}
                 />
               </div>
               
               <div className="grid grid-cols-2 gap-4">
                 <div className="grid gap-2">
                   <Label htmlFor="email">{t('email')} *</Label>
                   <Input
                     id="email"
                     type="email"
                     value={formData.email || ''}
                     onChange={(e) => handleChange('email', e.target.value)}
                     placeholder="email@example.com"
                   />
                 </div>
                 <div className="grid gap-2">
                   <Label htmlFor="phone">{t('phone')}</Label>
                   <Input
                     id="phone"
                     value={formData.phone || ''}
                     onChange={(e) => handleChange('phone', e.target.value)}
                     placeholder="+1 234 567 8900"
                   />
                 </div>
               </div>
               
               <div className="grid gap-2">
                 <Label htmlFor="location">{t('location')}</Label>
                 <Input
                   id="location"
                   value={formData.location || ''}
                   onChange={(e) => handleChange('location', e.target.value)}
                   placeholder={t('location_placeholder')}
                 />
               </div>
               
               <div className="grid grid-cols-2 gap-4">
                 <div className="grid gap-2">
                   <Label htmlFor="linkedin">{t('linkedin')}</Label>
                   <Input
                     id="linkedin"
                     value={formData.linkedin_url || ''}
                     onChange={(e) => handleChange('linkedin_url', e.target.value)}
                     placeholder="linkedin.com/in/..."
                   />
                 </div>
                 <div className="grid gap-2">
                   <Label htmlFor="website">{t('website')}</Label>
                   <Input
                     id="website"
                     value={formData.website_url || ''}
                     onChange={(e) => handleChange('website_url', e.target.value)}
                     placeholder="https://..."
                   />
                 </div>
               </div>
               
               <div className="grid gap-2">
                 <Label htmlFor="summary">{t('summary')}</Label>
                 <Textarea
                   id="summary"
                   value={formData.summary || ''}
                   onChange={(e) => handleChange('summary', e.target.value)}
                   placeholder={t('summary_placeholder')}
                   rows={4}
                 />
               </div>
             </div>
             
             <DialogFooter>
               <Button variant="outline" onClick={onClose}>
                 {t('cancel')}
               </Button>
               <Button onClick={handleSubmit}>
                 {t('save')}
               </Button>
             </DialogFooter>
           </DialogContent>
         </Dialog>
       );
     }
     ```
  
  4. Create WorkExperienceForm.tsx:
     ```typescript
     // ============================================
     // [F100] src/components/cv/WorkExperienceForm.tsx
     // ============================================
     
     'use client';
     
     import { useState } from 'react';
     import { useTranslations } from 'next-intl';
     import { WorkExperience } from '@/lib/types';
     import { generateId } from '@/lib/utils';
     import { Button } from '@/components/ui/button';
     import { Input } from '@/components/ui/input';
     import { Textarea } from '@/components/ui/textarea';
     import { Label } from '@/components/ui/label';
     import { Checkbox } from '@/components/ui/checkbox';
     import {
       Dialog,
       DialogContent,
       DialogHeader,
       DialogTitle,
       DialogFooter,
     } from '@/components/ui/dialog';
     import { Plus, X } from 'lucide-react';
     
     interface WorkExperienceFormProps {
       experience?: WorkExperience;
       open: boolean;
       onClose: () => void;
       onSave: (experience: WorkExperience) => void;
     }
     
     export function WorkExperienceForm({
       experience,
       open,
       onClose,
       onSave
     }: WorkExperienceFormProps) {
       const t = useTranslations('cv');
       
       const [formData, setFormData] = useState<Partial<WorkExperience>>(
         experience || {
           id: generateId(),
           job_title: '',
           company: '',
           location: '',
           start_date: '',
           end_date: '',
           is_current: false,
           description: '',
           achievements: []
         }
       );
       
       const [newAchievement, setNewAchievement] = useState('');
       
       const handleChange = (field: keyof WorkExperience, value: any) => {
         setFormData(prev => ({ ...prev, [field]: value }));
       };
       
       const addAchievement = () => {
         if (newAchievement.trim()) {
           handleChange('achievements', [
             ...(formData.achievements || []),
             newAchievement.trim()
           ]);
           setNewAchievement('');
         }
       };
       
       const removeAchievement = (index: number) => {
         handleChange('achievements', 
           (formData.achievements || []).filter((_, i) => i !== index)
         );
       };
       
       const handleSubmit = () => {
         onSave(formData as WorkExperience);
         onClose();
       };
       
       return (
         <Dialog open={open} onOpenChange={onClose}>
           <DialogContent className="max-w-lg max-h-[90vh] overflow-y-auto">
             <DialogHeader>
               <DialogTitle>
                 {experience ? t('edit_experience') : t('add_experience')}
               </DialogTitle>
             </DialogHeader>
             
             <div className="grid gap-4 py-4">
               <div className="grid gap-2">
                 <Label htmlFor="job_title">{t('job_title')} *</Label>
                 <Input
                   id="job_title"
                   value={formData.job_title || ''}
                   onChange={(e) => handleChange('job_title', e.target.value)}
                   placeholder={t('job_title_placeholder')}
                 />
               </div>
               
               <div className="grid gap-2">
                 <Label htmlFor="company">{t('company')} *</Label>
                 <Input
                   id="company"
                   value={formData.company || ''}
                   onChange={(e) => handleChange('company', e.target.value)}
                   placeholder={t('company_placeholder')}
                 />
               </div>
               
               <div className="grid gap-2">
                 <Label htmlFor="location">{t('location')}</Label>
                 <Input
                   id="location"
                   value={formData.location || ''}
                   onChange={(e) => handleChange('location', e.target.value)}
                   placeholder={t('location_placeholder')}
                 />
               </div>
               
               <div className="grid grid-cols-2 gap-4">
                 <div className="grid gap-2">
                   <Label htmlFor="start_date">{t('start_date')}</Label>
                   <Input
                     id="start_date"
                     type="month"
                     value={formData.start_date || ''}
                     onChange={(e) => handleChange('start_date', e.target.value)}
                   />
                 </div>
                 <div className="grid gap-2">
                   <Label htmlFor="end_date">{t('end_date')}</Label>
                   <Input
                     id="end_date"
                     type="month"
                     value={formData.end_date || ''}
                     onChange={(e) => handleChange('end_date', e.target.value)}
                     disabled={formData.is_current}
                   />
                 </div>
               </div>
               
               <div className="flex items-center gap-2">
                 <Checkbox
                   id="is_current"
                   checked={formData.is_current}
                   onCheckedChange={(checked) => {
                     handleChange('is_current', checked);
                     if (checked) handleChange('end_date', '');
                   }}
                 />
                 <Label htmlFor="is_current" className="cursor-pointer">
                   {t('current_position')}
                 </Label>
               </div>
               
               <div className="grid gap-2">
                 <Label htmlFor="description">{t('description')}</Label>
                 <Textarea
                   id="description"
                   value={formData.description || ''}
                   onChange={(e) => handleChange('description', e.target.value)}
                   placeholder={t('description_placeholder')}
                   rows={3}
                 />
               </div>
               
               {/* Achievements */}
               <div className="grid gap-2">
                 <Label>{t('achievements')}</Label>
                 <div className="space-y-2">
                   {(formData.achievements || []).map((achievement, index) => (
                     <div key={index} className="flex items-center gap-2">
                       <span className="flex-1 text-sm bg-muted p-2 rounded">
                         {achievement}
                       </span>
                       <Button
                         type="button"
                         variant="ghost"
                         size="sm"
                         onClick={() => removeAchievement(index)}
                       >
                         <X className="h-4 w-4" />
                       </Button>
                     </div>
                   ))}
                   <div className="flex gap-2">
                     <Input
                       value={newAchievement}
                       onChange={(e) => setNewAchievement(e.target.value)}
                       placeholder={t('add_achievement_placeholder')}
                       onKeyPress={(e) => e.key === 'Enter' && addAchievement()}
                     />
                     <Button type="button" variant="outline" onClick={addAchievement}>
                       <Plus className="h-4 w-4" />
                     </Button>
                   </div>
                 </div>
               </div>
             </div>
             
             <DialogFooter>
               <Button variant="outline" onClick={onClose}>
                 {t('cancel')}
               </Button>
               <Button onClick={handleSubmit}>
                 {t('save')}
               </Button>
             </DialogFooter>
           </DialogContent>
         </Dialog>
       );
     }
     ```
  
  5. Create EducationForm.tsx (similar structure to WorkExperienceForm):
     ```typescript
     // ============================================
     // [F101] src/components/cv/EducationForm.tsx
     // ============================================
     
     'use client';
     
     import { useState } from 'react';
     import { useTranslations } from 'next-intl';
     import { Education } from '@/lib/types';
     import { generateId } from '@/lib/utils';
     import { Button } from '@/components/ui/button';
     import { Input } from '@/components/ui/input';
     import { Textarea } from '@/components/ui/textarea';
     import { Label } from '@/components/ui/label';
     import {
       Dialog,
       DialogContent,
       DialogHeader,
       DialogTitle,
       DialogFooter,
     } from '@/components/ui/dialog';
     
     interface EducationFormProps {
       education?: Education;
       open: boolean;
       onClose: () => void;
       onSave: (education: Education) => void;
     }
     
     export function EducationForm({
       education,
       open,
       onClose,
       onSave
     }: EducationFormProps) {
       const t = useTranslations('cv');
       
       const [formData, setFormData] = useState<Partial<Education>>(
         education || {
           id: generateId(),
           degree: '',
           institution: '',
           location: '',
           start_date: '',
           end_date: '',
           gpa: '',
           description: ''
         }
       );
       
       const handleChange = (field: keyof Education, value: string) => {
         setFormData(prev => ({ ...prev, [field]: value }));
       };
       
       const handleSubmit = () => {
         onSave(formData as Education);
         onClose();
       };
       
       return (
         <Dialog open={open} onOpenChange={onClose}>
           <DialogContent className="max-w-lg">
             <DialogHeader>
               <DialogTitle>
                 {education ? t('edit_education') : t('add_education')}
               </DialogTitle>
             </DialogHeader>
             
             <div className="grid gap-4 py-4">
               <div className="grid gap-2">
                 <Label htmlFor="degree">{t('degree')} *</Label>
                 <Input
                   id="degree"
                   value={formData.degree || ''}
                   onChange={(e) => handleChange('degree', e.target.value)}
                   placeholder={t('degree_placeholder')}
                 />
               </div>
               
               <div className="grid gap-2">
                 <Label htmlFor="institution">{t('institution')} *</Label>
                 <Input
                   id="institution"
                   value={formData.institution || ''}
                   onChange={(e) => handleChange('institution', e.target.value)}
                   placeholder={t('institution_placeholder')}
                 />
               </div>
               
               <div className="grid grid-cols-2 gap-4">
                 <div className="grid gap-2">
                   <Label htmlFor="location">{t('location')}</Label>
                   <Input
                     id="location"
                     value={formData.location || ''}
                     onChange={(e) => handleChange('location', e.target.value)}
                   />
                 </div>
                 <div className="grid gap-2">
                   <Label htmlFor="gpa">{t('gpa')}</Label>
                   <Input
                     id="gpa"
                     value={formData.gpa || ''}
                     onChange={(e) => handleChange('gpa', e.target.value)}
                     placeholder="3.8/4.0"
                   />
                 </div>
               </div>
               
               <div className="grid grid-cols-2 gap-4">
                 <div className="grid gap-2">
                   <Label htmlFor="start_date">{t('start_date')}</Label>
                   <Input
                     id="start_date"
                     type="month"
                     value={formData.start_date || ''}
                     onChange={(e) => handleChange('start_date', e.target.value)}
                   />
                 </div>
                 <div className="grid gap-2">
                   <Label htmlFor="end_date">{t('end_date')}</Label>
                   <Input
                     id="end_date"
                     type="month"
                     value={formData.end_date || ''}
                     onChange={(e) => handleChange('end_date', e.target.value)}
                   />
                 </div>
               </div>
               
               <div className="grid gap-2">
                 <Label htmlFor="description">{t('description')}</Label>
                 <Textarea
                   id="description"
                   value={formData.description || ''}
                   onChange={(e) => handleChange('description', e.target.value)}
                   rows={3}
                 />
               </div>
             </div>
             
             <DialogFooter>
               <Button variant="outline" onClick={onClose}>
                 {t('cancel')}
               </Button>
               <Button onClick={handleSubmit}>
                 {t('save')}
               </Button>
             </DialogFooter>
           </DialogContent>
         </Dialog>
       );
     }
     ```
  
  6. Create SkillsEditor.tsx:
     ```typescript
     // ============================================
     // [F113] src/components/cv/SkillsEditor.tsx
     // ============================================
     
     'use client';
     
     import { useState, useCallback } from 'react';
     import { useTranslations } from 'next-intl';
     import { Input } from '@/components/ui/input';
     import { Badge } from '@/components/ui/badge';
     import { X, Plus } from 'lucide-react';
     import { cn } from '@/lib/utils';
     
     interface SkillsEditorProps {
       skills: string[];
       onChange: (skills: string[]) => void;
       disabled?: boolean;
       className?: string;
     }
     
     export function SkillsEditor({
       skills,
       onChange,
       disabled = false,
       className
     }: SkillsEditorProps) {
       const t = useTranslations('cv');
       const [inputValue, setInputValue] = useState('');
       
       const addSkill = useCallback(() => {
         const skill = inputValue.trim();
         if (skill && !skills.includes(skill)) {
           onChange([...skills, skill]);
           setInputValue('');
         }
       }, [inputValue, skills, onChange]);
       
       const removeSkill = useCallback((skillToRemove: string) => {
         onChange(skills.filter(s => s !== skillToRemove));
       }, [skills, onChange]);
       
       const handleKeyDown = (e: React.KeyboardEvent) => {
         if (e.key === 'Enter') {
           e.preventDefault();
           addSkill();
         }
       };
       
       return (
         <div className={cn('space-y-3', className)}>
           <div className="flex gap-2">
             <Input
               value={inputValue}
               onChange={(e) => setInputValue(e.target.value)}
               onKeyDown={handleKeyDown}
               placeholder={t('add_skill_placeholder')}
               disabled={disabled}
               className="flex-1"
             />
             <button
               onClick={addSkill}
               disabled={disabled || !inputValue.trim()}
               className="px-3 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 disabled:opacity-50"
             >
               <Plus className="h-4 w-4" />
             </button>
           </div>
           
           <div className="flex flex-wrap gap-2">
             {skills.map((skill) => (
               <Badge
                 key={skill}
                 variant="secondary"
                 className="px-3 py-1 text-sm"
               >
                 {skill}
                 {!disabled && (
                   <button
                     onClick={() => removeSkill(skill)}
                     className="ml-2 hover:text-destructive"
                   >
                     <X className="h-3 w-3" />
                   </button>
                 )}
               </Badge>
             ))}
             {skills.length === 0 && (
               <span className="text-sm text-muted-foreground">
                 {t('no_skills_added')}
               </span>
             )}
           </div>
         </div>
       );
     }
     ```
  
  7. Create CVFieldDisplay.tsx:
     ```typescript
     // ============================================
     // [F042] src/components/cv/CVFieldDisplay.tsx
     // ============================================
     
     'use client';
     
     import { useState } from 'react';
     import { useTranslations } from 'next-intl';
     import { ComprehensiveCV, CVFieldStatus, WorkExperience, Education } from '@/lib/types';
     import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
     import { Button } from '@/components/ui/button';
     import { FieldStatusBadge } from './FieldStatusBadge';
     import { ConfidenceIndicator } from './ConfidenceIndicator';
     import { PersonalInfoForm } from './PersonalInfoForm';
     import { WorkExperienceForm } from './WorkExperienceForm';
     import { EducationForm } from './EducationForm';
     import { SkillsEditor } from './SkillsEditor';
     import {
       User, Briefcase, GraduationCap, Code, Award, Languages, FolderOpen,
       Pencil, Plus, Trash2
     } from 'lucide-react';
     import { cn } from '@/lib/utils';
     
     interface CVFieldDisplayProps {
       cv: Partial<ComprehensiveCV>;
       fieldStatuses: CVFieldStatus[];
       confidence: number;
       onUpdate: (updates: Partial<ComprehensiveCV>) => void;
       className?: string;
     }
     
     export function CVFieldDisplay({
       cv,
       fieldStatuses,
       confidence,
       onUpdate,
       className
     }: CVFieldDisplayProps) {
       const t = useTranslations('cv');
       
       // Edit dialogs state
       const [editingPersonalInfo, setEditingPersonalInfo] = useState(false);
       const [editingExperience, setEditingExperience] = useState<WorkExperience | null>(null);
       const [addingExperience, setAddingExperience] = useState(false);
       const [editingEducation, setEditingEducation] = useState<Education | null>(null);
       const [addingEducation, setAddingEducation] = useState(false);
       
       // Helper to check if a field is complete
       const isFieldComplete = (fieldName: string) => {
         return fieldStatuses.find(s => s.field_name === fieldName)?.is_complete ?? false;
       };
       
       // Calculate completion stats
       const completeCount = fieldStatuses.filter(s => s.is_complete).length;
       const totalCount = fieldStatuses.length;
       const completionPercent = totalCount > 0 ? Math.round((completeCount / totalCount) * 100) : 0;
       
       // Update handlers
       const handlePersonalInfoSave = (info: any) => {
         onUpdate({ personal_info: info });
       };
       
       const handleExperienceSave = (exp: WorkExperience) => {
         const current = cv.work_experience || [];
         const index = current.findIndex(e => e.id === exp.id);
         if (index >= 0) {
           const updated = [...current];
           updated[index] = exp;
           onUpdate({ work_experience: updated });
         } else {
           onUpdate({ work_experience: [...current, exp] });
         }
         setEditingExperience(null);
         setAddingExperience(false);
       };
       
       const handleExperienceDelete = (id: string) => {
         onUpdate({
           work_experience: (cv.work_experience || []).filter(e => e.id !== id)
         });
       };
       
       const handleEducationSave = (edu: Education) => {
         const current = cv.education || [];
         const index = current.findIndex(e => e.id === edu.id);
         if (index >= 0) {
           const updated = [...current];
           updated[index] = edu;
           onUpdate({ education: updated });
         } else {
           onUpdate({ education: [...current, edu] });
         }
         setEditingEducation(null);
         setAddingEducation(false);
       };
       
       const handleEducationDelete = (id: string) => {
         onUpdate({
           education: (cv.education || []).filter(e => e.id !== id)
         });
       };
       
       const handleSkillsChange = (skills: string[]) => {
         onUpdate({ skills });
       };
       
       return (
         <div className={cn('space-y-6', className)}>
           {/* Summary Header */}
           <Card>
             <CardContent className="py-4">
               <div className="flex items-center justify-between flex-wrap gap-4">
                 <div>
                   <h3 className="font-semibold text-lg">{t('extraction_summary')}</h3>
                   <p className="text-sm text-muted-foreground">
                     {t('fields_complete', { count: completeCount, total: totalCount })}
                   </p>
                 </div>
                 <div className="flex items-center gap-4">
                   <div className="w-32 h-2 bg-muted rounded-full overflow-hidden">
                     <div 
                       className="h-full bg-primary transition-all" 
                       style={{ width: `${completionPercent}%` }}
                     />
                   </div>
                   <ConfidenceIndicator confidence={confidence} />
                 </div>
               </div>
             </CardContent>
           </Card>
           
           {/* Personal Info */}
           <Card>
             <CardHeader className="flex flex-row items-center justify-between">
               <CardTitle className="flex items-center gap-2 text-lg">
                 <User className="h-5 w-5" />
                 {t('personal_info')}
               </CardTitle>
               <div className="flex items-center gap-2">
                 <FieldStatusBadge isComplete={isFieldComplete('personal_info.full_name')} />
                 <Button variant="ghost" size="sm" onClick={() => setEditingPersonalInfo(true)}>
                   <Pencil className="h-4 w-4" />
                 </Button>
               </div>
             </CardHeader>
             <CardContent>
               <dl className="grid grid-cols-2 gap-4 text-sm">
                 <div>
                   <dt className="text-muted-foreground">{t('full_name')}</dt>
                   <dd className="font-medium">{cv.personal_info?.full_name || '—'}</dd>
                 </div>
                 <div>
                   <dt className="text-muted-foreground">{t('email')}</dt>
                   <dd>{cv.personal_info?.email || '—'}</dd>
                 </div>
                 <div>
                   <dt className="text-muted-foreground">{t('phone')}</dt>
                   <dd>{cv.personal_info?.phone || '—'}</dd>
                 </div>
                 <div>
                   <dt className="text-muted-foreground">{t('location')}</dt>
                   <dd>{cv.personal_info?.location || '—'}</dd>
                 </div>
               </dl>
               {cv.personal_info?.summary && (
                 <div className="mt-4">
                   <dt className="text-muted-foreground text-sm">{t('summary')}</dt>
                   <dd className="mt-1 text-sm">{cv.personal_info.summary}</dd>
                 </div>
               )}
             </CardContent>
           </Card>
           
           {/* Work Experience */}
           <Card>
             <CardHeader className="flex flex-row items-center justify-between">
               <CardTitle className="flex items-center gap-2 text-lg">
                 <Briefcase className="h-5 w-5" />
                 {t('work_experience')}
               </CardTitle>
               <div className="flex items-center gap-2">
                 <FieldStatusBadge isComplete={isFieldComplete('work_experience')} />
                 <Button variant="ghost" size="sm" onClick={() => setAddingExperience(true)}>
                   <Plus className="h-4 w-4" />
                 </Button>
               </div>
             </CardHeader>
             <CardContent>
               {(cv.work_experience || []).length > 0 ? (
                 <div className="space-y-4">
                   {cv.work_experience!.map((exp) => (
                     <div 
                       key={exp.id} 
                       className="p-4 bg-muted/50 rounded-lg group relative"
                     >
                       <div className="absolute right-2 top-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-1">
                         <Button 
                           variant="ghost" 
                           size="sm"
                           onClick={() => setEditingExperience(exp)}
                         >
                           <Pencil className="h-3 w-3" />
                         </Button>
                         <Button 
                           variant="ghost" 
                           size="sm"
                           onClick={() => handleExperienceDelete(exp.id)}
                         >
                           <Trash2 className="h-3 w-3 text-destructive" />
                         </Button>
                       </div>
                       <h4 className="font-semibold">{exp.job_title}</h4>
                       <p className="text-sm text-muted-foreground">
                         {exp.company} {exp.location && `• ${exp.location}`}
                       </p>
                       <p className="text-xs text-muted-foreground mt-1">
                         {exp.start_date} — {exp.is_current ? t('present') : exp.end_date}
                       </p>
                       {exp.description && (
                         <p className="text-sm mt-2">{exp.description}</p>
                       )}
                     </div>
                   ))}
                 </div>
               ) : (
                 <p className="text-sm text-muted-foreground">{t('no_experience_added')}</p>
               )}
             </CardContent>
           </Card>
           
           {/* Education */}
           <Card>
             <CardHeader className="flex flex-row items-center justify-between">
               <CardTitle className="flex items-center gap-2 text-lg">
                 <GraduationCap className="h-5 w-5" />
                 {t('education')}
               </CardTitle>
               <div className="flex items-center gap-2">
                 <FieldStatusBadge isComplete={isFieldComplete('education')} />
                 <Button variant="ghost" size="sm" onClick={() => setAddingEducation(true)}>
                   <Plus className="h-4 w-4" />
                 </Button>
               </div>
             </CardHeader>
             <CardContent>
               {(cv.education || []).length > 0 ? (
                 <div className="space-y-4">
                   {cv.education!.map((edu) => (
                     <div 
                       key={edu.id} 
                       className="p-4 bg-muted/50 rounded-lg group relative"
                     >
                       <div className="absolute right-2 top-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-1">
                         <Button 
                           variant="ghost" 
                           size="sm"
                           onClick={() => setEditingEducation(edu)}
                         >
                           <Pencil className="h-3 w-3" />
                         </Button>
                         <Button 
                           variant="ghost" 
                           size="sm"
                           onClick={() => handleEducationDelete(edu.id)}
                         >
                           <Trash2 className="h-3 w-3 text-destructive" />
                         </Button>
                       </div>
                       <h4 className="font-semibold">{edu.degree}</h4>
                       <p className="text-sm text-muted-foreground">{edu.institution}</p>
                       <p className="text-xs text-muted-foreground mt-1">
                         {edu.start_date} — {edu.end_date}
                         {edu.gpa && ` • GPA: ${edu.gpa}`}
                       </p>
                     </div>
                   ))}
                 </div>
               ) : (
                 <p className="text-sm text-muted-foreground">{t('no_education_added')}</p>
               )}
             </CardContent>
           </Card>
           
           {/* Skills */}
           <Card>
             <CardHeader className="flex flex-row items-center justify-between">
               <CardTitle className="flex items-center gap-2 text-lg">
                 <Code className="h-5 w-5" />
                 {t('skills')}
               </CardTitle>
               <FieldStatusBadge isComplete={is




بنویس

claude-opus-4-5-20251101
درست می‌گویی! اصلاح می‌کنم.
استخراج فیلدهای CV با regex کار حرفه‌ای نیست. باید از AI استفاده شود.

مشکل و راه‌حل
text

❌ روش قبلی (B10):
   متن خام CV → Regex Patterns → فیلدهای استخراج‌شده
   مشکلات:
   - CV ها فرمت‌های بسیار متنوعی دارند
   - Regex نمی‌تواند معنا را بفهمد
   - زبان‌های مختلف را ساپورت نمی‌کند
   - دقت پایین

✅ روش جدید:
   متن خام CV → AI Prompt → فیلدهای استخراج‌شده (JSON)
   مزایا:
   - درک معنایی محتوا
   - انعطاف در فرمت‌های مختلف
   - پشتیبانی از همه زبان‌ها
   - دقت بالا
تغییرات در معماری
text

قبل:
┌─────────┐    ┌──────────────┐    ┌─────────────┐
│ CV File │───▶│ Regex Parser │───▶│ Structured  │
│ (docx)  │    │ (B10)        │    │ CV Fields   │
└─────────┘    └──────────────┘    └─────────────┘

بعد:
┌─────────┐    ┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ CV File │───▶│ Text Parser │───▶│ AI Extractor │───▶│ Structured  │
│ (docx)  │    │ (B09)       │    │ (B10-NEW)    │    │ CV Fields   │
└─────────┘    └─────────────┘    └──────────────┘    └─────────────┘
                                         │
                                         ▼
                                  ┌──────────────┐
                                  │ User's AI    │
                                  │ API Key      │
                                  └──────────────┘
وابستگی جدید
مشکل: برای استخراج CV با AI، نیاز به API Key داریم. ولی مدیریت API Key در بلوک‌های B18-B22 بود!

راه‌حل: ترتیب بلوک‌ها را تغییر می‌دهیم:

text

ترتیب قبلی:
B09 → B10 (Regex) → B11 → B12 → B13 → B14 (CV کامل)
                                          ↓
B18 → B19 → B20 → B21 → B22 (AI Setup)

ترتیب جدید:
B09 (File Parsers)
     ↓
B10-NEW (AI Provider Interface) ← از B19 منتقل شد
     ↓
B11-NEW (AI Key Management) ← از B18, B21, B22 منتقل شد
     ↓
B12-NEW (AI CV Extractor) ← جایگزین B10 قدیم
     ↓
B13 → B14 → B15 → B16 (CV Components & Page)
بلوک‌های اصلاح‌شده
B10.yaml — AI Provider Interface (جدید — از B19 منتقل شد)
YAML

# blocks/B10.yaml

id: B10
name: "AI Provider Interface (Abstract Layer)"
phase: 1
phase_name: "CV Management"

goal: |
  Create an abstract interface for AI providers (OpenAI, Anthropic, Google).
  This allows the app to work with multiple AI services through a unified API.
  This block is moved earlier because AI is needed for CV field extraction.

dependencies: [B01, B02, B03, B04]

files_to_create:
  - id: F066
    path: "src/lib/ai/ai-provider.ts"
    description: "Abstract AI Provider interface"

  - id: F067
    path: "src/lib/ai/openai-provider.ts"
    description: "OpenAI implementation"

  - id: F068
    path: "src/lib/ai/anthropic-provider.ts"
    description: "Anthropic (Claude) implementation"

  - id: F069
    path: "src/lib/ai/google-ai-provider.ts"
    description: "Google AI (Gemini) implementation"

  - id: F070
    path: "src/lib/ai/ai-factory.ts"
    description: "Factory to create AI provider instances"

  - id: F104
    path: "src/lib/ai/index.ts"
    description: "Export all AI modules"

files_to_modify: []

files_available:
  - id: F001
    path: "package.json"
    from_block: B01
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04

commands: []

instructions: |
  1. Create ai-provider.ts - The abstract interface:
     ```typescript
     // ============================================
     // [F066] src/lib/ai/ai-provider.ts
     // Abstract AI Provider Interface
     // ============================================
     
     import { AIProviderName, AIModel, AIChatMessage } from '@/lib/types';
     
     export interface AIProviderConfig {
       apiKey: string;
       model?: string;
       temperature?: number;
       maxTokens?: number;
     }
     
     export interface AIValidationResult {
       valid: boolean;
       error?: string;
       models?: AIModel[];
       balance?: string | null;
     }
     
     export interface AICompletionOptions {
       model: string;
       messages: AIChatMessage[];
       temperature?: number;
       maxTokens?: number;
       jsonMode?: boolean;  // Request JSON output
     }
     
     export interface AIProvider {
       readonly providerName: AIProviderName;
       
       // Validate API key and get available models
       validateKey(apiKey: string): Promise<AIValidationResult>;
       
       // Get list of available models
       getModels(apiKey: string): Promise<AIModel[]>;
       
       // Simple completion (non-streaming)
       complete(config: AIProviderConfig, options: AICompletionOptions): Promise<string>;
       
       // Streaming completion
       streamComplete(
         config: AIProviderConfig,
         options: AICompletionOptions,
         onChunk: (chunk: string) => void
       ): Promise<string>;
       
       // Parse JSON response (with error handling)
       parseJsonResponse<T>(response: string): T | null;
     }
     
     // Base class with common functionality
     export abstract class BaseAIProvider implements AIProvider {
       abstract readonly providerName: AIProviderName;
       
       abstract validateKey(apiKey: string): Promise<AIValidationResult>;
       abstract getModels(apiKey: string): Promise<AIModel[]>;
       abstract complete(config: AIProviderConfig, options: AICompletionOptions): Promise<string>;
       abstract streamComplete(
         config: AIProviderConfig,
         options: AICompletionOptions,
         onChunk: (chunk: string) => void
       ): Promise<string>;
       
       parseJsonResponse<T>(response: string): T | null {
         try {
           // Try to extract JSON from response
           // Handle cases where AI wraps JSON in markdown code blocks
           let jsonStr = response;
           
           // Remove markdown code blocks if present
           const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
           if (jsonMatch) {
             jsonStr = jsonMatch[1];
           }
           
           return JSON.parse(jsonStr) as T;
         } catch (e) {
           console.error('Failed to parse JSON response:', e);
           return null;
         }
       }
     }
     ```
  
  2. Create openai-provider.ts:
     ```typescript
     // ============================================
     // [F067] src/lib/ai/openai-provider.ts
     // ============================================
     
     import OpenAI from 'openai';
     import { BaseAIProvider, AIProviderConfig, AICompletionOptions, AIValidationResult } from './ai-provider';
     import { AIProviderName, AIModel } from '@/lib/types';
     
     export class OpenAIProvider extends BaseAIProvider {
       readonly providerName: AIProviderName = 'openai';
       
       private createClient(apiKey: string): OpenAI {
         return new OpenAI({ apiKey });
       }
       
       async validateKey(apiKey: string): Promise<AIValidationResult> {
         try {
           const client = this.createClient(apiKey);
           const models = await client.models.list();
           
           const availableModels: AIModel[] = models.data
             .filter(m => m.id.includes('gpt'))
             .map(m => ({
               model_id: m.id,
               model_name: m.id,
               provider: 'openai' as AIProviderName
             }));
           
           return {
             valid: true,
             models: availableModels
           };
         } catch (error: any) {
           return {
             valid: false,
             error: error.message || 'Invalid API key'
           };
         }
       }
       
       async getModels(apiKey: string): Promise<AIModel[]> {
         const result = await this.validateKey(apiKey);
         return result.models || [];
       }
       
       async complete(config: AIProviderConfig, options: AICompletionOptions): Promise<string> {
         const client = this.createClient(config.apiKey);
         
         const response = await client.chat.completions.create({
           model: options.model,
           messages: options.messages.map(m => ({
             role: m.role as 'system' | 'user' | 'assistant',
             content: m.content
           })),
           temperature: options.temperature ?? config.temperature ?? 0.7,
           max_tokens: options.maxTokens ?? config.maxTokens ?? 4096,
           response_format: options.jsonMode ? { type: 'json_object' } : undefined
         });
         
         return response.choices[0]?.message?.content || '';
       }
       
       async streamComplete(
         config: AIProviderConfig,
         options: AICompletionOptions,
         onChunk: (chunk: string) => void
       ): Promise<string> {
         const client = this.createClient(config.apiKey);
         
         const stream = await client.chat.completions.create({
           model: options.model,
           messages: options.messages.map(m => ({
             role: m.role as 'system' | 'user' | 'assistant',
             content: m.content
           })),
           temperature: options.temperature ?? config.temperature ?? 0.7,
           max_tokens: options.maxTokens ?? config.maxTokens ?? 4096,
           stream: true
         });
         
         let fullResponse = '';
         for await (const chunk of stream) {
           const content = chunk.choices[0]?.delta?.content || '';
           fullResponse += content;
           onChunk(content);
         }
         
         return fullResponse;
       }
     }
     ```
  
  3. Create anthropic-provider.ts:
     ```typescript
     // ============================================
     // [F068] src/lib/ai/anthropic-provider.ts
     // ============================================
     
     import Anthropic from '@anthropic-ai/sdk';
     import { BaseAIProvider, AIProviderConfig, AICompletionOptions, AIValidationResult } from './ai-provider';
     import { AIProviderName, AIModel } from '@/lib/types';
     
     export class AnthropicProvider extends BaseAIProvider {
       readonly providerName: AIProviderName = 'anthropic';
       
       // Known Claude models (Anthropic doesn't have a models list API)
       private readonly KNOWN_MODELS: AIModel[] = [
         { model_id: 'claude-3-5-sonnet-20241022', model_name: 'Claude 3.5 Sonnet', provider: 'anthropic' },
         { model_id: 'claude-3-5-haiku-20241022', model_name: 'Claude 3.5 Haiku', provider: 'anthropic' },
         { model_id: 'claude-3-opus-20240229', model_name: 'Claude 3 Opus', provider: 'anthropic' },
         { model_id: 'claude-3-sonnet-20240229', model_name: 'Claude 3 Sonnet', provider: 'anthropic' },
         { model_id: 'claude-3-haiku-20240307', model_name: 'Claude 3 Haiku', provider: 'anthropic' },
       ];
       
       private createClient(apiKey: string): Anthropic {
         return new Anthropic({ apiKey });
       }
       
       async validateKey(apiKey: string): Promise<AIValidationResult> {
         try {
           const client = this.createClient(apiKey);
           
           // Make a minimal API call to verify the key
           await client.messages.create({
             model: 'claude-3-haiku-20240307',
             max_tokens: 10,
             messages: [{ role: 'user', content: 'Hi' }]
           });
           
           return {
             valid: true,
             models: this.KNOWN_MODELS
           };
         } catch (error: any) {
           return {
             valid: false,
             error: error.message || 'Invalid API key'
           };
         }
       }
       
       async getModels(apiKey: string): Promise<AIModel[]> {
         const result = await this.validateKey(apiKey);
         return result.valid ? this.KNOWN_MODELS : [];
       }
       
       async complete(config: AIProviderConfig, options: AICompletionOptions): Promise<string> {
         const client = this.createClient(config.apiKey);
         
         // Extract system message if present
         const systemMsg = options.messages.find(m => m.role === 'system');
         const otherMsgs = options.messages.filter(m => m.role !== 'system');
         
         const response = await client.messages.create({
           model: options.model,
           max_tokens: options.maxTokens ?? config.maxTokens ?? 4096,
           system: systemMsg?.content,
           messages: otherMsgs.map(m => ({
             role: m.role as 'user' | 'assistant',
             content: m.content
           }))
         });
         
         // Extract text from response
         const textBlock = response.content.find(c => c.type === 'text');
         return textBlock?.text || '';
       }
       
       async streamComplete(
         config: AIProviderConfig,
         options: AICompletionOptions,
         onChunk: (chunk: string) => void
       ): Promise<string> {
         const client = this.createClient(config.apiKey);
         
         const systemMsg = options.messages.find(m => m.role === 'system');
         const otherMsgs = options.messages.filter(m => m.role !== 'system');
         
         const stream = await client.messages.stream({
           model: options.model,
           max_tokens: options.maxTokens ?? config.maxTokens ?? 4096,
           system: systemMsg?.content,
           messages: otherMsgs.map(m => ({
             role: m.role as 'user' | 'assistant',
             content: m.content
           }))
         });
         
         let fullResponse = '';
         for await (const event of stream) {
           if (event.type === 'content_block_delta' && event.delta.type === 'text_delta') {
             const text = event.delta.text;
             fullResponse += text;
             onChunk(text);
           }
         }
         
         return fullResponse;
       }
     }
     ```
  
  4. Create google-ai-provider.ts:
     ```typescript
     // ============================================
     // [F069] src/lib/ai/google-ai-provider.ts
     // ============================================
     
     import { GoogleGenerativeAI } from '@google/generative-ai';
     import { BaseAIProvider, AIProviderConfig, AICompletionOptions, AIValidationResult } from './ai-provider';
     import { AIProviderName, AIModel } from '@/lib/types';
     
     export class GoogleAIProvider extends BaseAIProvider {
       readonly providerName: AIProviderName = 'google';
       
       private readonly KNOWN_MODELS: AIModel[] = [
         { model_id: 'gemini-1.5-pro', model_name: 'Gemini 1.5 Pro', provider: 'google' },
         { model_id: 'gemini-1.5-flash', model_name: 'Gemini 1.5 Flash', provider: 'google' },
         { model_id: 'gemini-1.0-pro', model_name: 'Gemini 1.0 Pro', provider: 'google' },
       ];
       
       private createClient(apiKey: string): GoogleGenerativeAI {
         return new GoogleGenerativeAI(apiKey);
       }
       
       async validateKey(apiKey: string): Promise<AIValidationResult> {
         try {
           const client = this.createClient(apiKey);
           const model = client.getGenerativeModel({ model: 'gemini-1.5-flash' });
           
           // Make a minimal API call to verify
           await model.generateContent('Hi');
           
           return {
             valid: true,
             models: this.KNOWN_MODELS
           };
         } catch (error: any) {
           return {
             valid: false,
             error: error.message || 'Invalid API key'
           };
         }
       }
       
       async getModels(apiKey: string): Promise<AIModel[]> {
         const result = await this.validateKey(apiKey);
         return result.valid ? this.KNOWN_MODELS : [];
       }
       
       async complete(config: AIProviderConfig, options: AICompletionOptions): Promise<string> {
         const client = this.createClient(config.apiKey);
         const model = client.getGenerativeModel({ 
           model: options.model,
           generationConfig: {
             temperature: options.temperature ?? config.temperature ?? 0.7,
             maxOutputTokens: options.maxTokens ?? config.maxTokens ?? 4096,
           }
         });
         
         // Convert messages to Gemini format
         const history = options.messages
           .filter(m => m.role !== 'system')
           .slice(0, -1)
           .map(m => ({
             role: m.role === 'assistant' ? 'model' : 'user',
             parts: [{ text: m.content }]
           }));
         
         const systemInstruction = options.messages.find(m => m.role === 'system')?.content;
         const lastMessage = options.messages[options.messages.length - 1];
         
         const chat = model.startChat({
           history,
           systemInstruction
         });
         
         const result = await chat.sendMessage(lastMessage.content);
         return result.response.text();
       }
       
       async streamComplete(
         config: AIProviderConfig,
         options: AICompletionOptions,
         onChunk: (chunk: string) => void
       ): Promise<string> {
         const client = this.createClient(config.apiKey);
         const model = client.getGenerativeModel({ 
           model: options.model,
           generationConfig: {
             temperature: options.temperature ?? config.temperature ?? 0.7,
             maxOutputTokens: options.maxTokens ?? config.maxTokens ?? 4096,
           }
         });
         
         const history = options.messages
           .filter(m => m.role !== 'system')
           .slice(0, -1)
           .map(m => ({
             role: m.role === 'assistant' ? 'model' : 'user',
             parts: [{ text: m.content }]
           }));
         
         const systemInstruction = options.messages.find(m => m.role === 'system')?.content;
         const lastMessage = options.messages[options.messages.length - 1];
         
         const chat = model.startChat({
           history,
           systemInstruction
         });
         
         const result = await chat.sendMessageStream(lastMessage.content);
         
         let fullResponse = '';
         for await (const chunk of result.stream) {
           const text = chunk.text();
           fullResponse += text;
           onChunk(text);
         }
         
         return fullResponse;
       }
     }
     ```
  
  5. Create ai-factory.ts:
     ```typescript
     // ============================================
     // [F070] src/lib/ai/ai-factory.ts
     // ============================================
     
     import { AIProviderName } from '@/lib/types';
     import { AIProvider } from './ai-provider';
     import { OpenAIProvider } from './openai-provider';
     import { AnthropicProvider } from './anthropic-provider';
     import { GoogleAIProvider } from './google-ai-provider';
     
     const providers: Record<AIProviderName, AIProvider> = {
       openai: new OpenAIProvider(),
       anthropic: new AnthropicProvider(),
       google: new GoogleAIProvider(),
     };
     
     export function getAIProvider(name: AIProviderName): AIProvider {
       const provider = providers[name];
       if (!provider) {
         throw new Error(`Unknown AI provider: ${name}`);
       }
       return provider;
     }
     
     export function getAllProviders(): AIProvider[] {
       return Object.values(providers);
     }
     
     export function getProviderNames(): AIProviderName[] {
       return Object.keys(providers) as AIProviderName[];
     }
     ```
  
  6. Create index.ts:
     ```typescript
     // ============================================
     // [F104] src/lib/ai/index.ts
     // ============================================
     
     export * from './ai-provider';
     export * from './openai-provider';
     export * from './anthropic-provider';
     export * from './google-ai-provider';
     export * from './ai-factory';
     ```

checkpoint_tests:
  - id: T01
    description: "All AI provider files exist"
    type: "files_exist"
    files:
      - "src/lib/ai/ai-provider.ts"
      - "src/lib/ai/openai-provider.ts"
      - "src/lib/ai/anthropic-provider.ts"
      - "src/lib/ai/google-ai-provider.ts"
      - "src/lib/ai/ai-factory.ts"
      - "src/lib/ai/index.ts"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "ai-provider.ts exports interface and base class"
    type: "grep"
    file: "src/lib/ai/ai-provider.ts"
    patterns:
      - "export interface AIProvider"
      - "export abstract class BaseAIProvider"
      - "validateKey"
      - "complete"
      - "streamComplete"
      - "parseJsonResponse"

  - id: T04
    description: "All providers extend BaseAIProvider"
    type: "grep"
    file: "src/lib/ai/openai-provider.ts"
    patterns:
      - "extends BaseAIProvider"
      - "OpenAI"

  - id: T05
    description: "Factory exports getAIProvider"
    type: "grep"
    file: "src/lib/ai/ai-factory.ts"
    patterns:
      - "export function getAIProvider"
      - "openai"
      - "anthropic"
      - "google"

  - id: T06
    description: "index.ts exports all modules"
    type: "grep"
    file: "src/lib/ai/index.ts"
    patterns:
      - "ai-provider"
      - "ai-factory"
      - "openai-provider"
      - "anthropic-provider"
      - "google-ai-provider"

max_retries: 3
B11.yaml — رمزنگاری و مدیریت API Key (جدید)
YAML

# blocks/B11.yaml

id: B11
name: "API Key Encryption and Storage"
phase: 1
phase_name: "CV Management"

goal: |
  Create secure storage for AI API keys with encryption.
  Users can add, validate, and manage their API keys for different AI providers.
  Keys are encrypted before storing in Supabase.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B10]

files_to_create:
  - id: F077
    path: "src/lib/encryption.ts"
    description: "Encryption/decryption utilities for API keys"

  - id: F105
    path: "src/app/api/ai/keys/route.ts"
    description: "API route for managing AI API keys"

  - id: F106
    path: "src/app/api/ai/validate/route.ts"
    description: "API route to validate an AI API key"

  - id: F081
    path: "src/hooks/useAIKeys.ts"
    description: "React hook for AI key management"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add AI key management translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add AI key management translations"

files_available:
  - id: F063
    path: "src/lib/supabase/client.ts"
    from_block: B06
  - id: F064
    path: "src/lib/supabase/server.ts"
    from_block: B06
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F090
    path: "src/context/AuthContext.tsx"
    from_block: B07
  - id: F066
    path: "src/lib/ai/ai-provider.ts"
    from_block: B10
  - id: F070
    path: "src/lib/ai/ai-factory.ts"
    from_block: B10

commands: []

instructions: |
  1. Create encryption.ts:
     ```typescript
     // ============================================
     // [F077] src/lib/encryption.ts
     // ============================================
     
     import CryptoJS from 'crypto-js';
     
     const SECRET_KEY = process.env.ENCRYPTION_SECRET_KEY || 'default-dev-key-change-in-prod';
     
     export function encrypt(text: string): string {
       return CryptoJS.AES.encrypt(text, SECRET_KEY).toString();
     }
     
     export function decrypt(encryptedText: string): string {
       const bytes = CryptoJS.AES.decrypt(encryptedText, SECRET_KEY);
       return bytes.toString(CryptoJS.enc.Utf8);
     }
     
     // For API keys, add extra validation
     export function encryptApiKey(apiKey: string): string {
       if (!apiKey || apiKey.trim().length === 0) {
         throw new Error('API key cannot be empty');
       }
       return encrypt(apiKey.trim());
     }
     
     export function decryptApiKey(encryptedKey: string): string {
       try {
         const decrypted = decrypt(encryptedKey);
         if (!decrypted) {
           throw new Error('Decryption failed');
         }
         return decrypted;
       } catch (error) {
         throw new Error('Failed to decrypt API key');
       }
     }
     ```
  
  2. Create api/ai/keys/route.ts:
     ```typescript
     // ============================================
     // [F105] src/app/api/ai/keys/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { encryptApiKey, decryptApiKey } from '@/lib/encryption';
     import { getAIProvider } from '@/lib/ai';
     import { AIProviderName, AIApiKey } from '@/lib/types';
     
     // GET - List all API keys for current user (without decrypted keys)
     export async function GET(request: NextRequest) {
       const supabase = createServerSupabaseClient();
       
       // Get current user (from dev auth or session)
       const userId = request.headers.get('x-user-id'); // Simplified for dev
       if (!userId) {
         return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
       }
       
       const { data, error } = await supabase
         .from('ai_api_keys')
         .select('id, provider_name, is_valid, available_models, token_balance, last_validated_at')
         .eq('user_id', userId);
       
       if (error) {
         return NextResponse.json({ error: error.message }, { status: 500 });
       }
       
       return NextResponse.json({ keys: data });
     }
     
     // POST - Add or update an API key
     export async function POST(request: NextRequest) {
       const supabase = createServerSupabaseClient();
       const userId = request.headers.get('x-user-id');
       
       if (!userId) {
         return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
       }
       
       const { provider_name, api_key } = await request.json();
       
       if (!provider_name || !api_key) {
         return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
       }
       
       // Validate the key
       const provider = getAIProvider(provider_name as AIProviderName);
       const validation = await provider.validateKey(api_key);
       
       // Encrypt the key
       const encryptedKey = encryptApiKey(api_key);
       
       // Upsert the key
       const { data, error } = await supabase
         .from('ai_api_keys')
         .upsert({
           user_id: userId,
           provider_name,
           api_key_encrypted: encryptedKey,
           is_valid: validation.valid,
           available_models: validation.models || [],
           token_balance: validation.balance,
           last_validated_at: new Date().toISOString()
         }, {
           onConflict: 'user_id,provider_name'
         })
         .select()
         .single();
       
       if (error) {
         return NextResponse.json({ error: error.message }, { status: 500 });
       }
       
       // Don't return the encrypted key
       const { api_key_encrypted, ...safeData } = data;
       
       return NextResponse.json({
         key: safeData,
         validation: {
           valid: validation.valid,
           error: validation.error,
           models: validation.models
         }
       });
     }
     
     // DELETE - Remove an API key
     export async function DELETE(request: NextRequest) {
       const supabase = createServerSupabaseClient();
       const userId = request.headers.get('x-user-id');
       const { searchParams } = new URL(request.url);
       const provider = searchParams.get('provider');
       
       if (!userId) {
         return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
       }
       
       if (!provider) {
         return NextResponse.json({ error: 'Provider required' }, { status: 400 });
       }
       
       const { error } = await supabase
         .from('ai_api_keys')
         .delete()
         .eq('user_id', userId)
         .eq('provider_name', provider);
       
       if (error) {
         return NextResponse.json({ error: error.message }, { status: 500 });
       }
       
       return NextResponse.json({ success: true });
     }
     ```
  
  3. Create api/ai/validate/route.ts:
     ```typescript
     // ============================================
     // [F106] src/app/api/ai/validate/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { getAIProvider } from '@/lib/ai';
     import { AIProviderName } from '@/lib/types';
     
     // POST - Validate an API key without storing it
     export async function POST(request: NextRequest) {
       const { provider_name, api_key } = await request.json();
       
       if (!provider_name || !api_key) {
         return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
       }
       
       try {
         const provider = getAIProvider(provider_name as AIProviderName);
         const validation = await provider.validateKey(api_key);
         
         return NextResponse.json(validation);
       } catch (error: any) {
         return NextResponse.json({
           valid: false,
           error: error.message
         });
       }
     }
     ```
  
  4. Create hooks/useAIKeys.ts:
     ```typescript
     // ============================================
     // [F081] src/hooks/useAIKeys.ts
     // ============================================
     
     import { useState, useEffect, useCallback } from 'react';
     import { useAuth } from '@/context/AuthContext';
     import { AIProviderName, AIApiKey, AIModel } from '@/lib/types';
     
     interface StoredKey {
       id: string;
       provider_name: AIProviderName;
       is_valid: boolean;
       available_models: AIModel[];
       token_balance: string | null;
       last_validated_at: string | null;
     }
     
     export function useAIKeys() {
       const { user } = useAuth();
       const [keys, setKeys] = useState<StoredKey[]>([]);
       const [loading, setLoading] = useState(true);
       const [error, setError] = useState<string | null>(null);
       
       // Fetch keys on mount
       useEffect(() => {
         if (user) {
           fetchKeys();
         }
       }, [user]);
       
       const fetchKeys = useCallback(async () => {
         setLoading(true);
         setError(null);
         
         try {
           const res = await fetch('/api/ai/keys', {
             headers: { 'x-user-id': user?.id || '' }
           });
           const data = await res.json();
           
           if (data.error) {
             throw new Error(data.error);
           }
           
           setKeys(data.keys || []);
         } catch (err: any) {
           setError(err.message);
         } finally {
           setLoading(false);
         }
       }, [user]);
       
       const addKey = useCallback(async (provider: AIProviderName, apiKey: string) => {
         setError(null);
         
         try {
           const res = await fetch('/api/ai/keys', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'x-user-id': user?.id || ''
             },
             body: JSON.stringify({
               provider_name: provider,
               api_key: apiKey
             })
           });
           
           const data = await res.json();
           
           if (data.error) {
             throw new Error(data.error);
           }
           
           await fetchKeys();
           return data.validation;
         } catch (err: any) {
           setError(err.message);
           throw err;
         }
       }, [user, fetchKeys]);
       
       const removeKey = useCallback(async (provider: AIProviderName) => {
         try {
           await fetch(`/api/ai/keys?provider=${provider}`, {
             method: 'DELETE',
             headers: { 'x-user-id': user?.id || '' }
           });
           await fetchKeys();
         } catch (err: any) {
           setError(err.message);
         }
       }, [user, fetchKeys]);
       
       const validateKey = useCallback(async (provider: AIProviderName, apiKey: string) => {
         const res = await fetch('/api/ai/validate', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({
             provider_name: provider,
             api_key: apiKey
           })
         });
         return res.json();
       }, []);
       
       const getModelsForProvider = useCallback((provider: AIProviderName): AIModel[] => {
         const key = keys.find(k => k.provider_name === provider);
         return key?.available_models || [];
       }, [keys]);
       
       const hasValidKey = useCallback((provider: AIProviderName): boolean => {
         const key = keys.find(k => k.provider_name === provider);
         return key?.is_valid || false;
       }, [keys]);
       
       const getValidProviders = useCallback((): AIProviderName[] => {
         return keys.filter(k => k.is_valid).map(k => k.provider_name);
       }, [keys]);
       
       return {
         keys,
         loading,
         error,
         fetchKeys,
         addKey,
         removeKey,
         validateKey,
         getModelsForProvider,
         hasValidKey,
         getValidProviders
       };
     }
     ```
  
  5. Add translations to en.json under "ai_keys":
     - title, add_key, provider, api_key, validate, save, delete
     - status_valid, status_invalid, status_checking
     - key_saved, key_deleted, validation_failed
     - enter_api_key_placeholder
  
  6. Add same translations to fa.json

checkpoint_tests:
  - id: T01
    description: "All API key management files exist"
    type: "files_exist"
    files:
      - "src/lib/encryption.ts"
      - "src/app/api/ai/keys/route.ts"
      - "src/app/api/ai/validate/route.ts"
      - "src/hooks/useAIKeys.ts"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "encryption.ts exports encrypt/decrypt functions"
    type: "grep"
    file: "src/lib/encryption.ts"
    patterns:
      - "export function encrypt"
      - "export function decrypt"
      - "encryptApiKey"
      - "decryptApiKey"
      - "CryptoJS"

  - id: T04
    description: "Keys API route has all CRUD methods"
    type: "grep"
    file: "src/app/api/ai/keys/route.ts"
    patterns:
      - "export async function GET"
      - "export async function POST"
      - "export async function DELETE"
      - "encryptApiKey"

  - id: T05
    description: "useAIKeys hook exports all functions"
    type: "grep"
    file: "src/hooks/useAIKeys.ts"
    patterns:
      - "export function useAIKeys"
      - "addKey"
      - "removeKey"
      - "validateKey"
      - "getModelsForProvider"
      - "hasValidKey"

  - id: T06
    description: "English translations have ai_keys section"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "ai_keys"

max_retries: 3
B12.yaml — استخراج فیلدهای CV با AI (جدید)
YAML

# blocks/B12.yaml

id: B12
name: "AI-Powered CV Field Extraction"
phase: 1
phase_name: "CV Management"

goal: |
  Create a system that uses AI to extract structured fields from raw CV text.
  This replaces the regex-based approach with intelligent extraction.
  Includes prompts for CV parsing and handles the AI response.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B09, B10, B11]

files_to_create:
  - id: F074
    path: "src/lib/cv/cv-extractor.ts"
    description: "AI-powered CV field extraction logic"

  - id: F107
    path: "src/lib/cv/cv-extraction-prompt.ts"
    description: "Prompts for CV extraction"

  - id: F108
    path: "src/lib/cv/cv-validator.ts"
    description: "Validate and check completeness of extracted CV"

  - id: F109
    path: "src/lib/cv/index.ts"
    description: "Export all CV modules"

  - id: F110
    path: "src/app/api/cv/extract/route.ts"
    description: "API route for AI CV extraction"

files_to_modify:
  - id: F079
    path: "src/lib/types.ts"
    description: "Add CVExtractionResult type"

files_available:
  - id: F063
    path: "src/lib/supabase/client.ts"
    from_block: B06
  - id: F064
    path: "src/lib/supabase/server.ts"
    from_block: B06
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F066
    path: "src/lib/ai/ai-provider.ts"
    from_block: B10
  - id: F070
    path: "src/lib/ai/ai-factory.ts"
    from_block: B10
  - id: F077
    path: "src/lib/encryption.ts"
    from_block: B11
  - id: F072
    path: "src/lib/parsers/docx-parser.ts"
    from_block: B09
  - id: F073
    path: "src/lib/parsers/markdown-parser.ts"
    from_block: B09

commands: []

instructions: |
  1. Add to types.ts:
     ```typescript
     // Add these types to the existing types.ts file
     
     export interface CVExtractionResult {
       success: boolean;
       cv: Partial<ComprehensiveCV>;
       fieldStatuses: CVFieldStatus[];
       confidence: number;  // 0-100
       rawText: string;
       aiProvider: AIProviderName;
       aiModel: string;
       extractionNotes?: string;  // Any notes from AI about the extraction
     }
     
     export interface CVExtractionRequest {
       rawText: string;
       aiProvider: AIProviderName;
       aiModel: string;
       language?: 'en' | 'fa' | 'auto';
     }
     ```
  
  2. Create cv-extraction-prompt.ts:
     ```typescript
     // ============================================
     // [F107] src/lib/cv/cv-extraction-prompt.ts
     // ============================================
     
     export const CV_EXTRACTION_SYSTEM_PROMPT = `You are an expert CV/Resume parser. Your job is to extract structured information from CV text.

     You MUST respond with valid JSON only, no other text or markdown.

     The JSON structure must be:
     {
       "personal_info": {
         "full_name": "string or null",
         "email": "string or null",
         "phone": "string or null",
         "location": "string or null",
         "linkedin_url": "string or null",
         "website_url": "string or null",
         "summary": "string or null"
       },
       "work_experience": [
         {
           "id": "unique string",
           "job_title": "string",
           "company": "string",
           "location": "string or null",
           "start_date": "YYYY-MM or null",
           "end_date": "YYYY-MM or null (null if current)",
           "is_current": boolean,
           "description": "string",
           "achievements": ["string"]
         }
       ],
       "education": [
         {
           "id": "unique string",
           "degree": "string",
           "institution": "string",
           "location": "string or null",
           "start_date": "YYYY-MM or null",
           "end_date": "YYYY-MM or null",
           "gpa": "string or null",
           "description": "string or null"
         }
       ],
       "skills": ["string"],
       "certifications": [
         {
           "id": "unique string",
           "name": "string",
           "issuer": "string",
           "date_obtained": "YYYY-MM or null",
           "expiry_date": "YYYY-MM or null",
           "credential_url": "string or null"
         }
       ],
       "languages": [
         {
           "language": "string",
           "proficiency": "Native | Fluent | Advanced | Intermediate | Basic"
         }
       ],
       "projects": [
         {
           "id": "unique string",
           "name": "string",
           "description": "string",
           "url": "string or null"
         }
       ],
       "confidence": 0-100,
       "notes": "Any observations about the CV quality or missing information"
     }

     Rules:
     1. Extract ALL information you can find
     2. Use null for fields that are not present
     3. Generate unique IDs for list items (use simple strings like "work-1", "edu-1", etc.)
     4. Normalize dates to YYYY-MM format when possible
     5. If a date says "Present" or "Current", set is_current to true and end_date to null
     6. Extract achievements as separate items in the achievements array
     7. Be thorough - don't miss any information
     8. The confidence score should reflect how complete and clear the CV is
     9. Add any observations to the notes field`;
     
     export const CV_EXTRACTION_USER_PROMPT = (cvText: string) => 
       `Please parse the following CV/Resume and extract all structured information:

     ---CV TEXT START---
     ${cvText}
     ---CV TEXT END---

     Respond with JSON only.`;
     
     // Alternative prompt for unclear/short CVs
     export const CV_EXTRACTION_CLARIFICATION_PROMPT = (cvText: string, missingFields: string[]) =>
       `The CV appears to be missing some important information. Please try to extract what's available and note the missing fields.
     
     Missing fields: ${missingFields.join(', ')}
     
     CV Text:
     ${cvText}
     
     Respond with JSON only, using null for missing fields.`;
     ```
  
  3. Create cv-validator.ts:
     ```typescript
     // ============================================
     // [F108] src/lib/cv/cv-validator.ts
     // ============================================
     
     import { ComprehensiveCV, CVFieldStatus } from '@/lib/types';
     import { CV_REQUIRED_FIELDS } from '@/lib/constants';
     
     export function validateExtractedCV(cv: Partial<ComprehensiveCV>): CVFieldStatus[] {
       const statuses: CVFieldStatus[] = [];
       
       // Check personal info fields
       const personalFields = ['full_name', 'email', 'phone', 'summary'];
       for (const field of personalFields) {
         const value = cv.personal_info?.[field as keyof typeof cv.personal_info];
         statuses.push({
           field_name: `personal_info.${field}`,
           is_complete: Boolean(value && String(value).trim().length > 0),
           current_value: value || null
         });
       }
       
       // Check work experience
       statuses.push({
         field_name: 'work_experience',
         is_complete: (cv.work_experience?.length || 0) > 0,
         current_value: cv.work_experience || []
       });
       
       // Check education
       statuses.push({
         field_name: 'education',
         is_complete: (cv.education?.length || 0) > 0,
         current_value: cv.education || []
       });
       
       // Check skills
       statuses.push({
         field_name: 'skills',
         is_complete: (cv.skills?.length || 0) > 0,
         current_value: cv.skills || []
       });
       
       return statuses;
     }
     
     export function getMissingFields(statuses: CVFieldStatus[]): string[] {
       return statuses
         .filter(s => !s.is_complete)
         .map(s => s.field_name);
     }
     
     export function getCompletionPercentage(statuses: CVFieldStatus[]): number {
       if (statuses.length === 0) return 0;
       const complete = statuses.filter(s => s.is_complete).length;
       return Math.round((complete / statuses.length) * 100);
     }
     
     export function isMinimumViable(cv: Partial<ComprehensiveCV>): boolean {
       // A CV is minimally viable if it has at least:
       // - Name
       // - Email OR Phone
       // - At least one work experience OR education
       const hasName = Boolean(cv.personal_info?.full_name);
       const hasContact = Boolean(cv.personal_info?.email || cv.personal_info?.phone);
       const hasExperience = (cv.work_experience?.length || 0) > 0;
       const hasEducation = (cv.education?.length || 0) > 0;
       
       return hasName && hasContact && (hasExperience || hasEducation);
     }
     ```
  
  4. Create cv-extractor.ts:
     ```typescript
     // ============================================
     // [F074] src/lib/cv/cv-extractor.ts
     // ============================================
     
     import { getAIProvider } from '@/lib/ai';
     import { AIProviderConfig, AICompletionOptions } from '@/lib/ai/ai-provider';
     import { 
       CVExtractionResult, 
       CVExtractionRequest,
       ComprehensiveCV,
       AIProviderName 
     } from '@/lib/types';
     import { 
       CV_EXTRACTION_SYSTEM_PROMPT, 
       CV_EXTRACTION_USER_PROMPT 
     } from './cv-extraction-prompt';
     import { validateExtractedCV, getCompletionPercentage } from './cv-validator';
     import { generateId } from '@/lib/utils';
     
     export async function extractCVWithAI(
       request: CVExtractionRequest,
       apiKey: string
     ): Promise<CVExtractionResult> {
       const { rawText, aiProvider, aiModel } = request;
       
       const provider = getAIProvider(aiProvider);
       
       const config: AIProviderConfig = {
         apiKey,
         temperature: 0.1,  // Low temperature for consistent extraction
         maxTokens: 4096
       };
       
       const options: AICompletionOptions = {
         model: aiModel,
         messages: [
           { role: 'system', content: CV_EXTRACTION_SYSTEM_PROMPT },
           { role: 'user', content: CV_EXTRACTION_USER_PROMPT(rawText) }
         ],
         jsonMode: true  // Request JSON output where supported
       };
       
       try {
         const response = await provider.complete(config, options);
         const parsed = provider.parseJsonResponse<any>(response);
         
         if (!parsed) {
           return {
             success: false,
             cv: {},
             fieldStatuses: [],
             confidence: 0,
             rawText,
             aiProvider,
             aiModel,
             extractionNotes: 'Failed to parse AI response as JSON'
           };
         }
         
         // Transform parsed data to our CV structure
         const cv: Partial<ComprehensiveCV> = {
           personal_info: parsed.personal_info || {},
           work_experience: (parsed.work_experience || []).map((w: any) => ({
             ...w,
             id: w.id || generateId()
           })),
           education: (parsed.education || []).map((e: any) => ({
             ...e,
             id: e.id || generateId()
           })),
           skills: parsed.skills || [],
           certifications: (parsed.certifications || []).map((c: any) => ({
             ...c,
             id: c.id || generateId()
           })),
           languages: parsed.languages || [],
           projects: (parsed.projects || []).map((p: any) => ({
             ...p,
             id: p.id || generateId()
           })),
           additional_sections: [],
           raw_text: rawText
         };
         
         const fieldStatuses = validateExtractedCV(cv);
         const completionPercentage = getCompletionPercentage(fieldStatuses);
         
         return {
           success: true,
           cv,
           fieldStatuses,
           confidence: parsed.confidence || completionPercentage,
           rawText,
           aiProvider,
           aiModel,
           extractionNotes: parsed.notes
         };
         
       } catch (error: any) {
         return {
           success: false,
           cv: {},
           fieldStatuses: [],
           confidence: 0,
           rawText,
           aiProvider,
           aiModel,
           extractionNotes: `Extraction failed: ${error.message}`
         };
       }
     }
     ```
  
  5. Create index.ts:
     ```typescript
     // ============================================
     // [F109] src/lib/cv/index.ts
     // ============================================
     
     export * from './cv-extractor';
     export * from './cv-extraction-prompt';
     export * from './cv-validator';
     ```
  
  6. Create api/cv/extract/route.ts:
     ```typescript
     // ============================================
     // [F110] src/app/api/cv/extract/route.ts
     // ============================================
     
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     import { extractCVWithAI } from '@/lib/cv';
     import { decryptApiKey } from '@/lib/encryption';
     import { parseFile } from '@/lib/parsers';
     import { AIProviderName } from '@/lib/types';
     
     export async function POST(request: NextRequest) {
       const supabase = createServerSupabaseClient();
       const userId = request.headers.get('x-user-id');
       
       if (!userId) {
         return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
       }
       
       const formData = await request.formData();
       const file = formData.get('file') as File | null;
       const rawText = formData.get('rawText') as string | null;
       const provider = formData.get('provider') as AIProviderName;
       const model = formData.get('model') as string;
       
       if (!provider || !model) {
         return NextResponse.json({ 
           error: 'AI provider and model are required' 
         }, { status: 400 });
       }
       
       // Get the user's API key for this provider
       const { data: keyData, error: keyError } = await supabase
         .from('ai_api_keys')
         .select('api_key_encrypted')
         .eq('user_id', userId)
         .eq('provider_name', provider)
         .single();
       
       if (keyError || !keyData) {
         return NextResponse.json({ 
           error: `No API key found for ${provider}. Please add one in Settings.` 
         }, { status: 400 });
       }
       
       // Decrypt the API key
       let apiKey: string;
       try {
         apiKey = decryptApiKey(keyData.api_key_encrypted);
       } catch {
         return NextResponse.json({ 
           error: 'Failed to decrypt API key' 
         }, { status: 500 });
       }
       
       // Get the raw text (either from file or direct input)
       let textToProcess: string;
       
       if (file) {
         try {
           const parsed = await parseFile(file);
           textToProcess = parsed.text;
         } catch (error: any) {
           return NextResponse.json({ 
             error: `Failed to parse file: ${error.message}` 
           }, { status: 400 });
         }
       } else if (rawText) {
         textToProcess = rawText;
       } else {
         return NextResponse.json({ 
           error: 'Either file or rawText is required' 
         }, { status: 400 });
       }
       
       // Extract CV fields using AI
       const result = await extractCVWithAI(
         {
           rawText: textToProcess,
           aiProvider: provider,
           aiModel: model
         },
         apiKey
       );
       
       return NextResponse.json(result);
     }
     ```

checkpoint_tests:
  - id: T01
    description: "All CV extraction files exist"
    type: "files_exist"
    files:
      - "src/lib/cv/cv-extractor.ts"
      - "src/lib/cv/cv-extraction-prompt.ts"
      - "src/lib/cv/cv-validator.ts"
      - "src/lib/cv/index.ts"
      - "src/app/api/cv/extract/route.ts"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "cv-extractor.ts uses AI provider"
    type: "grep"
    file: "src/lib/cv/cv-extractor.ts"
    patterns:
      - "getAIProvider"
      - "extractCVWithAI"
      - "CVExtractionResult"
      - "provider.complete"

  - id: T04
    description: "cv-extraction-prompt.ts has extraction prompts"
    type: "grep"
    file: "src/lib/cv/cv-extraction-prompt.ts"
    patterns:
      - "CV_EXTRACTION_SYSTEM_PROMPT"
      - "CV_EXTRACTION_USER_PROMPT"
      - "personal_info"
      - "work_experience"
      - "JSON"

  - id: T05
    description: "cv-validator.ts has validation functions"
    type: "grep"
    file: "src/lib/cv/cv-validator.ts"
    patterns:
      - "validateExtractedCV"
      - "getMissingFields"
      - "getCompletionPercentage"
      - "isMinimumViable"

  - id: T06
    description: "API route uses AI extraction"
    type: "grep"
    file: "src/app/api/cv/extract/route.ts"
    patterns:
      - "extractCVWithAI"
      - "decryptApiKey"
      - "parseFile"

  - id: T07
    description: "types.ts has CVExtractionResult"
    type: "grep"
    file: "src/lib/types.ts"
    patterns:
      - "CVExtractionResult"
      - "CVExtractionRequest"

max_retries: 3
ترتیب جدید بلوک‌ها
text

B07: Development Auth            (بدون تغییر)
B08: Main Layout                 (بدون تغییر)
B09: File Parsers                (بدون تغییر)
B10: AI Provider Interface       ← جدید (از B19 منتقل شد)
B11: API Key Management          ← جدید (از B18/B21/B22 ترکیب شد)
B12: AI CV Field Extractor       ← جدید (جایگزین B10 قدیم)
B13: CV Uploader Component       ← شماره تغییر کرد (قبلاً B11)
B14: CV Field Display & Forms    ← شماره تغییر کرد (قبلاً B12)
B15: CV API & Database           ← شماره تغییر کرد (قبلاً B13)
B16: CV Manager Page             ← شماره تغییر کرد (قبلاً B14)
آپدیت وابستگی‌ها
YAML

# B13 (CV Uploader) حالا به B12 (AI Extractor) هم وابسته است
dependencies: [B01, B02, B03, B04, B05, B08, B09, B10, B11, B12]

# تفاوت کلیدی:
# CVUploader حالا به جای استفاده از regex-based extraction
# از API route /api/cv/extract استفاده می‌کند که AI-powered است
آیا می‌خواهی B13 تا B16 اصلاح‌شده را هم بنویسم تا با این تغییرات سازگار باشند؟





یک مشکلی وجود دارد اکسترکشن محتویات cv باید با با کمک ai ضورت بگیرد

claude-opus-4-5-20251101
بلوک‌های B07 تا B14 — فایل‌های YAML
B07.yaml — لاگین موقت (Development Auth)
YAML

# blocks/B07.yaml

id: B07
name: "Development Auth (Temporary Login)"
phase: 0
phase_name: "Foundation"

goal: |
  Create a simple temporary authentication system for development purposes.
  This will be replaced with Google OAuth in the final phase.
  Users can "login" by entering their email and name - no password required.
  This allows development to proceed without OAuth complexity.

dependencies: [B01, B02, B03, B04, B05, B06]

files_to_create:
  - id: F089
    path: "src/lib/auth/dev-auth.ts"
    description: "Development authentication helper functions"

  - id: F090
    path: "src/context/AuthContext.tsx"
    description: "React context for authentication state"

  - id: F091
    path: "src/components/auth/DevLoginForm.tsx"
    description: "Simple login form for development"

  - id: F092
    path: "src/components/auth/AuthGuard.tsx"
    description: "Component to protect routes that require authentication"

files_to_modify:
  - id: F011
    path: "src/app/[locale]/page.tsx"
    description: "Landing page with login form"

  - id: F010
    path: "src/app/[locale]/layout.tsx"
    description: "Add AuthContext provider"

  - id: F087
    path: "src/i18n/en.json"
    description: "Add auth-related translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add auth-related translations"

files_available:
  - id: F001
    path: "package.json"
    from_block: B01
  - id: F063
    path: "src/lib/supabase/client.ts"
    from_block: B06
  - id: F064
    path: "src/lib/supabase/server.ts"
    from_block: B06
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F080
    path: "src/lib/utils.ts"
    from_block: B04
  - id: F086
    path: "src/i18n/config.ts"
    from_block: B05
  - id: F087
    path: "src/i18n/en.json"
    from_block: B05
  - id: F088
    path: "src/i18n/fa.json"
    from_block: B05

commands: []

instructions: |
  1. Create dev-auth.ts with these functions:
     - devLogin(email: string, name: string): Creates or retrieves user from Supabase
     - devLogout(): Clears the session
     - getCurrentUser(): Returns current user or null
     - Use localStorage to persist the user ID during development
  
  2. Create AuthContext.tsx:
     - Provide user state, loading state, login/logout functions
     - Check for existing session on mount
     - Export useAuth hook
  
  3. Create DevLoginForm.tsx:
     - Simple form with email and name fields
     - Submit button
     - Loading state during login
     - Error message display
     - Use i18n for all text
     - Support RTL for Farsi
  
  4. Create AuthGuard.tsx:
     - Wrap protected pages
     - If not authenticated, redirect to login page
     - Show loading spinner while checking auth
  
  5. Update [locale]/page.tsx:
     - Show DevLoginForm if not authenticated
     - Redirect to /dashboard if authenticated
  
  6. Update [locale]/layout.tsx:
     - Wrap children with AuthProvider
  
  7. Add to en.json and fa.json under "auth" key:
     - login_title, email_label, name_label, login_button, logging_in, 
       login_error, welcome_back, logout, email_placeholder, name_placeholder

  IMPORTANT: This is temporary for development. Keep it simple.
  Do NOT implement password, OAuth, or complex session management.

checkpoint_tests:
  - id: T01
    description: "dev-auth.ts file exists"
    type: "files_exist"
    files:
      - "src/lib/auth/dev-auth.ts"

  - id: T02
    description: "AuthContext.tsx file exists"
    type: "files_exist"
    files:
      - "src/context/AuthContext.tsx"

  - id: T03
    description: "DevLoginForm.tsx file exists"
    type: "files_exist"
    files:
      - "src/components/auth/DevLoginForm.tsx"

  - id: T04
    description: "AuthGuard.tsx file exists"
    type: "files_exist"
    files:
      - "src/components/auth/AuthGuard.tsx"

  - id: T05
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T06
    description: "AuthContext exports useAuth hook"
    type: "grep"
    file: "src/context/AuthContext.tsx"
    patterns:
      - "export function useAuth"
      - "AuthProvider"
      - "createContext"

  - id: T07
    description: "DevLoginForm uses i18n"
    type: "grep"
    file: "src/components/auth/DevLoginForm.tsx"
    patterns:
      - "useTranslations"
      - "t("

  - id: T08
    description: "English translations have auth keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "login_title"
      - "email_label"
      - "login_button"

  - id: T09
    description: "Farsi translations have auth keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "login_title"
      - "email_label"
      - "login_button"

  - id: T10
    description: "Layout includes AuthProvider"
    type: "grep"
    file: "src/app/[locale]/layout.tsx"
    patterns:
      - "AuthProvider"

max_retries: 3
B08.yaml — Layout اصلی (Header + Sidebar + Footer)
YAML

# blocks/B08.yaml

id: B08
name: "Main Layout (Header + Sidebar + Footer)"
phase: 0
phase_name: "Foundation"

goal: |
  Create the main application layout with Header, Sidebar navigation, and Footer.
  The layout should be responsive, support RTL for Farsi, and include language switching.

dependencies: [B01, B02, B03, B04, B05, B06, B07]

files_to_create:
  - id: F037
    path: "src/components/layout/Header.tsx"
    description: "Top header with logo, app name, language switcher, user info"

  - id: F038
    path: "src/components/layout/Sidebar.tsx"
    description: "Side navigation menu with links to all main pages"

  - id: F039
    path: "src/components/layout/Footer.tsx"
    description: "Simple footer with copyright"

  - id: F040
    path: "src/components/layout/LanguageSwitcher.tsx"
    description: "Button/dropdown to switch between EN and FA"

  - id: F093
    path: "src/components/layout/MainLayout.tsx"
    description: "Combines Header, Sidebar, Footer into main app layout"

  - id: F094
    path: "src/components/layout/MobileMenu.tsx"
    description: "Hamburger menu for mobile devices"

  - id: F012
    path: "src/app/[locale]/dashboard/page.tsx"
    description: "Dashboard page (placeholder for now)"

files_to_modify:
  - id: F010
    path: "src/app/[locale]/layout.tsx"
    description: "Use MainLayout for authenticated pages"

  - id: F087
    path: "src/i18n/en.json"
    description: "Add navigation translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add navigation translations"

  - id: F009
    path: "src/app/globals.css"
    description: "Add layout-specific CSS if needed"

files_available:
  - id: F001
    path: "package.json"
    from_block: B01
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F036
    path: "src/components/ui/dropdown-menu.tsx"
    from_block: B02
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F080
    path: "src/lib/utils.ts"
    from_block: B04
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F086
    path: "src/i18n/config.ts"
    from_block: B05
  - id: F087
    path: "src/i18n/en.json"
    from_block: B05
  - id: F088
    path: "src/i18n/fa.json"
    from_block: B05
  - id: F090
    path: "src/context/AuthContext.tsx"
    from_block: B07

commands: []

instructions: |
  1. Create Header.tsx:
     - Logo/App name on the left (links to dashboard)
     - LanguageSwitcher component
     - User avatar/name from AuthContext
     - Logout button
     - Use shadcn/ui Button and DropdownMenu
     - Responsive: hide some elements on mobile
  
  2. Create Sidebar.tsx:
     - Navigation links:
       * Dashboard (/[locale]/dashboard)
       * My CV (/[locale]/cv-manager)
       * New Application (/[locale]/new-application)
       * My Applications (/[locale]/applications)
       * Prompt Management (/[locale]/prompts)
       * Settings (/[locale]/settings)
     - Highlight active link
     - Use lucide-react icons
     - Collapsible on desktop (optional)
     - Hidden on mobile (replaced by MobileMenu)
  
  3. Create Footer.tsx:
     - Simple: "© 2025 CV Tailor. All rights reserved."
     - Centered, subtle styling
  
  4. Create LanguageSwitcher.tsx:
     - Show current language (EN/FA)
     - Click to switch
     - Use next-intl's useRouter and usePathname
     - When switching, redirect to same page in new locale
  
  5. Create MobileMenu.tsx:
     - Hamburger icon button
     - Opens a drawer/sheet with navigation links
     - Use shadcn Sheet or custom implementation
  
  6. Create MainLayout.tsx:
     - Combines: Header (top), Sidebar (left), main content (center), Footer (bottom)
     - Responsive grid/flex layout
     - On mobile: no sidebar, use MobileMenu
     - Handle RTL: sidebar on right for Farsi
  
  7. Create dashboard/page.tsx:
     - Simple placeholder: "Welcome to Dashboard"
     - Wrap with AuthGuard
     - Will be expanded later
  
  8. Update [locale]/layout.tsx:
     - Detect if route needs MainLayout (authenticated routes)
     - For now, apply MainLayout to all routes except login
  
  9. Add to translations (nav section):
     - dashboard, cv_manager, new_application, applications, prompts, settings
     - logout, language

checkpoint_tests:
  - id: T01
    description: "All layout component files exist"
    type: "files_exist"
    files:
      - "src/components/layout/Header.tsx"
      - "src/components/layout/Sidebar.tsx"
      - "src/components/layout/Footer.tsx"
      - "src/components/layout/LanguageSwitcher.tsx"
      - "src/components/layout/MainLayout.tsx"
      - "src/components/layout/MobileMenu.tsx"

  - id: T02
    description: "Dashboard page exists"
    type: "files_exist"
    files:
      - "src/app/[locale]/dashboard/page.tsx"

  - id: T03
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T04
    description: "Header uses AuthContext"
    type: "grep"
    file: "src/components/layout/Header.tsx"
    patterns:
      - "useAuth"

  - id: T05
    description: "Sidebar has all navigation links"
    type: "grep"
    file: "src/components/layout/Sidebar.tsx"
    patterns:
      - "dashboard"
      - "cv-manager"
      - "new-application"
      - "applications"
      - "prompts"
      - "settings"

  - id: T06
    description: "LanguageSwitcher handles locale change"
    type: "grep"
    file: "src/components/layout/LanguageSwitcher.tsx"
    patterns:
      - "useRouter"
      - "usePathname"
      - "locale"

  - id: T07
    description: "MainLayout combines all components"
    type: "grep"
    file: "src/components/layout/MainLayout.tsx"
    patterns:
      - "Header"
      - "Sidebar"
      - "Footer"

  - id: T08
    description: "English translations have nav keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "dashboard"
      - "cv_manager"
      - "new_application"
      - "settings"

  - id: T09
    description: "Farsi translations have nav keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "dashboard"
      - "settings"

  - id: T10
    description: "Dashboard page uses AuthGuard"
    type: "grep"
    file: "src/app/[locale]/dashboard/page.tsx"
    patterns:
      - "AuthGuard"

max_retries: 3
B09.yaml — پارسرهای فایل (Word + Markdown)
YAML

# blocks/B09.yaml

id: B09
name: "File Parsers (Word + Markdown)"
phase: 1
phase_name: "CV Management"

goal: |
  Create utility functions to parse Word (.docx) and Markdown (.md) files
  and extract their text content. These will be used to parse uploaded CVs.

dependencies: [B01, B02, B03, B04]

files_to_create:
  - id: F072
    path: "src/lib/parsers/docx-parser.ts"
    description: "Parse .docx files and extract text content"

  - id: F073
    path: "src/lib/parsers/markdown-parser.ts"
    description: "Parse .md files and extract text content"

  - id: F095
    path: "src/lib/parsers/index.ts"
    description: "Export all parsers from single entry point"

files_to_modify: []

files_available:
  - id: F001
    path: "package.json"
    from_block: B01
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F080
    path: "src/lib/utils.ts"
    from_block: B04

commands: []

instructions: |
  1. Create docx-parser.ts:
     ```typescript
     import mammoth from 'mammoth';
     
     export interface ParsedDocument {
       text: string;
       html?: string;
       metadata?: {
         wordCount: number;
         hasImages: boolean;
       };
     }
     
     export async function parseDocx(file: File | Buffer): Promise<ParsedDocument> {
       // If File, convert to ArrayBuffer first
       // Use mammoth.extractRawText() for text
       // Use mammoth.convertToHtml() for HTML (optional)
       // Return ParsedDocument
       // Handle errors gracefully
     }
     
     export async function parseDocxFromArrayBuffer(arrayBuffer: ArrayBuffer): Promise<ParsedDocument> {
       // Direct parsing from ArrayBuffer
     }
     ```
  
  2. Create markdown-parser.ts:
     ```typescript
     import { unified } from 'unified';
     import remarkParse from 'remark-parse';
     import remarkHtml from 'remark-html';
     
     export interface ParsedMarkdown {
       text: string;
       html: string;
       metadata?: {
         wordCount: number;
         headings: string[];
       };
     }
     
     export async function parseMarkdown(content: string): Promise<ParsedMarkdown> {
       // Parse markdown to AST
       // Extract plain text (strip formatting)
       // Convert to HTML
       // Extract headings
       // Return ParsedMarkdown
     }
     
     export async function parseMarkdownFile(file: File): Promise<ParsedMarkdown> {
       // Read file as text
       // Call parseMarkdown
     }
     ```
  
  3. Create index.ts:
     ```typescript
     export * from './docx-parser';
     export * from './markdown-parser';
     
     export type SupportedFileType = 'docx' | 'md' | 'txt';
     
     export function detectFileType(filename: string): SupportedFileType | null {
       // Check file extension
       // Return type or null if unsupported
     }
     
     export async function parseFile(file: File): Promise<{ text: string; html?: string }> {
       // Detect type
       // Call appropriate parser
       // Throw error if unsupported
     }
     ```
  
  IMPORTANT:
  - Handle errors gracefully (corrupted files, empty files, etc.)
  - Return meaningful error messages
  - Keep functions pure and testable
  - Word count should count actual words, not characters

checkpoint_tests:
  - id: T01
    description: "All parser files exist"
    type: "files_exist"
    files:
      - "src/lib/parsers/docx-parser.ts"
      - "src/lib/parsers/markdown-parser.ts"
      - "src/lib/parsers/index.ts"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "docx-parser exports parseDocx function"
    type: "grep"
    file: "src/lib/parsers/docx-parser.ts"
    patterns:
      - "export async function parseDocx"
      - "mammoth"
      - "ParsedDocument"

  - id: T04
    description: "markdown-parser exports parseMarkdown function"
    type: "grep"
    file: "src/lib/parsers/markdown-parser.ts"
    patterns:
      - "export async function parseMarkdown"
      - "unified"
      - "ParsedMarkdown"

  - id: T05
    description: "index.ts exports all parsers and utilities"
    type: "grep"
    file: "src/lib/parsers/index.ts"
    patterns:
      - "export * from './docx-parser'"
      - "export * from './markdown-parser'"
      - "parseFile"
      - "detectFileType"

  - id: T06
    description: "Error handling is implemented"
    type: "grep"
    file: "src/lib/parsers/docx-parser.ts"
    patterns:
      - "try"
      - "catch"
      - "throw"

max_retries: 3
B10.yaml — استخراج‌گر فیلدهای سی‌وی
YAML

# blocks/B10.yaml

id: B10
name: "CV Field Extractor"
phase: 1
phase_name: "CV Management"

goal: |
  Create logic to extract structured fields from raw CV text.
  Identify sections like personal info, work experience, education, skills, etc.
  Also identify which required fields are missing or incomplete.

dependencies: [B01, B02, B03, B04, B09]

files_to_create:
  - id: F074
    path: "src/lib/parsers/cv-field-extractor.ts"
    description: "Extract structured CV fields from raw text"

  - id: F096
    path: "src/lib/parsers/cv-patterns.ts"
    description: "Regex patterns and section identifiers for CV parsing"

files_to_modify:
  - id: F095
    path: "src/lib/parsers/index.ts"
    description: "Export CV field extractor"

files_available:
  - id: F001
    path: "package.json"
    from_block: B01
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F080
    path: "src/lib/utils.ts"
    from_block: B04
  - id: F072
    path: "src/lib/parsers/docx-parser.ts"
    from_block: B09
  - id: F073
    path: "src/lib/parsers/markdown-parser.ts"
    from_block: B09
  - id: F095
    path: "src/lib/parsers/index.ts"
    from_block: B09

commands: []

instructions: |
  1. Create cv-patterns.ts:
     ```typescript
     // Section header patterns (English and Farsi)
     export const SECTION_PATTERNS = {
       personal_info: [
         /^(personal\s*(info|information|details)|contact|about\s*me)/i,
         /^(اطلاعات\s*شخصی|درباره\s*من|تماس)/
       ],
       work_experience: [
         /^(work\s*experience|experience|employment|professional\s*experience)/i,
         /^(سوابق\s*کاری|تجربه\s*کاری|سابقه\s*کار)/
       ],
       education: [
         /^(education|academic|qualifications)/i,
         /^(تحصیلات|سوابق\s*تحصیلی)/
       ],
       skills: [
         /^(skills|technical\s*skills|competencies)/i,
         /^(مهارت‌?ها|توانایی‌?ها)/
       ],
       certifications: [
         /^(certifications?|certificates?|licenses?)/i,
         /^(گواهینامه‌?ها|مدارک)/
       ],
       languages: [
         /^(languages?|language\s*skills)/i,
         /^(زبان‌?ها|مهارت\s*زبان)/
       ],
       projects: [
         /^(projects?|portfolio)/i,
         /^(پروژه‌?ها)/
       ]
     };
     
     // Email, phone, LinkedIn patterns
     export const FIELD_PATTERNS = {
       email: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/,
       phone: /(\+?\d{1,3}[-.\s]?)?\(?\d{2,4}\)?[-.\s]?\d{3,4}[-.\s]?\d{3,4}/,
       linkedin: /linkedin\.com\/in\/[\w-]+/i,
       website: /https?:\/\/[^\s]+/
     };
     ```
  
  2. Create cv-field-extractor.ts:
     ```typescript
     import { ComprehensiveCV, CVFieldStatus, PersonalInfo, WorkExperience, Education } from '@/lib/types';
     import { CV_REQUIRED_FIELDS } from '@/lib/constants';
     import { SECTION_PATTERNS, FIELD_PATTERNS } from './cv-patterns';
     
     export interface ExtractionResult {
       cv: Partial<ComprehensiveCV>;
       fieldStatuses: CVFieldStatus[];
       rawText: string;
       confidence: number; // 0-100, how confident we are in the extraction
     }
     
     export function extractCVFields(rawText: string): ExtractionResult {
       // 1. Split text into sections based on headers
       // 2. Extract personal info using patterns
       // 3. Extract work experience (job title, company, dates, description)
       // 4. Extract education
       // 5. Extract skills (as array)
       // 6. Extract other sections
       // 7. Check which required fields are complete/incomplete
       // 8. Calculate confidence score
     }
     
     function extractPersonalInfo(text: string): Partial<PersonalInfo> {
       // Use regex to find email, phone, linkedin, etc.
       // Try to identify name (usually first line or largest text)
       // Extract summary if present
     }
     
     function extractWorkExperience(sectionText: string): WorkExperience[] {
       // Split into individual jobs
       // Extract: job_title, company, location, dates, description
       // Parse dates into start_date, end_date, is_current
     }
     
     function extractEducation(sectionText: string): Education[] {
       // Similar to work experience
       // Extract: degree, institution, dates, gpa
     }
     
     function extractSkills(sectionText: string): string[] {
       // Split by common delimiters (comma, bullet, newline)
       // Clean up each skill
       // Remove duplicates
     }
     
     export function checkFieldCompleteness(cv: Partial<ComprehensiveCV>): CVFieldStatus[] {
       // Check each field in CV_REQUIRED_FIELDS
       // Return array of { field_name, is_complete, current_value }
     }
     
     export function getMissingFields(statuses: CVFieldStatus[]): string[] {
       // Return list of field names that are incomplete
     }
     ```
  
  3. Update index.ts:
     - Export extractCVFields, checkFieldCompleteness, getMissingFields
  
  NOTES:
  - This is heuristic-based extraction, not AI-powered
  - It's okay if it's not perfect - users can correct in the UI
  - Focus on common CV formats
  - Support both English and Farsi section headers

checkpoint_tests:
  - id: T01
    description: "CV field extractor files exist"
    type: "files_exist"
    files:
      - "src/lib/parsers/cv-field-extractor.ts"
      - "src/lib/parsers/cv-patterns.ts"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "cv-patterns.ts exports section patterns"
    type: "grep"
    file: "src/lib/parsers/cv-patterns.ts"
    patterns:
      - "SECTION_PATTERNS"
      - "FIELD_PATTERNS"
      - "personal_info"
      - "work_experience"
      - "education"
      - "skills"

  - id: T04
    description: "cv-field-extractor.ts exports main functions"
    type: "grep"
    file: "src/lib/parsers/cv-field-extractor.ts"
    patterns:
      - "export function extractCVFields"
      - "export function checkFieldCompleteness"
      - "ExtractionResult"
      - "CVFieldStatus"

  - id: T05
    description: "Uses types from types.ts"
    type: "grep"
    file: "src/lib/parsers/cv-field-extractor.ts"
    patterns:
      - "import"
      - "ComprehensiveCV"
      - "PersonalInfo"

  - id: T06
    description: "Uses constants from constants.ts"
    type: "grep"
    file: "src/lib/parsers/cv-field-extractor.ts"
    patterns:
      - "CV_REQUIRED_FIELDS"

  - id: T07
    description: "index.ts exports CV field extractor"
    type: "grep"
    file: "src/lib/parsers/index.ts"
    patterns:
      - "cv-field-extractor"

max_retries: 3
B11.yaml — کامپوننت آپلود سی‌وی
YAML

# blocks/B11.yaml

id: B11
name: "CV Uploader Component"
phase: 1
phase_name: "CV Management"

goal: |
  Create a component that allows users to upload their CV file (Word or Markdown)
  or enter CV text directly. Includes drag-and-drop, file validation, and preview.

dependencies: [B01, B02, B03, B04, B05, B08, B09, B10]

files_to_create:
  - id: F041
    path: "src/components/cv/CVUploader.tsx"
    description: "Main CV upload component with drag-drop and text input"

  - id: F097
    path: "src/components/cv/FileDropZone.tsx"
    description: "Reusable drag-and-drop file upload zone"

  - id: F098
    path: "src/components/cv/TextInputMode.tsx"
    description: "Textarea for direct CV text input"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add CV upload translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add CV upload translations"

files_available:
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F028
    path: "src/components/ui/input.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F032
    path: "src/components/ui/textarea.tsx"
    from_block: B02
  - id: F033
    path: "src/components/ui/tabs.tsx"
    from_block: B02
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F080
    path: "src/lib/utils.ts"
    from_block: B04
  - id: F072
    path: "src/lib/parsers/docx-parser.ts"
    from_block: B09
  - id: F073
    path: "src/lib/parsers/markdown-parser.ts"
    from_block: B09
  - id: F095
    path: "src/lib/parsers/index.ts"
    from_block: B09
  - id: F074
    path: "src/lib/parsers/cv-field-extractor.ts"
    from_block: B10

commands: []

instructions: |
  1. Create FileDropZone.tsx:
     ```typescript
     interface FileDropZoneProps {
       onFileSelect: (file: File) => void;
       acceptedTypes: string[];  // e.g., ['.docx', '.md']
       maxSizeMB: number;
       disabled?: boolean;
     }
     
     // Features:
     // - Drag and drop area with visual feedback
     // - Click to open file picker
     // - Show accepted file types
     // - Show max file size
     // - Error state for invalid files
     // - Loading state while processing
     // - Use lucide-react icons (Upload, File, AlertCircle)
     // - i18n for all text
     // - RTL support
     ```
  
  2. Create TextInputMode.tsx:
     ```typescript
     interface TextInputModeProps {
       value: string;
       onChange: (value: string) => void;
       placeholder?: string;
       disabled?: boolean;
     }
     
     // Features:
     // - Large textarea for pasting CV text
     // - Character count
     // - Clear button
     // - i18n for all text
     ```
  
  3. Create CVUploader.tsx:
     ```typescript
     interface CVUploaderProps {
       onCVParsed: (result: ExtractionResult) => void;
       existingCV?: Partial<ComprehensiveCV>;
       disabled?: boolean;
     }
     
     // Features:
     // - Tabs: "Upload File" | "Enter Text"
     // - Upload File tab: FileDropZone
     // - Enter Text tab: TextInputMode
     // - When file is selected or text submitted:
     //   1. Parse the content
     //   2. Extract CV fields
     //   3. Call onCVParsed with result
     // - Show loading state during parsing
     // - Show error messages if parsing fails
     // - If existingCV provided, show option to replace or merge
     // - i18n for all text
     // - RTL support
     ```
  
  4. Add translations:
     Under "cv" key in en.json and fa.json:
     - upload_tab, text_tab
     - drag_drop_text, or_click, supported_formats
     - max_file_size, file_too_large, invalid_format
     - parsing_file, parsing_text, parse_error
     - enter_cv_text, text_placeholder
     - character_count, clear_text
     - replace_existing, merge_existing

checkpoint_tests:
  - id: T01
    description: "All CV uploader component files exist"
    type: "files_exist"
    files:
      - "src/components/cv/CVUploader.tsx"
      - "src/components/cv/FileDropZone.tsx"
      - "src/components/cv/TextInputMode.tsx"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "CVUploader uses tabs for upload modes"
    type: "grep"
    file: "src/components/cv/CVUploader.tsx"
    patterns:
      - "FileDropZone"
      - "TextInputMode"
      - "Tabs"
      - "onCVParsed"

  - id: T04
    description: "FileDropZone implements drag and drop"
    type: "grep"
    file: "src/components/cv/FileDropZone.tsx"
    patterns:
      - "onDragOver"
      - "onDrop"
      - "onFileSelect"
      - "acceptedTypes"

  - id: T05
    description: "Uses parsers from B09"
    type: "grep"
    file: "src/components/cv/CVUploader.tsx"
    patterns:
      - "parseFile"
      - "extractCVFields"
      - "@/lib/parsers"

  - id: T06
    description: "Uses i18n"
    type: "grep"
    file: "src/components/cv/CVUploader.tsx"
    patterns:
      - "useTranslations"
      - "t("

  - id: T07
    description: "English translations have CV upload keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "upload_tab"
      - "drag_drop_text"
      - "parsing_file"

  - id: T08
    description: "Farsi translations have CV upload keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "upload_tab"
      - "drag_drop_text"

max_retries: 3
B12.yaml — نمایش و تکمیل فیلدهای سی‌وی
YAML

# blocks/B12.yaml

id: B12
name: "CV Field Display and Completion Forms"
phase: 1
phase_name: "CV Management"

goal: |
  Create components to display extracted CV fields, highlight incomplete fields,
  and provide forms to complete missing information.

dependencies: [B01, B02, B03, B04, B05, B08, B09, B10, B11]

files_to_create:
  - id: F042
    path: "src/components/cv/CVFieldExtractor.tsx"
    description: "Display extracted fields with completeness indicators"

  - id: F043
    path: "src/components/cv/CVCompletionForm.tsx"
    description: "Form to fill in missing CV fields"

  - id: F044
    path: "src/components/cv/CVPreview.tsx"
    description: "Preview the complete CV in a readable format"

  - id: F099
    path: "src/components/cv/FieldStatusBadge.tsx"
    description: "Badge showing complete/incomplete status"

  - id: F100
    path: "src/components/cv/WorkExperienceForm.tsx"
    description: "Form for adding/editing work experience entries"

  - id: F101
    path: "src/components/cv/EducationForm.tsx"
    description: "Form for adding/editing education entries"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add field display and form translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add field display and form translations"

files_available:
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F028
    path: "src/components/ui/input.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F030
    path: "src/components/ui/dialog.tsx"
    from_block: B02
  - id: F032
    path: "src/components/ui/textarea.tsx"
    from_block: B02
  - id: F034
    path: "src/components/ui/badge.tsx"
    from_block: B02
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F074
    path: "src/lib/parsers/cv-field-extractor.ts"
    from_block: B10
  - id: F041
    path: "src/components/cv/CVUploader.tsx"
    from_block: B11

commands: []

instructions: |
  1. Create FieldStatusBadge.tsx:
     ```typescript
     interface FieldStatusBadgeProps {
       isComplete: boolean;
       size?: 'sm' | 'md';
     }
     
     // Shows ✅ Complete (green) or ⚠️ Incomplete (yellow/orange)
     // Use shadcn Badge component
     // i18n for text
     ```
  
  2. Create CVFieldExtractor.tsx:
     ```typescript
     interface CVFieldExtractorProps {
       extractionResult: ExtractionResult;
       onFieldClick: (fieldName: string) => void;
     }
     
     // Display all CV sections in cards:
     // - Personal Info card (name, email, phone, etc.)
     // - Work Experience card (list of jobs)
     // - Education card (list of degrees)
     // - Skills card (list of skills)
     // - etc.
     
     // Each field shows:
     // - Field label
     // - Current value (or "Not provided")
     // - FieldStatusBadge
     // - Click to edit (calls onFieldClick)
     
     // Incomplete fields are highlighted
     // Summary at top: "X of Y required fields complete"
     ```
  
  3. Create CVCompletionForm.tsx:
     ```typescript
     interface CVCompletionFormProps {
       fieldName: string;
       currentValue: any;
       onSave: (value: any) => void;
       onCancel: () => void;
     }
     
     // Dynamic form based on fieldName
     // For personal_info.email: simple text input
     // For work_experience: show WorkExperienceForm
     // For education: show EducationForm
     // For skills: show tag/chip input
     
     // Opens in a Dialog/Modal
     // Save and Cancel buttons
     // Validation before save
     ```
  
  4. Create WorkExperienceForm.tsx:
     ```typescript
     interface WorkExperienceFormProps {
       experience?: WorkExperience;  // Editing existing or adding new
       onSave: (experience: WorkExperience) => void;
       onCancel: () => void;
     }
     
     // Fields:
     // - Job Title (required)
     // - Company (required)
     // - Location
     // - Start Date
     // - End Date (or "Current" checkbox)
     // - Description (textarea)
     // - Achievements (list, add/remove)
     ```
  
  5. Create EducationForm.tsx:
     ```typescript
     interface EducationFormProps {
       education?: Education;
       onSave: (education: Education) => void;
       onCancel: () => void;
     }
     
     // Similar structure to WorkExperienceForm
     // Fields: Degree, Institution, Location, Dates, GPA, Description
     ```
  
  6. Create CVPreview.tsx:
     ```typescript
     interface CVPreviewProps {
       cv: Partial<ComprehensiveCV>;
       locale: 'en' | 'fa';
     }
     
     // Render CV in a clean, readable format
     // Section headers
     // Formatted dates
     // Bullet points for lists
     // Support RTL for Farsi
     ```
  
  7. Add translations:
     - field_complete, field_incomplete
     - fields_complete_summary ("X of Y fields complete")
     - click_to_edit, add_new, save, cancel
     - job_title, company, location, start_date, end_date, current_job
     - description, achievements, add_achievement
     - degree, institution, gpa
     - All field labels

checkpoint_tests:
  - id: T01
    description: "All CV field component files exist"
    type: "files_exist"
    files:
      - "src/components/cv/CVFieldExtractor.tsx"
      - "src/components/cv/CVCompletionForm.tsx"
      - "src/components/cv/CVPreview.tsx"
      - "src/components/cv/FieldStatusBadge.tsx"
      - "src/components/cv/WorkExperienceForm.tsx"
      - "src/components/cv/EducationForm.tsx"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "CVFieldExtractor shows all CV sections"
    type: "grep"
    file: "src/components/cv/CVFieldExtractor.tsx"
    patterns:
      - "personal_info"
      - "work_experience"
      - "education"
      - "skills"
      - "FieldStatusBadge"

  - id: T04
    description: "CVCompletionForm handles different field types"
    type: "grep"
    file: "src/components/cv/CVCompletionForm.tsx"
    patterns:
      - "WorkExperienceForm"
      - "EducationForm"
      - "Dialog"
      - "onSave"

  - id: T05
    description: "WorkExperienceForm has all required fields"
    type: "grep"
    file: "src/components/cv/WorkExperienceForm.tsx"
    patterns:
      - "job_title"
      - "company"
      - "start_date"
      - "end_date"

  - id: T06
    description: "Uses i18n"
    type: "grep"
    file: "src/components/cv/CVFieldExtractor.tsx"
    patterns:
      - "useTranslations"

  - id: T07
    description: "English translations have form keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "job_title"
      - "field_complete"
      - "click_to_edit"

max_retries: 3
B13.yaml — API Route سی‌وی + ذخیره در Supabase
YAML

# blocks/B13.yaml

id: B13
name: "CV API Routes and Database Integration"
phase: 1
phase_name: "CV Management"

goal: |
  Create API routes for CV CRUD operations and a React hook for CV state management.
  CVs are stored in Supabase. Each user has one comprehensive CV.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08, B09, B10]

files_to_create:
  - id: F022
    path: "src/app/api/cv/route.ts"
    description: "API route for CV CRUD (GET, POST, PUT)"

  - id: F102
    path: "src/app/api/cv/parse/route.ts"
    description: "API route to parse uploaded CV file"

  - id: F082
    path: "src/hooks/useCV.ts"
    description: "React hook for CV operations"

files_to_modify: []

files_available:
  - id: F063
    path: "src/lib/supabase/client.ts"
    from_block: B06
  - id: F064
    path: "src/lib/supabase/server.ts"
    from_block: B06
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F078
    path: "src/lib/constants.ts"
    from_block: B04
  - id: F090
    path: "src/context/AuthContext.tsx"
    from_block: B07
  - id: F072
    path: "src/lib/parsers/docx-parser.ts"
    from_block: B09
  - id: F073
    path: "src/lib/parsers/markdown-parser.ts"
    from_block: B09
  - id: F074
    path: "src/lib/parsers/cv-field-extractor.ts"
    from_block: B10

commands: []

instructions: |
  1. Create src/app/api/cv/route.ts:
     ```typescript
     import { NextRequest, NextResponse } from 'next/server';
     import { createServerSupabaseClient } from '@/lib/supabase/server';
     
     // GET - Retrieve user's CV
     export async function GET(request: NextRequest) {
       // Get user from session/auth
       // Fetch CV from comprehensive_cvs table
       // Return CV or null if not exists
     }
     
     // POST - Create new CV (or replace existing)
     export async function POST(request: NextRequest) {
       // Get user from session
       // Parse request body (ComprehensiveCV data)
       // Upsert into comprehensive_cvs (user can only have one)
       // Return created/updated CV
     }
     
     // PUT - Update specific fields of CV
     export async function PUT(request: NextRequest) {
       // Get user from session
       // Parse request body (partial CV update)
       // Merge with existing CV
       // Update in database
       // Return updated CV
     }
     
     // Handle errors with proper status codes
     // 401 if not authenticated
     // 400 if invalid data
     // 500 if database error
     ```
  
  2. Create src/app/api/cv/parse/route.ts:
     ```typescript
     import { NextRequest, NextResponse } from 'next/server';
     import { parseFile } from '@/lib/parsers';
     import { extractCVFields } from '@/lib/parsers/cv-field-extractor';
     
     // POST - Parse uploaded CV file
     export async function POST(request: NextRequest) {
       // Get file from FormData
       // Parse file (docx or md)
       // Extract CV fields
       // Return ExtractionResult
       // Do NOT save to database - just parse and return
     }
     ```
  
  3. Create src/hooks/useCV.ts:
     ```typescript
     import { useState, useEffect, useCallback } from 'react';
     import { useAuth } from '@/context/AuthContext';
     import { ComprehensiveCV, CVFieldStatus, ExtractionResult } from '@/lib/types';
     
     export function useCV() {
       const { user } = useAuth();
       const [cv, setCV] = useState<ComprehensiveCV | null>(null);
       const [loading, setLoading] = useState(true);
       const [saving, setSaving] = useState(false);
       const [error, setError] = useState<string | null>(null);
       
       // Load CV on mount / user change
       useEffect(() => { ... }, [user]);
       
       // Fetch CV from API
       const fetchCV = useCallback(async () => { ... }, []);
       
       // Save entire CV
       const saveCV = useCallback(async (cvData: Partial<ComprehensiveCV>) => { ... }, []);
       
       // Update specific field
       const updateField = useCallback(async (fieldPath: string, value: any) => {
         // fieldPath like "personal_info.email" or "work_experience"
         // Merge with existing CV
         // Save to API
       }, [cv]);
       
       // Parse file and update CV
       const parseAndUpdateCV = useCallback(async (file: File) => {
         // Call /api/cv/parse
         // Get ExtractionResult
         // Save to API
         // Update local state
       }, []);
       
       // Get field statuses
       const getFieldStatuses = useCallback((): CVFieldStatus[] => {
         // Use checkFieldCompleteness from cv-field-extractor
       }, [cv]);
       
       return {
         cv,
         loading,
         saving,
         error,
         fetchCV,
         saveCV,
         updateField,
         parseAndUpdateCV,
         getFieldStatuses,
       };
     }
     ```

checkpoint_tests:
  - id: T01
    description: "API route files exist"
    type: "files_exist"
    files:
      - "src/app/api/cv/route.ts"
      - "src/app/api/cv/parse/route.ts"

  - id: T02
    description: "useCV hook exists"
    type: "files_exist"
    files:
      - "src/hooks/useCV.ts"

  - id: T03
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T04
    description: "CV API route has GET, POST, PUT handlers"
    type: "grep"
    file: "src/app/api/cv/route.ts"
    patterns:
      - "export async function GET"
      - "export async function POST"
      - "export async function PUT"
      - "createServerSupabaseClient"

  - id: T05
    description: "Parse API route uses parsers"
    type: "grep"
    file: "src/app/api/cv/parse/route.ts"
    patterns:
      - "parseFile"
      - "extractCVFields"
      - "FormData"

  - id: T06
    description: "useCV hook exports all functions"
    type: "grep"
    file: "src/hooks/useCV.ts"
    patterns:
      - "export function useCV"
      - "fetchCV"
      - "saveCV"
      - "updateField"
      - "parseAndUpdateCV"
      - "useAuth"

  - id: T07
    description: "useCV uses types from types.ts"
    type: "grep"
    file: "src/hooks/useCV.ts"
    patterns:
      - "ComprehensiveCV"
      - "CVFieldStatus"

max_retries: 3
B14.yaml — صفحه مدیریت سی‌وی (یکپارچه‌سازی)
YAML

# blocks/B14.yaml

id: B14
name: "CV Manager Page (Full Integration)"
phase: 1
phase_name: "CV Management"

goal: |
  Create the complete CV Manager page that integrates all CV components.
  Users can upload/enter their CV, see extracted fields, complete missing info,
  and save their comprehensive CV.

dependencies: [B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13]

files_to_create:
  - id: F013
    path: "src/app/[locale]/cv-manager/page.tsx"
    description: "Main CV Manager page"

  - id: F103
    path: "src/app/[locale]/cv-manager/loading.tsx"
    description: "Loading state for CV Manager"

files_to_modify:
  - id: F087
    path: "src/i18n/en.json"
    description: "Add CV Manager page translations"

  - id: F088
    path: "src/i18n/fa.json"
    description: "Add CV Manager page translations"

files_available:
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  - id: F029
    path: "src/components/ui/card.tsx"
    from_block: B02
  - id: F033
    path: "src/components/ui/tabs.tsx"
    from_block: B02
  - id: F035
    path: "src/components/ui/toast.tsx"
    from_block: B02
  - id: F079
    path: "src/lib/types.ts"
    from_block: B03
  - id: F092
    path: "src/components/auth/AuthGuard.tsx"
    from_block: B07
  - id: F041
    path: "src/components/cv/CVUploader.tsx"
    from_block: B11
  - id: F042
    path: "src/components/cv/CVFieldExtractor.tsx"
    from_block: B12
  - id: F043
    path: "src/components/cv/CVCompletionForm.tsx"
    from_block: B12
  - id: F044
    path: "src/components/cv/CVPreview.tsx"
    from_block: B12
  - id: F082
    path: "src/hooks/useCV.ts"
    from_block: B13

commands: []

instructions: |
  1. Create cv-manager/page.tsx:
     ```typescript
     'use client';
     
     import { useState } from 'react';
     import { useTranslations } from 'next-intl';
     import { AuthGuard } from '@/components/auth/AuthGuard';
     import { CVUploader } from '@/components/cv/CVUploader';
     import { CVFieldExtractor } from '@/components/cv/CVFieldExtractor';
     import { CVCompletionForm } from '@/components/cv/CVCompletionForm';
     import { CVPreview } from '@/components/cv/CVPreview';
     import { useCV } from '@/hooks/useCV';
     import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
     import { Card } from '@/components/ui/card';
     import { Button } from '@/components/ui/button';
     
     export default function CVManagerPage() {
       const t = useTranslations('cv_manager');
       const { cv, loading, saving, error, saveCV, updateField, parseAndUpdateCV, getFieldStatuses } = useCV();
       const [activeTab, setActiveTab] = useState<'upload' | 'fields' | 'preview'>('upload');
       const [editingField, setEditingField] = useState<string | null>(null);
       
       // Workflow:
       // 1. If no CV exists, show Upload tab
       // 2. After upload/parse, show Fields tab with extracted data
       // 3. User can click incomplete fields to complete them
       // 4. User can switch to Preview tab to see full CV
       // 5. Save button persists to database
       
       return (
         <AuthGuard>
           <div className="container mx-auto p-6">
             <h1>{t('title')}</h1>
             
             {error && <ErrorMessage message={error} />}
             
             <Tabs value={activeTab} onValueChange={setActiveTab}>
               <TabsList>
                 <TabsTrigger value="upload">{t('upload_tab')}</TabsTrigger>
                 <TabsTrigger value="fields">{t('fields_tab')}</TabsTrigger>
                 <TabsTrigger value="preview">{t('preview_tab')}</TabsTrigger>
               </TabsList>
               
               <TabsContent value="upload">
                 <CVUploader
                   onCVParsed={async (result) => {
                     await saveCV(result.cv);
                     setActiveTab('fields');
                   }}
                   existingCV={cv}
                 />
               </TabsContent>
               
               <TabsContent value="fields">
                 {cv ? (
                   <CVFieldExtractor
                     extractionResult={{ cv, fieldStatuses: getFieldStatuses(), rawText: cv.raw_text }}
                     onFieldClick={(fieldName) => setEditingField(fieldName)}
                   />
                 ) : (
                   <EmptyState message={t('no_cv_yet')} />
                 )}
               </TabsContent>
               
               <TabsContent value="preview">
                 {cv ? (
                   <CVPreview cv={cv} locale={locale} />
                 ) : (
                   <EmptyState message={t('no_cv_yet')} />
                 )}
               </TabsContent>
             </Tabs>
             
             {editingField && (
               <CVCompletionForm
                 fieldName={editingField}
                 currentValue={getFieldValue(cv, editingField)}
                 onSave={async (value) => {
                   await updateField(editingField, value);
                   setEditingField(null);
                 }}
                 onCancel={() => setEditingField(null)}
               />
             )}
             
             {cv && (
               <div className="mt-6 flex justify-end">
                 <Button onClick={() => saveCV(cv)} disabled={saving}>
                   {saving ? t('saving') : t('save_cv')}
                 </Button>
               </div>
             )}
           </div>
         </AuthGuard>
       );
     }
     ```
  
  2. Create cv-manager/loading.tsx:
     ```typescript
     export default function Loading() {
       return (
         <div className="container mx-auto p-6 animate-pulse">
           {/* Skeleton UI for CV Manager */}
         </div>
       );
     }
     ```
  
  3. Add translations to en.json under "cv_manager" key:
     - title: "My Comprehensive CV"
     - upload_tab, fields_tab, preview_tab
     - no_cv_yet, saving, save_cv, saved_successfully
     - fields_summary ("X of Y required fields complete")
     - complete_all_fields_hint
  
  4. Add same translations to fa.json

checkpoint_tests:
  - id: T01
    description: "CV Manager page files exist"
    type: "files_exist"
    files:
      - "src/app/[locale]/cv-manager/page.tsx"
      - "src/app/[locale]/cv-manager/loading.tsx"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "CV Manager page uses AuthGuard"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "AuthGuard"
      - "<AuthGuard>"

  - id: T04
    description: "CV Manager page uses all CV components"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "CVUploader"
      - "CVFieldExtractor"
      - "CVCompletionForm"
      - "CVPreview"

  - id: T05
    description: "CV Manager page uses useCV hook"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "useCV"
      - "saveCV"
      - "updateField"

  - id: T06
    description: "CV Manager page has tabs"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "Tabs"
      - "TabsContent"
      - "upload"
      - "fields"
      - "preview"

  - id: T07
    description: "CV Manager uses i18n"
    type: "grep"
    file: "src/app/[locale]/cv-manager/page.tsx"
    patterns:
      - "useTranslations"
      - "cv_manager"

  - id: T08
    description: "English translations have CV Manager keys"
    type: "grep"
    file: "src/i18n/en.json"
    patterns:
      - "cv_manager"
      - "upload_tab"
      - "fields_tab"
      - "preview_tab"

  - id: T09
    description: "Farsi translations have CV Manager keys"
    type: "grep"
    file: "src/i18n/fa.json"
    patterns:
      - "cv_manager"

  - id: T10
    description: "Loading component exists"
    type: "grep"
    file: "src/app/[locale]/cv-manager/loading.tsx"
    patterns:
      - "export default function Loading"
      - "animate-pulse"

max_retries: 3
خلاصه بلوک‌های B07–B14
بلوک	نام	فاز	تعداد فایل ایجادی	وابستگی‌ها
B07	Development Auth	0 - Foundation	4	B01-B06
B08	Main Layout	0 - Foundation	7	B01-B07
B09	File Parsers	1 - CV Management	3	B01-B04
B10	CV Field Extractor	1 - CV Management	2	B01-B04, B09
B11	CV Uploader Component	1 - CV Management	3	B01-B05, B08-B10
B12	CV Field Display & Forms	1 - CV Management	6	B01-B05, B08-B11
B13	CV API & Database	1 - CV Management	3	B01-B10
B14	CV Manager Page	1 - CV Management	2	B01-B13
این ۸ بلوک، فاز صفر (Foundation) را کامل می‌کنند و فاز یک (CV Management) را تکمیل می‌کنند.

آماده‌ام برای نوشتن بلوک‌های B15–B24 (پرامپت‌ها و AI) یا بلوک‌های دیگر. کدام مجموعه را بنویسم؟





از شماره ۷ تا ۱۴ را بنویس

claude-opus-4-5-20251101-thinking-32k
Something went wrong with this response, please try again.


در ۳ پارت ۱۰ تایی بنویس

claude-opus-4-6
Something went wrong with this response, please try again.


بله بساز

claude-opus-4-6-thinking

Thought for 3 seconds

بله! دقیقاً می‌شود.
یک سیستم اتوماسیون ارکستراتور می‌نویسیم که کل فرایند را مدیریت کند.

معماری سیستم ارکستراتور
text

┌──────────────────────────────────────────────────────────┐
│                    ORCHESTRATOR                            │
│                                                            │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐             │
│  │ Block     │───▶│ Prompt   │───▶│ Agent    │             │
│  │ Loader    │    │ Builder  │    │ Sender   │             │
│  └──────────┘    └──────────┘    └──────────┘             │
│       ▲                               │                    │
│       │                               ▼                    │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐             │
│  │ Status   │◀───│ Verify   │◀───│ Result   │             │
│  │ Tracker  │    │ Engine   │    │ Parser   │             │
│  └──────────┘    └──────────┘    └──────────┘             │
│                                                            │
└──────────────────────────────────────────────────────────┘
ساختار فایل‌های ارکستراتور
text

cv-tailor-orchestrator/
│
├── orchestrator.ts              ← مغز اصلی
├── config.ts                    ← تنظیمات
├── package.json
├── tsconfig.json
│
├── blocks/                      ← تعریف هر بلوک (YAML)
│   ├── B01.yaml
│   ├── B02.yaml
│   ├── B03.yaml
│   ├── ...
│   └── B39.yaml
│
├── templates/                   ← قالب‌های پرامپت
│   ├── context-packet.md
│   ├── block-prompt.md
│   ├── fix-prompt.md
│   └── status-check.md
│
├── verifiers/                   ← اسکریپت‌های تأیید هر بلوک
│   ├── verify-B01.ts
│   ├── verify-B02.ts
│   ├── ...
│   └── verify-common.ts
│
├── state/                       ← وضعیت فعلی (اتوماتیک آپدیت می‌شود)
│   ├── tracker.json             ← وضعیت هر بلوک
│   ├── file-registry.json       ← رجیستری تمام فایل‌های ساخته‌شده
│   └── conversation-log.json    ← لاگ مکالمات با ایجنت
│
└── output/                      ← پرامپت‌های تولیدشده
    ├── prompt-B01.md
    ├── prompt-B02.md
    └── ...
۱. فایل تعریف بلوک (Block Definition YAML)
هر بلوک یک فایل YAML مستقل دارد:

YAML

# blocks/B01.yaml

id: B01
name: "Create Empty Next.js Project"
phase: 0
phase_name: "Foundation"

goal: |
  Create a clean, running Next.js project with TypeScript and Tailwind CSS.

dependencies: []  # هیچ بلوک قبلی لازم نیست

files_to_create:
  - id: F001
    path: "package.json"
  - id: F002
    path: "tsconfig.json"
  - id: F003
    path: "next.config.js"
  - id: F004
    path: "tailwind.config.ts"
  - id: F005
    path: ".env.local"
  - id: F006
    path: ".env.example"
  - id: F009
    path: "src/app/globals.css"

files_to_modify: []

files_available: []  # اولین بلوک - هیچ فایلی وجود ندارد

commands:
  - "npx create-next-app@latest cv-tailor-app --typescript --tailwind --eslint --app --src-dir --import-alias \"@/*\""

instructions: |
  Run the create-next-app command with the exact flags specified.
  Do not add any extra files or configurations.
  Make sure .env.local has empty placeholder values.
  Make sure .env.example documents what env vars are needed.

checkpoint_tests:
  - id: T01
    description: "npm run dev runs without errors"
    type: "command"
    command: "cd cv-tailor-app && npm run dev -- --port 3099 &; sleep 5; curl -s -o /dev/null -w '%{http_code}' http://localhost:3099; kill %1"
    expected: "200"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "cd cv-tailor-app && npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "All required files exist"
    type: "files_exist"
    files:
      - "package.json"
      - "tsconfig.json"
      - "next.config.js"
      - "tailwind.config.ts"
      - ".env.local"
      - ".env.example"
      - "src/app/globals.css"

max_retries: 3
YAML

# blocks/B03.yaml

id: B03
name: "Central TypeScript Types"
phase: 0
phase_name: "Foundation"

goal: |
  Define all TypeScript types for the entire project in a single reference file.

dependencies: [B01, B02]

files_to_create:
  - id: F079
    path: "src/lib/types.ts"
    content_source: "inline"  # محتوا در خود YAML هست
    content: |
      // ============================================
      // [F079] src/lib/types.ts
      // Central TypeScript Type Definitions
      // ============================================

      export interface User {
        id: string;
        google_id: string | null;
        email: string;
        name: string;
        avatar_url: string | null;
        preferred_language: 'en' | 'fa';
        created_at: string;
        updated_at: string;
      }

      // ... [rest of types as defined in the plan]

files_to_modify: []

files_available:
  - id: F001
    path: "package.json"
    from_block: B01
  - id: F027
    path: "src/components/ui/button.tsx"
    from_block: B02
  # ... etc

checkpoint_tests:
  - id: T01
    description: "File F079 exists"
    type: "files_exist"
    files:
      - "src/lib/types.ts"

  - id: T02
    description: "TypeScript compiles without errors"
    type: "command"
    command: "npx tsc --noEmit"
    expected_exit_code: 0

  - id: T03
    description: "All interfaces are exported"
    type: "grep"
    file: "src/lib/types.ts"
    patterns:
      - "export interface User"
      - "export interface ComprehensiveCV"
      - "export interface Prompt"
      - "export interface AIApiKey"
      - "export interface JobApplication"
      - "export interface Template"

max_retries: 3
۲. State Tracker
JSON

// state/tracker.json

{
  "project_name": "cv-tailor-app",
  "current_block": "B01",
  "started_at": "2025-01-15T10:00:00Z",
  "blocks": {
    "B01": {
      "status": "pending",
      "started_at": null,
      "completed_at": null,
      "attempts": 0,
      "max_retries": 3,
      "test_results": [],
      "files_created": [],
      "errors": []
    },
    "B02": {
      "status": "pending",
      "started_at": null,
      "completed_at": null,
      "attempts": 0,
      "max_retries": 3,
      "test_results": [],
      "files_created": [],
      "errors": []
    }
  },
  "file_registry": {}
}
JSON

// state/file-registry.json
// بعد از تکمیل هر بلوک آپدیت می‌شود

{
  "F001": {
    "path": "package.json",
    "created_by_block": "B01",
    "modified_by_blocks": ["B02"],
    "exists": true,
    "last_verified": "2025-01-15T10:05:00Z"
  },
  "F002": {
    "path": "tsconfig.json",
    "created_by_block": "B01",
    "modified_by_blocks": [],
    "exists": true,
    "last_verified": "2025-01-15T10:05:00Z"
  }
}
۳. قالب‌های پرامپت (Prompt Templates)
Markdown

<!-- templates/context-packet.md -->

# PROJECT OVERVIEW (Read Only — Do NOT start building yet)

## What we're building
A web app called "CV Tailor" that helps users create tailored CVs,
cover letters, and application emails using AI.

## Tech Stack
- Next.js (App Router) + TypeScript
- Tailwind CSS + shadcn/ui
- Supabase (Database + Auth)
- Vercel (Hosting)
- AI APIs: OpenAI, Anthropic, Google AI

## How we'll work together
- I will give you ONE block at a time
- Each block has a specific goal, specific files, and specific tests
- You MUST complete the checkpoint tests before I give you the next block
- You must NEVER create files that aren't listed in the current block
- You must NEVER import from files that don't exist yet
- After completing each block, list ALL files you created/modified with full paths
- Mark each checkpoint test as PASS or FAIL

Confirm you understand, then I'll give you the first block.
Markdown

<!-- templates/block-prompt.md -->
<!-- متغیرها با {{variable}} مشخص شده‌اند -->

# BLOCK {{block_id}}: {{block_name}}

## COMPLETED BLOCKS
{{completed_blocks_list}}

## GOAL
{{block_goal}}

## FILES TO CREATE
{{files_to_create_list}}

## FILES TO MODIFY
{{files_to_modify_list}}

## EXISTING FILES YOU MAY IMPORT FROM
{{available_files_list}}

## FILES YOU MUST NOT TOUCH
Everything not listed above.

{{#if commands}}
## COMMANDS TO RUN
{{commands_list}}
{{/if}}

{{#if content}}
## EXACT FILE CONTENTS
{{file_contents}}
{{/if}}

## INSTRUCTIONS
{{instructions}}

## CHECKPOINT TESTS (verify ALL after completion)
{{checkpoint_tests_list}}

## MANDATORY RULES
1. Create ONLY the files listed in "FILES TO CREATE"
2. Modify ONLY the files listed in "FILES TO MODIFY"
3. NEVER import from files not in "EXISTING FILES"
4. NEVER reference files that don't exist
5. After completion, list every file you created/modified with full path
6. Mark each checkpoint test as ✅ PASS or ❌ FAIL
7. If unsure about anything, ASK — don't guess
8. Keep each file under 200 lines
9. All user-facing text must use i18n (if i18n is set up)
10. Handle errors gracefully
Markdown

<!-- templates/fix-prompt.md -->

# FIX REQUIRED FOR BLOCK {{block_id}}

## FAILED TESTS
{{failed_tests_list}}

## ERROR DETAILS
{{error_details}}

## FILES YOU MAY MODIFY TO FIX
{{fixable_files_list}}

## RULES
- Fix ONLY the issues listed above
- Do NOT change any other files
- Do NOT refactor or improve unrelated code
- After fixing, re-run all checkpoint tests and report results
Markdown

<!-- templates/status-check.md -->

# STATUS CHECK — After Block {{block_id}}

## Completed Blocks ({{completed_count}}/{{total_count}})
{{completed_blocks_detailed}}

## All Existing Files ({{file_count}} files)
{{all_files_list}}

## Current Phase
Phase {{current_phase}}: {{phase_name}}

## Next Block
{{next_block_id}}: {{next_block_name}}

## Known Issues
{{known_issues}}

---
Confirm this matches your understanding, then I'll give you the next block.
۴. Verification Engine (موتور تأیید)
TypeScript

// verifiers/verify-common.ts

import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

export interface TestResult {
  test_id: string;
  description: string;
  passed: boolean;
  actual_output?: string;
  expected_output?: string;
  error?: string;
}

export interface CheckpointTest {
  id: string;
  description: string;
  type: 'command' | 'files_exist' | 'grep' | 'contains' | 'custom';
  command?: string;
  expected?: string;
  expected_exit_code?: number;
  files?: string[];
  file?: string;
  patterns?: string[];
  custom_fn?: string;
}

const PROJECT_ROOT = path.resolve(__dirname, '../../cv-tailor-app');

export function runTest(test: CheckpointTest): TestResult {
  try {
    switch (test.type) {

      case 'files_exist':
        return verifyFilesExist(test);

      case 'command':
        return verifyCommand(test);

      case 'grep':
        return verifyGrep(test);

      case 'contains':
        return verifyContains(test);

      default:
        return {
          test_id: test.id,
          description: test.description,
          passed: false,
          error: `Unknown test type: ${test.type}`
        };
    }
  } catch (err: any) {
    return {
      test_id: test.id,
      description: test.description,
      passed: false,
      error: err.message
    };
  }
}

function verifyFilesExist(test: CheckpointTest): TestResult {
  const missing: string[] = [];

  for (const file of test.files || []) {
    const fullPath = path.join(PROJECT_ROOT, file);
    if (!fs.existsSync(fullPath)) {
      missing.push(file);
    }
  }

  return {
    test_id: test.id,
    description: test.description,
    passed: missing.length === 0,
    actual_output: missing.length > 0
      ? `Missing files: ${missing.join(', ')}`
      : 'All files exist',
    expected_output: 'All files exist'
  };
}

function verifyCommand(test: CheckpointTest): TestResult {
  try {
    const output = execSync(test.command!, {
      cwd: PROJECT_ROOT,
      timeout: 30000,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });

    if (test.expected) {
      const passed = output.trim().includes(test.expected);
      return {
        test_id: test.id,
        description: test.description,
        passed,
        actual_output: output.trim(),
        expected_output: test.expected
      };
    }

    return {
      test_id: test.id,
      description: test.description,
      passed: true,
      actual_output: 'Command executed successfully'
    };

  } catch (err: any) {
    if (test.expected_exit_code !== undefined) {
      return {
        test_id: test.id,
        description: test.description,
        passed: err.status === test.expected_exit_code,
        actual_output: `Exit code: ${err.status}`,
        expected_output: `Exit code: ${test.expected_exit_code}`,
        error: err.stderr?.toString()
      };
    }

    return {
      test_id: test.id,
      description: test.description,
      passed: false,
      error: err.message
    };
  }
}

function verifyGrep(test: CheckpointTest): TestResult {
  const filePath = path.join(PROJECT_ROOT, test.file!);

  if (!fs.existsSync(filePath)) {
    return {
      test_id: test.id,
      description: test.description,
      passed: false,
      error: `File not found: ${test.file}`
    };
  }

  const content = fs.readFileSync(filePath, 'utf-8');
  const missing: string[] = [];

  for (const pattern of test.patterns || []) {
    if (!content.includes(pattern)) {
      missing.push(pattern);
    }
  }

  return {
    test_id: test.id,
    description: test.description,
    passed: missing.length === 0,
    actual_output: missing.length > 0
      ? `Missing patterns: ${missing.join(', ')}`
      : 'All patterns found',
    expected_output: 'All patterns found'
  };
}

function verifyContains(test: CheckpointTest): TestResult {
  const filePath = path.join(PROJECT_ROOT, test.file!);

  if (!fs.existsSync(filePath)) {
    return {
      test_id: test.id,
      description: test.description,
      passed: false,
      error: `File not found: ${test.file}`
    };
  }

  const content = fs.readFileSync(filePath, 'utf-8');
  const passed = content.includes(test.expected!);

  return {
    test_id: test.id,
    description: test.description,
    passed,
    actual_output: passed ? 'Content found' : 'Content NOT found',
    expected_output: test.expected
  };
}

export function runAllTests(tests: CheckpointTest[]): {
  all_passed: boolean;
  results: TestResult[];
  summary: string;
} {
  const results = tests.map(t => runTest(t));
  const all_passed = results.every(r => r.passed);

  const summary = results.map(r =>
    `${r.passed ? '✅' : '❌'} [${r.test_id}] ${r.description}` +
    (r.error ? `\n   Error: ${r.error}` : '') +
    (!r.passed && r.actual_output ? `\n   Got: ${r.actual_output}` : '') +
    (!r.passed && r.expected_output ? `\n   Expected: ${r.expected_output}` : '')
  ).join('\n');

  return { all_passed, results, summary };
}
۵. مغز اصلی — Orchestrator
TypeScript

// orchestrator.ts

import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'yaml';
import { runAllTests, CheckpointTest, TestResult } from './verifiers/verify-common';

// ═══════════════════════════════════════════
// CONFIGURATION
// ═══════════════════════════════════════════

interface OrchestratorConfig {
  project_path: string;
  blocks_dir: string;
  templates_dir: string;
  state_dir: string;
  output_dir: string;
  agent_mode: 'clipboard' | 'file' | 'api';
  // اگر agent_mode = 'api' باشد:
  agent_api_url?: string;
  agent_api_key?: string;
  // تنظیمات
  auto_advance: boolean;         // آیا بعد از پاس تست، خودکار بره بلوک بعد؟
  status_check_interval: number; // هر چند بلوک، Status Check بده
  max_retries: number;           // حداکثر تلاش برای هر بلوک
}

const CONFIG: OrchestratorConfig = {
  project_path: path.resolve(__dirname, '../cv-tailor-app'),
  blocks_dir: path.resolve(__dirname, 'blocks'),
  templates_dir: path.resolve(__dirname, 'templates'),
  state_dir: path.resolve(__dirname, 'state'),
  output_dir: path.resolve(__dirname, 'output'),
  agent_mode: 'clipboard',      // شروع با حالت clipboard
  auto_advance: false,          // بهتر است دستی تأیید شود
  status_check_interval: 5,
  max_retries: 3
};

// ═══════════════════════════════════════════
// STATE MANAGEMENT
// ═══════════════════════════════════════════

interface BlockState {
  status: 'pending' | 'in_progress' | 'passed' | 'failed' | 'skipped';
  started_at: string | null;
  completed_at: string | null;
  attempts: number;
  test_results: TestResult[];
  files_created: string[];
  files_modified: string[];
  errors: string[];
}

interface ProjectState {
  project_name: string;
  current_block: string | null;
  started_at: string;
  last_updated: string;
  blocks: Record<string, BlockState>;
  file_registry: Record<string, {
    path: string;
    created_by: string;
    modified_by: string[];
    exists: boolean;
  }>;
}

function loadState(): ProjectState {
  const statePath = path.join(CONFIG.state_dir, 'tracker.json');
  if (fs.existsSync(statePath)) {
    return JSON.parse(fs.readFileSync(statePath, 'utf-8'));
  }
  return initState();
}

function saveState(state: ProjectState): void {
  state.last_updated = new Date().toISOString();
  const statePath = path.join(CONFIG.state_dir, 'tracker.json');
  fs.mkdirSync(CONFIG.state_dir, { recursive: true });
  fs.writeFileSync(statePath, JSON.stringify(state, null, 2));
}

function initState(): ProjectState {
  const blockFiles = fs.readdirSync(CONFIG.blocks_dir)
    .filter(f => f.endsWith('.yaml'))
    .sort();

  const blocks: Record<string, BlockState> = {};
  for (const file of blockFiles) {
    const blockId = file.replace('.yaml', '');
    blocks[blockId] = {
      status: 'pending',
      started_at: null,
      completed_at: null,
      attempts: 0,
      test_results: [],
      files_created: [],
      files_modified: [],
      errors: []
    };
  }

  return {
    project_name: 'cv-tailor-app',
    current_block: null,
    started_at: new Date().toISOString(),
    last_updated: new Date().toISOString(),
    blocks,
    file_registry: {}
  };
}

// ═══════════════════════════════════════════
// BLOCK LOADER
// ═══════════════════════════════════════════

interface BlockDefinition {
  id: string;
  name: string;
  phase: number;
  phase_name: string;
  goal: string;
  dependencies: string[];
  files_to_create: { id: string; path: string; content?: string }[];
  files_to_modify: { id: string; path: string }[];
  files_available: { id: string; path: string; from_block: string }[];
  commands: string[];
  instructions: string;
  checkpoint_tests: CheckpointTest[];
  max_retries: number;
}

function loadBlock(blockId: string): BlockDefinition {
  const blockPath = path.join(CONFIG.blocks_dir, `${blockId}.yaml`);
  if (!fs.existsSync(blockPath)) {
    throw new Error(`Block file not found: ${blockPath}`);
  }
  const content = fs.readFileSync(blockPath, 'utf-8');
  return yaml.parse(content);
}

function getBlockOrder(): string[] {
  return fs.readdirSync(CONFIG.blocks_dir)
    .filter(f => f.endsWith('.yaml'))
    .map(f => f.replace('.yaml', ''))
    .sort((a, b) => {
      const numA = parseInt(a.replace('B', ''));
      const numB = parseInt(b.replace('B', ''));
      return numA - numB;
    });
}

// ═══════════════════════════════════════════
// PROMPT BUILDER
// ═══════════════════════════════════════════

function buildPrompt(block: BlockDefinition, state: ProjectState): string {
  const template = fs.readFileSync(
    path.join(CONFIG.templates_dir, 'block-prompt.md'),
    'utf-8'
  );

  // بلوک‌های تکمیل‌شده
  const completedBlocks = Object.entries(state.blocks)
    .filter(([_, s]) => s.status === 'passed')
    .map(([id, s]) => {
      const b = loadBlock(id);
      const files = s.files_created.map(f => `[${f}]`).join(', ');
      return `- ${id} ✅: ${b.name} — Files: ${files}`;
    })
    .join('\n');

  // فایل‌های قابل ایجاد
  const filesToCreate = block.files_to_create
    .map(f => `[${f.id}] ${f.path}`)
    .join('\n');

  // فایل‌های قابل تغییر
  const filesToModify = block.files_to_modify.length > 0
    ? block.files_to_modify.map(f => `[${f.id}] ${f.path}`).join('\n')
    : 'None';

  // فایل‌های موجود
  const availableFiles = Object.entries(state.file_registry)
    .filter(([_, info]) => info.exists)
    .map(([id, info]) => `[${id}] ${info.path} (from ${info.created_by})`)
    .join('\n') || 'None — this is the first block.';

  // دستورات
  const commands = block.commands.length > 0
    ? block.commands.map(c => `\`\`\`\n${c}\n\`\`\``).join('\n')
    : '';

  // تست‌ها
  const tests = block.checkpoint_tests
    .map(t => `□ [${t.id}] ${t.description}`)
    .join('\n');

  // محتوای فایل‌ها (اگر inline باشد)
  const fileContents = block.files_to_create
    .filter(f => f.content)
    .map(f => `### [${f.id}] ${f.path}\n\`\`\`typescript\n${f.content}\n\`\`\``)
    .join('\n\n');

  // ساخت پرامپت نهایی
  let prompt = `# BLOCK ${block.id}: ${block.name}\n\n`;
  prompt += `## COMPLETED BLOCKS\n${completedBlocks || 'None yet'}\n\n`;
  prompt += `## GOAL\n${block.goal}\n\n`;
  prompt += `## FILES TO CREATE\n${filesToCreate}\n\n`;
  prompt += `## FILES TO MODIFY\n${filesToModify}\n\n`;
  prompt += `## EXISTING FILES YOU MAY IMPORT FROM\n${availableFiles}\n\n`;
  prompt += `## FILES YOU MUST NOT TOUCH\nEverything not listed above.\n\n`;

  if (commands) {
    prompt += `## COMMANDS TO RUN\n${commands}\n\n`;
  }

  if (fileContents) {
    prompt += `## EXACT FILE CONTENTS\n${fileContents}\n\n`;
  }

  prompt += `## INSTRUCTIONS\n${block.instructions}\n\n`;
  prompt += `## CHECKPOINT TESTS (verify ALL after completion)\n${tests}\n\n`;

  prompt += `## MANDATORY RULES\n`;
  prompt += `1. Create ONLY the files listed in "FILES TO CREATE"\n`;
  prompt += `2. Modify ONLY the files listed in "FILES TO MODIFY"\n`;
  prompt += `3. NEVER import from files not in "EXISTING FILES"\n`;
  prompt += `4. NEVER reference files that don't exist\n`;
  prompt += `5. After completion, list every file you created/modified with full path\n`;
  prompt += `6. Mark each checkpoint test as ✅ PASS or ❌ FAIL\n`;
  prompt += `7. If unsure about anything, ASK — don't guess\n`;
  prompt += `8. Keep each file under 200 lines\n`;
  prompt += `9. All user-facing text must use i18n (if i18n is set up)\n`;
  prompt += `10. Handle errors gracefully\n`;

  return prompt;
}

function buildFixPrompt(
  block: BlockDefinition,
  failedTests: TestResult[]
): string {
  let prompt = `# FIX REQUIRED FOR BLOCK ${block.id}\n\n`;

  prompt += `## FAILED TESTS\n`;
  for (const t of failedTests) {
    prompt += `### ❌ [${t.test_id}] ${t.description}\n`;
    if (t.error) prompt += `**Error:** ${t.error}\n`;
    if (t.actual_output) prompt += `**Got:** ${t.actual_output}\n`;
    if (t.expected_output) prompt += `**Expected:** ${t.expected_output}\n`;
    prompt += '\n';
  }

  prompt += `## FILES YOU MAY MODIFY TO FIX\n`;
  const allFiles = [
    ...block.files_to_create.map(f => `[${f.id}] ${f.path}`),
    ...block.files_to_modify.map(f => `[${f.id}] ${f.path}`)
  ];
  prompt += allFiles.join('\n') + '\n\n';

  prompt += `## RULES\n`;
  prompt += `- Fix ONLY the issues listed above\n`;
  prompt += `- Do NOT change any other files\n`;
  prompt += `- Do NOT refactor or improve unrelated code\n`;
  prompt += `- After fixing, re-verify all checkpoint tests\n`;

  return prompt;
}

function buildStatusCheck(state: ProjectState): string {
  const blockOrder = getBlockOrder();
  const completed = blockOrder.filter(id => state.blocks[id]?.status === 'passed');
  const total = blockOrder.length;

  let check = `# STATUS CHECK\n\n`;
  check += `## Completed Blocks (${completed.length}/${total})\n`;

  for (const id of completed) {
    const block = loadBlock(id);
    const blockState = state.blocks[id];
    const files = blockState.files_created.join(', ');
    check += `- ${id} ✅: ${block.name} — [${files}]\n`;
  }

  check += `\n## All Existing Files (${Object.keys(state.file_registry).length} files)\n`;
  for (const [fileId, info] of Object.entries(state.file_registry)) {
    if (info.exists) {
      check += `- [${fileId}] ${info.path}\n`;
    }
  }

  const nextBlock = blockOrder.find(id => state.blocks[id]?.status === 'pending');
  if (nextBlock) {
    const nb = loadBlock(nextBlock);
    check += `\n## Next Block\n${nextBlock}: ${nb.name}\n`;
  }

  check += `\nConfirm this matches your understanding, then I'll give you the next block.\n`;

  return check;
}

// ═══════════════════════════════════════════
// MAIN ORCHESTRATOR LOGIC
// ═══════════════════════════════════════════

function checkDependencies(block: BlockDefinition, state: ProjectState): {
  satisfied: boolean;
  missing: string[];
} {
  const missing = block.dependencies.filter(
    dep => state.blocks[dep]?.status !== 'passed'
  );
  return {
    satisfied: missing.length === 0,
    missing
  };
}

function updateFileRegistry(
  state: ProjectState,
  block: BlockDefinition
): void {
  for (const file of block.files_to_create) {
    state.file_registry[file.id] = {
      path: file.path,
      created_by: block.id,
      modified_by: [],
      exists: true
    };
  }
  for (const file of block.files_to_modify) {
    if (state.file_registry[file.id]) {
      state.file_registry[file.id].modified_by.push(block.id);
    }
  }
}

async function processBlock(blockId: string): Promise<void> {
  const state = loadState();
  const block = loadBlock(blockId);

  console.log(`\n${'═'.repeat(60)}`);
  console.log(`  BLOCK ${block.id}: ${block.name}`);
  console.log(`  Phase ${block.phase}: ${block.phase_name}`);
  console.log(`${'═'.repeat(60)}\n`);

  // 1. بررسی وابستگی‌ها
  const deps = checkDependencies(block, state);
  if (!deps.satisfied) {
    console.error(`❌ Dependencies not met: ${deps.missing.join(', ')}`);
    return;
  }
  console.log('✅ Dependencies satisfied');

  // 2. ساخت پرامپت
  const prompt = buildPrompt(block, state);

  // 3. ذخیره پرامپت
  fs.mkdirSync(CONFIG.output_dir, { recursive: true });
  const promptPath = path.join(CONFIG.output_dir, `prompt-${blockId}.md`);
  fs.writeFileSync(promptPath, prompt);
  console.log(`📝 Prompt saved to: ${promptPath}`);

  // 4. ارسال به ایجنت (بسته به حالت)
  switch (CONFIG.agent_mode) {
    case 'clipboard':
      await copyToClipboard(prompt);
      console.log('📋 Prompt copied to clipboard!');
      console.log('   → Paste into agent, wait for completion');
      console.log('   → Then run: npm run verify <blockId>');
      break;

    case 'file':
      console.log(`📄 Prompt written to: ${promptPath}`);
      console.log('   → Feed this file to the agent');
      console.log('   → Then run: npm run verify <blockId>');
      break;

    case 'api':
      console.log('🤖 Sending to agent API...');
      // await sendToAgentAPI(prompt);
      break;
  }

  // 5. آپدیت وضعیت
  state.current_block = blockId;
  state.blocks[blockId].status = 'in_progress';
  state.blocks[blockId].started_at = new Date().toISOString();
  state.blocks[blockId].attempts += 1;
  saveState(state);
}

async function verifyBlock(blockId: string): Promise<void> {
  const state = loadState();
  const block = loadBlock(blockId);

  console.log(`\n🔍 Verifying Block ${blockId}...\n`);

  // اجرای تمام تست‌ها
  const { all_passed, results, summary } = runAllTests(block.checkpoint_tests);

  console.log(summary);
  console.log(`\n${'─'.repeat(40)}`);

  state.blocks[blockId].test_results = results;

  if (all_passed) {
    // ✅ همه تست‌ها پاس شدند
    console.log(`\n✅ BLOCK ${blockId} PASSED!\n`);

    state.blocks[blockId].status = 'passed';
    state.blocks[blockId].completed_at = new Date().toISOString();
    state.blocks[blockId].files_created = block.files_to_create.map(f => f.id);
    state.blocks[blockId].files_modified = block.files_to_modify.map(f => f.id);

    updateFileRegistry(state, block);
    saveState(state);

    // آیا وقت Status Check هست؟
    const completedCount = Object.values(state.blocks)
      .filter(b => b.status === 'passed').length;

    if (completedCount % CONFIG.status_check_interval === 0) {
      const statusCheck = buildStatusCheck(state);
      const statusPath = path.join(
        CONFIG.output_dir,
        `status-check-after-${blockId}.md`
      );
      fs.writeFileSync(statusPath, statusCheck);
      console.log(`📊 Status check saved to: ${statusPath}`);
    }

    // بلوک بعدی
    const nextBlock = findNextBlock(state);
    if (nextBlock) {
      console.log(`\n➡️  Next block: ${nextBlock}`);
      if (CONFIG.auto_advance) {
        await processBlock(nextBlock);
      } else {
        console.log(`   Run: npm run block ${nextBlock}`);
      }
    } else {
      console.log(`\n🎉 ALL BLOCKS COMPLETED!`);
    }

  } else {
    // ❌ بعضی تست‌ها فیل شدند
    const failedTests = results.filter(r => !r.passed);
    console.log(`\n❌ BLOCK ${blockId} FAILED (${failedTests.length} tests failed)\n`);

    state.blocks[blockId].status = 'failed';
    state.blocks[blockId].errors.push(
      ...failedTests.map(t => `[${t.test_id}] ${t.error || t.actual_output}`)
    );
    saveState(state);

    // ساخت پرامپت اصلاحی
    if (state.blocks[blockId].attempts < block.max_retries) {
      const fixPrompt = buildFixPrompt(block, failedTests);
      const fixPath = path.join(
        CONFIG.output_dir,
        `fix-${blockId}-attempt${state.blocks[blockId].attempts}.md`
      );
      fs.writeFileSync(fixPath, fixPrompt);
      console.log(`🔧 Fix prompt saved to: ${fixPath}`);

      if (CONFIG.agent_mode === 'clipboard') {
        await copyToClipboard(fixPrompt);
        console.log('📋 Fix prompt copied to clipboard!');
      }
    } else {
      console.log(`\n⛔ Max retries (${block.max_retries}) reached for ${blockId}`);
      console.log('   Manual intervention required.');
    }
  }
}

function findNextBlock(state: ProjectState): string | null {
  const blockOrder = getBlockOrder();

  for (const blockId of blockOrder) {
    if (state.blocks[blockId]?.status === 'pending') {
      const block = loadBlock(blockId);
      const deps = checkDependencies(block, state);
      if (deps.satisfied) {
        return blockId;
      }
    }
  }
  return null;
}

function showDashboard(): void {
  const state = loadState();
  const blockOrder = getBlockOrder();

  console.log(`\n${'═'.repeat(60)}`);
  console.log('  CV TAILOR — ORCHESTRATOR DASHBOARD');
  console.log(`${'═'.repeat(60)}\n`);

  const statusIcons: Record<string, string> = {
    pending: '⬜',
    in_progress: '🔨',
    passed: '✅',
    failed: '❌',
    skipped: '⏭️'
  };

  let currentPhase = -1;

  for (const blockId of blockOrder) {
    const block = loadBlock(blockId);
    const blockState = state.blocks[blockId];
    const icon = statusIcons[blockState?.status || 'pending'];

    if (block.phase !== currentPhase) {
      currentPhase = block.phase;
      console.log(`\n── Phase ${block.phase}: ${block.phase_name} ──`);
    }

    const attempts = blockState?.attempts
      ? ` (attempts: ${blockState.attempts})`
      : '';

    console.log(`  ${icon} ${blockId}: ${block.name}${attempts}`);
  }

  const completed = Object.values(state.blocks)
    .filter(b => b.status === 'passed').length;
  const total = blockOrder.length;
  const percentage = Math.round((completed / total) * 100);

  console.log(`\n${'─'.repeat(60)}`);
  console.log(`  Progress: ${completed}/${total} (${percentage}%)`);
  console.log(`  Files created: ${Object.keys(state.file_registry).length}`);

  const nextBlock = findNextBlock(state);
  if (nextBlock) {
    console.log(`  Next: ${nextBlock}`);
  }
  console.log(`${'═'.repeat(60)}\n`);
}

// ═══════════════════════════════════════════
// CLIPBOARD UTILITY
// ═══════════════════════════════════════════

async function copyToClipboard(text: string): Promise<void> {
  const { execSync } = require('child_process');
  const platform = process.platform;

  try {
    if (platform === 'darwin') {
      execSync('pbcopy', { input: text });
    } else if (platform === 'win32') {
      execSync('clip', { input: text });
    } else {
      execSync('xclip -selection clipboard', { input: text });
    }
  } catch {
    console.log('⚠️  Could not copy to clipboard. Use the saved file instead.');
  }
}

// ═══════════════════════════════════════════
// CLI INTERFACE
// ═══════════════════════════════════════════

const command = process.argv[2];
const arg = process.argv[3];

switch (command) {
  case 'init':
    const freshState = initState();
    saveState(freshState);
    console.log('✅ Orchestrator initialized');
    showDashboard();
    break;

  case 'dashboard':
  case 'status':
    showDashboard();
    break;

  case 'context':
    // ارسال Context Packet اولیه
    const contextTemplate = fs.readFileSync(
      path.join(CONFIG.templates_dir, 'context-packet.md'),
      'utf-8'
    );
    copyToClipboard(contextTemplate);
    console.log('📋 Context packet copied to clipboard!');
    console.log('   → Paste into agent as first message');
    console.log('   → After agent confirms, run: npm run block B01');
    break;

  case 'block':
    if (!arg) {
      console.error('Usage: npm run block <blockId>');
      console.error('Example: npm run block B01');
      process.exit(1);
    }
    processBlock(arg);
    break;

  case 'verify':
    if (!arg) {
      console.error('Usage: npm run verify <blockId>');
      process.exit(1);
    }
    verifyBlock(arg);
    break;

  case 'next':
    const nextState = loadState();
    const nextId = findNextBlock(nextState);
    if (nextId) {
      processBlock(nextId);
    } else {
      console.log('🎉 All blocks completed!');
    }
    break;

  case 'retry':
    if (!arg) {
      console.error('Usage: npm run retry <blockId>');
      process.exit(1);
    }
    const retryState = loadState();
    retryState.blocks[arg].status = 'pending';
    saveState(retryState);
    processBlock(arg);
    break;

  case 'reset':
    if (arg === 'all') {
      const resetState = initState();
      saveState(resetState);
      console.log('🔄 Full reset complete');
    } else if (arg) {
      const partialState = loadState();
      partialState.blocks[arg] = {
        status: 'pending',
        started_at: null,
        completed_at: null,
        attempts: 0,
        test_results: [],
        files_created: [],
        files_modified: [],
        errors: []
      };
      saveState(partialState);
      console.log(`🔄 Block ${arg} reset`);
    }
    break;

  default:
    console.log(`
╔══════════════════════════════════════════╗
║     CV TAILOR ORCHESTRATOR               ║
╠══════════════════════════════════════════╣
║                                          ║
║  Commands:                               ║
║                                          ║
║  npm run orch init       Initialize      ║
║  npm run orch context    Send context    ║
║  npm run orch block B01  Process block   ║
║  npm run orch verify B01 Verify block    ║
║  npm run orch next       Next block      ║
║  npm run orch retry B01  Retry block     ║
║  npm run orch dashboard  Show status     ║
║  npm run orch reset all  Reset all       ║
║  npm run orch reset B01  Reset block     ║
║                                          ║
╚══════════════════════════════════════════╝
    `);
}
۶. فایل package.json ارکستراتور
JSON

{
  "name": "cv-tailor-orchestrator",
  "version": "1.0.0",
  "scripts": {
    "orch": "ts-node orchestrator.ts",
    "init": "ts-node orchestrator.ts init",
    "context": "ts-node orchestrator.ts context",
    "block": "ts-node orchestrator.ts block",
    "verify": "ts-node orchestrator.ts verify",
    "next": "ts-node orchestrator.ts next",
    "dashboard": "ts-node orchestrator.ts dashboard",
    "retry": "ts-node orchestrator.ts retry",
    "reset": "ts-node orchestrator.ts reset"
  },
  "dependencies": {
    "yaml": "^2.3.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "ts-node": "^10.9.0",
    "@types/node": "^20.0.0"
  }
}
فرایند کار روزانه تو
text

صبح شروع کار:

$ npm run dashboard

═══════════════════════════════════════
  CV TAILOR — ORCHESTRATOR DASHBOARD
═══════════════════════════════════════

── Phase 0: Foundation ──
  ✅ B01: Create Empty Next.js Project
  ✅ B02: Install All Dependencies
  ✅ B03: Central TypeScript Types
  ✅ B04: Constants and Utilities
  🔨 B05: i18n System (attempts: 1)
  ⬜ B06: Supabase Connection
  ⬜ B07: Development Auth
  ⬜ B08: Main Layout

── Phase 1: CV Management ──
  ⬜ B09: File Parsers
  ...

  Progress: 4/39 (10%)
  Next: B05

──────────────────────────────────────


$ npm run verify B05        ← تست بلوک فعلی

🔍 Verifying Block B05...

✅ [T01] i18n config file exists
✅ [T02] English translations file exists
❌ [T03] Farsi translations file exists
   Error: File not found: src/i18n/fa.json
✅ [T04] Middleware configured

❌ BLOCK B05 FAILED (1 test failed)

🔧 Fix prompt copied to clipboard!   ← خودکار پرامپت اصلاحی ساخته شد


[پرامپت را paste می‌کنی در ایجنت]
[ایجنت اصلاح می‌کند]


$ npm run verify B05        ← دوباره تست

✅ [T01] i18n config file exists
✅ [T02] English translations file exists
✅ [T03] Farsi translations file exists
✅ [T04] Middleware configured

✅ BLOCK B05 PASSED!

➡️  Next block: B06
   Run: npm run block B06


$ npm run block B06         ← پرامپت بلوک بعدی ساخته و کپی شد

📋 Prompt copied to clipboard!
   → Paste into agent


[ادامه...]
خلاصه
text

┌─────────────────────────────────────────────┐
│                                               │
│   تو فقط ۳ دستور تکرار می‌کنی:              │
│                                               │
│   1. npm run block B__    ← پرامپت بساز      │
│   2. [paste در ایجنت]     ← ایجنت کار کند   │
│   3. npm run verify B__   ← تست کن           │
│                                               │
│   اگر فیل شد:                                │
│   → خودکار Fix Prompt ساخته می‌شود           │
│   → paste کن و دوباره verify کن              │
│                                               │
│   اگر پاس شد:                                │
│   → خودکار بلوک بعدی پیشنهاد می‌شود         │
│                                               │
│   هر ۵ بلوک:                                  │
│   → خودکار Status Check تولید می‌شود         │
│                                               │
└─────────────────────────────────────────────┘
آیا می‌خواهی فایل‌های YAML تمام ۳۹ بلوک را هم بنویسم تا سیستم ارکستراتور آماده اجرا باشد؟





ایا نمیتوان اسکریپتی نوشت که همین کار دادن بلاک ها به ایجنت را اتوماتیک انجام دهد با رعایت الزامات و هر چیز دیگری ؟

claude-opus-4-6-thinking

Thought for 1 second

نه! قطعاً نه.
اگر همه را یکجا بدهی، دقیقاً همان سه مشکل اصلی رخ می‌دهد: توهم، گم‌شدن، گیج‌شدن.

استراتژی تغذیه ایجنت (Agent Feeding Strategy)
text

تصور کن ایجنت مثل یک کارگر ماهر ولی فراموش‌کار است.

❌ غلط: نقشه کل ساختمان ۱۰ طبقه را بده و بگو بساز
✅ درست: نقشه فونداسیون را بده، بعد تأیید کن، بعد نقشه طبقه اول را بده
دقیقاً چه چیزی، چه وقتی
📦 لایه ۱: فقط یک‌بار در ابتدا (Context Packet)
یک پیام اولیه به ایجنت بده که شامل فقط این‌ها باشد:

Markdown

# PROJECT OVERVIEW (Read Only — Do NOT start building yet)

## What we're building
A web app called "CV Tailor" that helps users create tailored CVs, 
cover letters, and application emails using AI.

## Tech Stack
- Next.js (App Router) + TypeScript
- Tailwind CSS + shadcn/ui
- Supabase (Database + Auth)
- Vercel (Hosting)
- AI APIs: OpenAI, Anthropic, Google AI

## How we'll work together
- I will give you ONE block at a time
- Each block has a specific goal, specific files, and specific tests
- You MUST complete the checkpoint tests before I give you the next block
- You must NEVER create files that aren't listed in the current block
- You must NEVER import from files that don't exist yet

## File Numbering System
Every file in this project has a tracking ID like [F001], [F002], etc.
Every directory has an ID like [D001], [D002], etc.
I will tell you which IDs exist at each step.

Confirm you understand, then I'll give you Block B01.
هیچ چیز دیگری ندهید. نه ساختار فایل کامل، نه لیست بلوک‌ها، نه جزئیات فازها.

📦 لایه ۲: بلوک به بلوک (Block Packets)
بعد از تأیید ایجنت، فقط بلوک B01 را بده:

Markdown

# BLOCK B01: Create Empty Next.js Project

## GOAL
Create a clean, running Next.js project with TypeScript and Tailwind.

## FILES TO CREATE
[F001] package.json
[F002] tsconfig.json
[F003] next.config.js
[F004] tailwind.config.ts
[F005] .env.local
[F006] .env.example
[F009] src/app/globals.css

## EXISTING FILES YOU CAN REFERENCE
None — this is the first block.

## EXACT COMMANDS
npx create-next-app@latest cv-tailor-app --typescript --tailwind --eslint --app --src-dir --import-alias "@/*"

## CHECKPOINT TESTS (you must verify ALL)
□ npm run dev runs without errors
□ localhost:3000 shows the default page
□ Files [F001] through [F006] and [F009] exist
□ TypeScript compiles without errors

## RULES
1. Create ONLY the files listed above
2. Do NOT create any additional files or folders
3. After completion, list every file you created with its full path
4. Mark each checkpoint test as ✅ or ❌
📦 لایه ۳: بعد از تأیید هر بلوک (Context Update)
وقتی بلوک B01 تمام شد و تست‌ها پاس شدند، بلوک B02 را با آپدیت زمینه بده:

Markdown

# BLOCK B02: Install All Dependencies

## COMPLETED BLOCKS
- B01 ✅ — Files created: [F001]-[F006], [F009]

## GOAL
Install all required npm packages for the project.

## FILES TO MODIFY
[F001] package.json (will be updated by npm install)

## FILES TO CREATE
[F027]-[F036] src/components/ui/*.tsx (created by shadcn CLI)

## EXISTING FILES (from B01)
[F001] package.json ← you can reference this
[F009] src/app/globals.css ← shadcn may modify this

## EXACT COMMANDS
[paste the npm install commands from the plan]

## CHECKPOINT TESTS
□ npm run dev runs without errors
□ No peer dependency conflicts
□ shadcn components exist in src/components/ui/
□ [F027]-[F036] all exist

## RULES
[same rules as always]
الگوی تصمیم‌گیری: چه وقت بلوک بعدی را بده
text

                    ┌──────────────────┐
                    │  بلوک را بده     │
                    └────────┬─────────┘
                             │
                             ▼
                    ┌──────────────────┐
                    │ ایجنت کد نوشت    │
                    └────────┬─────────┘
                             │
                             ▼
                   ┌───────────────────┐
                   │ Checkpoint Tests  │
                   │ همه پاس شدند؟    │
                   └─────────┬─────────┘
                             │
                     ┌───────┴───────┐
                     │               │
                    بله             نه
                     │               │
                     ▼               ▼
              ┌─────────────┐ ┌──────────────┐
              │ وضعیت بلوک  │ │ از ایجنت بخواه│
              │ را ✅ ثبت کن│ │ اصلاح کند    │
              └──────┬──────┘ └──────┬───────┘
                     │               │
                     ▼               │
              ┌─────────────┐        │
              │ بلوک بعدی   │◄───────┘
              │ را بده      │  (بعد از اصلاح)
              └─────────────┘
⚠️ نکات حیاتی
۱. هرگز بیش از یک بلوک ندهید
text

❌  "بلوک B09 تا B14 را بساز"
✅  "بلوک B09 را بساز"
۲. همیشه لیست فایل‌های موجود را بده
text

❌  "حالا بلوک B10 را بساز"
✅  "بلوک B10 را بساز. فایل‌های موجود:
     [F001]-[F009] از B01
     [F027]-[F036] از B02
     [F078]-[F080] از B04
     [F072]-[F073] از B09
     تو فقط [F074] را می‌سازی"
۳. وقتی ایجنت اشتباه کرد، فقط همان بلوک را تکرار کن
text

❌  "این غلط بود، بیا همه چیز را از اول بنویسیم"
✅  "فایل [F072] خطا دارد. خط ۴۵ این خطا را می‌دهد: [error].
     فقط این فایل را اصلاح کن. هیچ فایل دیگری را تغییر نده."
۴. هر ۵ بلوک، یک خلاصه وضعیت بده
Markdown

# STATUS CHECK (after B10)

## Completed Blocks
- B01 ✅ — Project setup
- B02 ✅ — Dependencies installed  
- B03 ✅ — TypeScript types [F079]
- B04 ✅ — Constants [F078] + Utils [F080]
- B05 ✅ — i18n system [F086]-[F088], [F030]
- B06 ✅ — Supabase [F063]-[F064]
- B07 ✅ — Dev auth [F008], [F010], [F011]
- B08 ✅ — Layout [F037]-[F040]
- B09 ✅ — File parsers [F072]-[F073]
- B10 ✅ — CV field extractor [F074]

## All Existing Files
[list every file with its ID]

## Next Block
B11: CV Uploader Component

## Known Issues
None (or list any)
۵. اگر ایجنت گیر کرد، مشکل را ایزوله کن
text

❌  "کل صفحه CV Manager کار نمی‌کند"
✅  "فایل [F041] CVUploader.tsx وقتی فایل .docx آپلود می‌شود
     این خطا می‌دهد: [exact error message].
     فایل [F072] docx-parser.ts را بررسی کن.
     هیچ فایل دیگری را تغییر نده."
یک جدول مرجع برایت (نگه‌ دار)
این جدول را بعد از هر بلوک خودت پر کن و نسخه به‌روز آن را به ایجنت بده:

text

| بلوک | وضعیت | تاریخ  | فایل‌های ایجاد/تغییر      | مشکلات |
|------|-------|--------|---------------------------|--------|
| B01  | ✅    | ----   | F001-F006, F009           | —      |
| B02  | ✅    | ----   | F001(upd), F027-F036      | —      |
| B03  | ⬜    |        |                           |        |
| B04  | ⬜    |        |                           |        |
| ...  |       |        |                           |        |
خلاصه نهایی
text

┌─────────────────────────────────────────────────┐
│                                                   │
│   ۱. Context Packet (یک‌بار)                     │
│      → ایجنت می‌فهمد چه پروژه‌ای است            │
│                                                   │
│   ۲. Block Packet (هر بار یکی)                   │
│      → ایجنت فقط یک کار کوچک می‌کند             │
│                                                   │
│   ۳. Checkpoint (تو تأیید می‌کنی)               │
│      → قبل از رفتن به بلوک بعدی                  │
│                                                   │
│   ۴. Context Update (در بلوک بعدی)               │
│      → ایجنت می‌داند چه چیزهایی وجود دارند       │
│                                                   │
│   ۵. Status Check (هر ۵ بلوک)                    │
│      → مرور کلی برای جلوگیری از drift            │
│                                                   │
└─────────────────────────────────────────────────┘
به‌ زبان ساده: تو نقش سرکارگر را داری و ایجنت نقش کارگر ماهر. هر بار یک دستور کار مشخص بده، نتیجه را بررسی کن، بعد دستور بعدی را بده.





ایا همه طرح کلی را یک جا به ایجنت بدهم؟

claude-opus-4-6-thinking

Thought for 3 seconds

طرح اجرایی مهار‌شده برای ایجنت Antigravity
مشکل اصلی و راه‌حل
ایجنت‌های AI سه مشکل اصلی دارند:

توهم‌زنی — به فایل‌ها/توابعی ارجاع می‌دهند که وجود ندارند
گم‌کردن مختصات — فراموش می‌کنند چه چیزی کجا ساخته شده
گیج‌شدن در پیچیدگی — وقتی همه چیز یکجا بهشان داده شود
راه‌حل: سیستم «بلوک‌سازی کنترل‌شده»

ساختار کلی طرح
text

┌─────────────────────────────────────────────────────┐
│                  MASTER BLUEPRINT                     │
│         (سند مرجع که همیشه به‌روز است)                │
│                                                       │
│  ● نقشه فایل‌ها (چه فایلی کجاست)                     │
│  ● نقشه وابستگی‌ها (چه چیزی به چه چیزی وصل است)     │
│  ● وضعیت هر بلوک (ساخته‌شده / تست‌شده / تأیید‌شده)  │
│  ● قراردادهای نام‌گذاری                               │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────┐
│              EXECUTION BLOCKS                        │
│         (بلوک‌های اجرایی اتمیک)                      │
│                                                       │
│  هر بلوک شامل:                                       │
│  ● یک هدف واحد و کوچک                               │
│  ● لیست دقیق فایل‌هایی که باید ایجاد/تغییر شوند    │
│  ● ورودی‌ها (از بلوک‌های قبلی)                       │
│  ● خروجی‌ها (برای بلوک‌های بعدی)                     │
│  ● تست تأیید (Checkpoint)                            │
│  ● معیار قبولی (Acceptance Criteria)                 │
└─────────────────────────────────────────────────────┘
سند شماره ۱: MASTER BLUEPRINT (نقشه مادر)
این سند قبل از شروع هر بلوک به ایجنت داده می‌شود تا بداند الان کجاست

۱.۱ نقشه کامل ساختار فایل‌ها (با شماره ردیابی)
text

کل پروژه: cv-tailor-app/

[F001] ── package.json
[F002] ── tsconfig.json
[F003] ── next.config.js
[F004] ── tailwind.config.ts
[F005] ── .env.local
[F006] ── .env.example

[D001] ── src/
│
├── [D002] ── app/
│   ├── [F007] ── layout.tsx                    (Root Layout)
│   ├── [F008] ── page.tsx                      (Landing Page)
│   ├── [F009] ── globals.css
│   │
│   ├── [D003] ── [locale]/
│   │   ├── [F010] ── layout.tsx                (Locale Layout)
│   │   ├── [F011] ── page.tsx                  (Localized Landing)
│   │   │
│   │   ├── [D004] ── dashboard/
│   │   │   └── [F012] ── page.tsx              (Dashboard)
│   │   │
│   │   ├── [D005] ── cv-manager/
│   │   │   └── [F013] ── page.tsx              (CV Management)
│   │   │
│   │   ├── [D006] ── new-application/
│   │   │   └── [F014] ── page.tsx              (New Application Wizard)
│   │   │
│   │   ├── [D007] ── prompts/
│   │   │   └── [F015] ── page.tsx              (Prompt Management)
│   │   │
│   │   ├── [D008] ── settings/
│   │   │   └── [F016] ── page.tsx              (Settings)
│   │   │
│   │   └── [D009] ── applications/
│   │       ├── [F017] ── page.tsx              (Applications List)
│   │       └── [D010] ── [id]/
│   │           └── [F018] ── page.tsx          (Application Detail)
│   │
│   └── [D011] ── api/
│       ├── [D012] ── ai/
│       │   ├── [F019] ── chat/route.ts         (AI Chat Endpoint)
│       │   ├── [F020] ── validate-key/route.ts (Key Validation)
│       │   └── [F021] ── models/route.ts       (Available Models)
│       │
│       ├── [D013] ── cv/
│       │   ├── [F022] ── parse/route.ts        (CV Parsing)
│       │   └── [F023] ── export/route.ts       (CV Export)
│       │
│       ├── [D014] ── prompts/
│       │   └── [F024] ── route.ts              (Prompts CRUD)
│       │
│       └── [D015] ── export/
│           ├── [F025] ── docx/route.ts         (Word Export)
│           └── [F026] ── markdown/route.ts     (Markdown Export)
│
├── [D016] ── components/
│   ├── [D017] ── ui/                           (shadcn components)
│   │   ├── [F027] ── button.tsx
│   │   ├── [F028] ── input.tsx
│   │   ├── [F029] ── card.tsx
│   │   ├── [F030] ── dialog.tsx
│   │   ├── [F031] ── select.tsx
│   │   ├── [F032] ── textarea.tsx
│   │   ├── [F033] ── tabs.tsx
│   │   ├── [F034] ── badge.tsx
│   │   ├── [F035] ── toast.tsx
│   │   └── [F036] ── dropdown-menu.tsx
│   │
│   ├── [D018] ── layout/
│   │   ├── [F037] ── Header.tsx
│   │   ├── [F038] ── Sidebar.tsx
│   │   ├── [F039] ── Footer.tsx
│   │   └── [F040] ── LanguageSwitcher.tsx
│   │
│   ├── [D019] ── cv/
│   │   ├── [F041] ── CVUploader.tsx
│   │   ├── [F042] ── CVFieldExtractor.tsx
│   │   ├── [F043] ── CVCompletionForm.tsx
│   │   └── [F044] ── CVPreview.tsx
│   │
│   ├── [D020] ── prompts/
│   │   ├── [F045] ── PromptList.tsx
│   │   ├── [F046] ── PromptEditor.tsx
│   │   ├── [F047] ── PromptSelector.tsx
│   │   └── [F048] ── PromptCategoryFilter.tsx
│   │
│   ├── [D021] ── ai/
│   │   ├── [F049] ── AIKeyManager.tsx
│   │   ├── [F050] ── AIModelSelector.tsx
│   │   ├── [F051] ── AIConnectionStatus.tsx
│   │   ├── [F052] ── AIChatInterface.tsx
│   │   └── [F053] ── AIMultiDraftPanel.tsx
│   │
│   ├── [D022] ── application/
│   │   ├── [F054] ── JobDescriptionInput.tsx
│   │   ├── [F055] ── ToneSelector.tsx
│   │   ├── [F056] ── LanguageSelector.tsx
│   │   ├── [F057] ── OutputEditor.tsx
│   │   ├── [F058] ── DocumentPreview.tsx
│   │   └── [F059] ── DownloadPanel.tsx
│   │
│   └── [D023] ── templates/
│       ├── [F060] ── TemplateUploader.tsx
│       ├── [F061] ── TemplateSelector.tsx
│       └── [F062] ── TemplatePreview.tsx
│
├── [D024] ── lib/
│   ├── [F063] ── supabase/client.ts            (Supabase Browser Client)
│   ├── [F064] ── supabase/server.ts            (Supabase Server Client)
│   ├── [F065] ── supabase/middleware.ts         (Auth Middleware)
│   │
│   ├── [D025] ── ai/
│   │   ├── [F066] ── ai-provider.ts            (Abstract AI Provider Interface)
│   │   ├── [F067] ── openai-provider.ts         (OpenAI Implementation)
│   │   ├── [F068] ── anthropic-provider.ts      (Anthropic Implementation)
│   │   ├── [F069] ── google-ai-provider.ts      (Google AI Implementation)
│   │   ├── [F070] ── ai-factory.ts              (AI Provider Factory)
│   │   └── [F071] ── ai-orchestrator.ts         (Multi-AI Draft Orchestrator)
│   │
│   ├── [D026] ── parsers/
│   │   ├── [F072] ── docx-parser.ts             (Word File Parser)
│   │   ├── [F073] ── markdown-parser.ts         (Markdown Parser)
│   │   └── [F074] ── cv-field-extractor.ts      (CV Field Extraction Logic)
│   │
│   ├── [D027] ── generators/
│   │   ├── [F075] ── docx-generator.ts          (Word File Generator)
│   │   └── [F076] ── markdown-generator.ts      (Markdown File Generator)
│   │
│   ├── [F077] ── encryption.ts                  (API Key Encryption)
│   ├── [F078] ── constants.ts                   (App Constants)
│   ├── [F079] ── types.ts                       (TypeScript Types)
│   └── [F080] ── utils.ts                       (Utility Functions)
│
├── [D028] ── hooks/
│   ├── [F081] ── useAI.ts
│   ├── [F082] ── useCV.ts
│   ├── [F083] ── usePrompts.ts
│   ├── [F084] ── useApplication.ts
│   └── [F085] ── useLocale.ts
│
├── [D029] ── i18n/
│   ├── [F086] ── config.ts                      (i18n Configuration)
│   ├── [F087] ── en.json                        (English Translations)
│   └── [F088] ── fa.json                        (Farsi Translations)
│
└── [D030] ── middleware.ts                      (Next.js Middleware)
۱.۲ جدول ردیابی وضعیت (Status Tracker)
هر بلوک پس از اتمام، وضعیتش اینجا ثبت می‌شود

text

| بلوک  | وضعیت       | فایل‌های تغییریافته | خروجی قابل تأیید         |
|-------|-------------|---------------------|--------------------------|
| B01   | ⬜ منتظر     |                     |                          |
| B02   | ⬜ منتظر     |                     |                          |
| ...   |             |                     |                          |
وضعیت‌ها:

⬜ منتظر (Pending)
🔨 در حال ساخت (Building)
✅ ساخته و تست‌شده (Built & Tested)
❌ نیاز به اصلاح (Needs Fix)
سند شماره ۲: بلوک‌های اجرایی اتمیک (Execution Blocks)
🔵 فاز ۰: راه‌اندازی اولیه (Foundation)
بلوک B01: ایجاد پروژه Next.js خالی
هدف: یک پروژه Next.js خالی و قابل اجرا روی localhost

پیش‌نیاز: هیچ

فایل‌های ایجادی:

text

[F001] package.json
[F002] tsconfig.json
[F003] next.config.js
[F004] tailwind.config.ts
[F005] .env.local
[F006] .env.example
[F009] src/app/globals.css
دستور دقیق:

text

npx create-next-app@latest cv-tailor-app --typescript --tailwind --eslint --app --src-dir --import-alias "@/*"
وابستگی‌های اضافی برای نصب:

text

(هیچ — فقط پروژه خالی)
تست تأیید (Checkpoint):

text

□ دستور npm run dev بدون خطا اجرا می‌شود
□ صفحه localhost:3000 نمایش داده می‌شود
□ فایل‌های [F001] تا [F006] و [F009] وجود دارند
□ TypeScript بدون خطا کامپایل می‌شود
بلوک B02: نصب وابستگی‌های اصلی
هدف: نصب تمام کتابخانه‌های مورد نیاز پروژه

پیش‌نیاز: B01 ✅

فایل‌های تغییری:

text

[F001] package.json (به‌روزرسانی)
دستورات دقیق:

Bash

# UI Components
npx shadcn-ui@latest init
npx shadcn-ui@latest add button input card dialog select textarea tabs badge toast dropdown-menu

# Supabase
npm install @supabase/supabase-js @supabase/ssr

# AI SDKs
npm install openai @anthropic-ai/sdk @google/generative-ai

# File Parsing & Generation
npm install mammoth docx file-saver
npm install @types/file-saver --save-dev

# Markdown
npm install remark remark-html remark-parse unified

# Rich Text Editor
npm install @tiptap/react @tiptap/starter-kit @tiptap/extension-placeholder @tiptap/pm

# i18n
npm install next-intl

# Encryption
npm install crypto-js
npm install @types/crypto-js --save-dev

# Utilities
npm install clsx tailwind-merge lucide-react zod
تست تأیید:

text

□ npm run dev بدون خطا اجرا می‌شود
□ هیچ peer dependency conflict وجود ندارد
□ فایل‌های shadcn در src/components/ui/ ایجاد شده‌اند
  [F027] button.tsx
  [F028] input.tsx
  [F029] card.tsx
  [F030] dialog.tsx
  [F031] select.tsx
  [F032] textarea.tsx
  [F033] tabs.tsx
  [F034] badge.tsx
  [F035] toast.tsx
  [F036] dropdown-menu.tsx
بلوک B03: تعریف TypeScript Types مرکزی
هدف: تعریف تمام تایپ‌های TypeScript پروژه در یک فایل مرجع

پیش‌نیاز: B02 ✅

فایل‌های ایجادی:

text

[F079] src/lib/types.ts
محتوای دقیق فایل:

TypeScript

// ============================================
// [F079] src/lib/types.ts
// Central TypeScript Type Definitions
// ============================================

// ---- User Types ----
export interface User {
  id: string;
  google_id: string | null;
  email: string;
  name: string;
  avatar_url: string | null;
  preferred_language: 'en' | 'fa';
  created_at: string;
  updated_at: string;
}

// ---- Comprehensive CV Types ----
export interface PersonalInfo {
  full_name: string;
  email: string;
  phone: string;
  location: string;
  linkedin_url: string;
  website_url: string;
  summary: string;
}

export interface WorkExperience {
  id: string;
  job_title: string;
  company: string;
  location: string;
  start_date: string;
  end_date: string | null;
  is_current: boolean;
  description: string;
  achievements: string[];
}

export interface Education {
  id: string;
  degree: string;
  institution: string;
  location: string;
  start_date: string;
  end_date: string;
  gpa: string | null;
  description: string;
}

export interface Certification {
  id: string;
  name: string;
  issuer: string;
  date_obtained: string;
  expiry_date: string | null;
  credential_url: string | null;
}

export interface ComprehensiveCV {
  id: string;
  user_id: string;
  personal_info: PersonalInfo;
  work_experience: WorkExperience[];
  education: Education[];
  skills: string[];
  certifications: Certification[];
  languages: { language: string; proficiency: string }[];
  projects: { id: string; name: string; description: string; url: string | null }[];
  additional_sections: { title: string; content: string }[];
  raw_text: string;
  created_at: string;
  updated_at: string;
}

export interface CVFieldStatus {
  field_name: string;
  is_complete: boolean;
  current_value: any;
}

// ---- Prompt Types ----
export interface Prompt {
  id: string;
  title_en: string;
  title_fa: string;
  description_en: string;
  description_fa: string;
  prompt_text: string;
  category: string;
  is_active: boolean;
  sort_order: number;
  created_at: string;
  updated_at: string;
}

// ---- AI Types ----
export type AIProviderName = 'openai' | 'anthropic' | 'google';

export interface AIApiKey {
  id: string;
  user_id: string;
  provider_name: AIProviderName;
  api_key_encrypted: string;
  is_valid: boolean;
  available_models: AIModel[];
  token_balance: string | null;
  last_validated_at: string | null;
  created_at: string;
  updated_at: string;
}

export interface AIModel {
  model_id: string;
  model_name: string;
  provider: AIProviderName;
}

export interface AISelection {
  provider: AIProviderName;
  model_id: string;
  role: 'draft' | 'final';
}

export interface AIChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

// ---- Application Types ----
export type OutputLanguage = 'en' | 'fa' | 'fr' | 'de' | 'es' | 'ar' | 'zh' | 'tr';

export type ToneMode = 'preset' | 'custom';

export interface ToneSetting {
  mode: ToneMode;
  preset_value: string | null;   // e.g., 'formal', 'semi-formal', 'friendly', 'professional', 'creative'
  custom_text: string | null;
}

export interface JobApplication {
  id: string;
  user_id: string;
  job_description: string;
  selected_prompt_ids: string[];
  ai_selections: AISelection[];
  output_language: OutputLanguage;
  tone_setting: ToneSetting;
  selected_template_ids: {
    cv: string | null;
    cover_letter: string | null;
    email: string | null;
  };
  ai_questions: AIChatMessage[];
  draft_outputs: DraftOutput[];
  final_output: FinalOutput | null;
  edited_output: FinalOutput | null;
  status: 'input' | 'processing' | 'clarification' | 'draft_ready' | 'editing' | 'finalized';
  created_at: string;
  updated_at: string;
}

export interface DraftOutput {
  ai_provider: AIProviderName;
  ai_model: string;
  content: string;
  created_at: string;
}

export interface FinalOutput {
  tailored_cv: string;
  cover_letter: string;
  application_email: string;
}

// ---- Template Types ----
export type TemplateType = 'cv' | 'cover_letter' | 'email';
export type FileFormat = 'docx' | 'md';

export interface Template {
  id: string;
  user_id: string;
  template_name: string;
  template_type: TemplateType;
  file_format: FileFormat;
  file_content: string;
  created_at: string;
  updated_at: string;
}

// ---- UI Types ----
export type AppLocale = 'en' | 'fa';

export interface NavigationItem {
  label_key: string;
  href: string;
  icon: string;
}
تست تأیید:

text

□ فایل [F079] وجود دارد
□ npm run build بدون خطای TypeScript اجرا می‌شود
□ تمام interface‌ها و type‌ها export شده‌اند
بلوک B04: Constants و Utilities
هدف: ثابت‌ها و توابع کمکی مرکزی

پیش‌نیاز: B03 ✅

فایل‌های ایجادی:

text

[F078] src/lib/constants.ts
[F080] src/lib/utils.ts
محتوای [F078] constants.ts:

TypeScript

// ============================================
// [F078] src/lib/constants.ts
// ============================================

import { OutputLanguage, AIProviderName } from './types';

export const APP_NAME = 'CV Tailor';

export const SUPPORTED_OUTPUT_LANGUAGES: { code: OutputLanguage; label_en: string; label_fa: string }[] = [
  { code: 'en', label_en: 'English', label_fa: 'انگلیسی' },
  { code: 'fa', label_en: 'Persian (Farsi)', label_fa: 'فارسی' },
  { code: 'fr', label_en: 'French', label_fa: 'فرانسوی' },
  { code: 'de', label_en: 'German', label_fa: 'آلمانی' },
  { code: 'es', label_en: 'Spanish', label_fa: 'اسپانیایی' },
  { code: 'ar', label_en: 'Arabic', label_fa: 'عربی' },
  { code: 'zh', label_en: 'Chinese', label_fa: 'چینی' },
  { code: 'tr', label_en: 'Turkish', label_fa: 'ترکی' },
];

export const SUPPORTED_AI_PROVIDERS: { name: AIProviderName; label: string; website: string }[] = [
  { name: 'openai', label: 'OpenAI', website: 'https://platform.openai.com' },
  { name: 'anthropic', label: 'Anthropic', website: 'https://console.anthropic.com' },
  { name: 'google', label: 'Google AI', website: 'https://aistudio.google.com' },
];

export const TONE_PRESETS: { value: string; label_en: string; label_fa: string }[] = [
  { value: 'formal', label_en: 'Formal', label_fa: 'رسمی' },
  { value: 'semi-formal', label_en: 'Semi-Formal', label_fa: 'نیمه‌رسمی' },
  { value: 'professional', label_en: 'Professional', label_fa: 'حرفه‌ای' },
  { value: 'friendly', label_en: 'Friendly', label_fa: 'دوستانه' },
  { value: 'creative', label_en: 'Creative', label_fa: 'خلاقانه' },
  { value: 'confident', label_en: 'Confident', label_fa: 'مطمئن' },
];

export const CV_REQUIRED_FIELDS = [
  'personal_info.full_name',
  'personal_info.email',
  'personal_info.phone',
  'personal_info.summary',
  'work_experience',
  'education',
  'skills',
] as const;

export const MAX_FILE_SIZE_MB = 10;
export const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
محتوای [F080] utils.ts:

TypeScript

// ============================================
// [F080] src/lib/utils.ts
// ============================================

import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function generateId(): string {
  return crypto.randomUUID();
}

export function formatDate(dateString: string, locale: string = 'en'): string {
  return new Date(dateString).toLocaleDateString(locale === 'fa' ? 'fa-IR' : 'en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}

export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
}

export function isRTL(locale: string): boolean {
  return ['fa', 'ar'].includes(locale);
}
تست تأیید:

text

□ فایل‌های [F078] و [F080] وجود دارند
□ npm run build بدون خطا اجرا می‌شود
□ import از هر دو فایل در یک فایل تست ممکن است
بلوک B05: سیستم دوزبانه (i18n)
هدف: پیاده‌سازی سیستم دوزبانه فارسی/انگلیسی با next-intl

پیش‌نیاز: B04 ✅

فایل‌های ایجادی:

text

[F086] src/i18n/config.ts
[F087] src/i18n/en.json
[F088] src/i18n/fa.json
[F030] src/middleware.ts
[F003] next.config.js (به‌روزرسانی)
محتوای [F086] config.ts:

TypeScript

// ============================================
// [F086] src/i18n/config.ts
// ============================================

export const locales = ['en', 'fa'] as const;
export type Locale = (typeof locales)[number];
export const defaultLocale: Locale = 'en';
محتوای [F087] en.json (ساختار اولیه):

JSON

{
  "common": {
    "app_name": "CV Tailor",
    "loading": "Loading...",
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "add": "Add",
    "confirm": "Confirm",
    "download": "Download",
    "upload": "Upload",
    "back": "Back",
    "next": "Next",
    "submit": "Submit",
    "search": "Search",
    "filter": "Filter",
    "status": "Status",
    "actions": "Actions",
    "language": "Language",
    "settings": "Settings"
  },
  "nav": {
    "dashboard": "Dashboard",
    "cv_manager": "My CV",
    "new_application": "New Application",
    "applications": "My Applications",
    "prompts": "Prompt Management",
    "settings": "Settings",
    "logout": "Logout"
  },
  "auth": {
    "login": "Login",
    "login_with_google": "Login with Google",
    "logout": "Logout",
    "welcome": "Welcome"
  },
  "cv": {
    "title": "Comprehensive CV",
    "upload_cv": "Upload CV",
    "upload_description": "Upload your comprehensive CV in Word or Markdown format",
    "or_enter_manually": "Or enter manually",
    "personal_info": "Personal Information",
    "work_experience": "Work Experience",
    "education": "Education",
    "skills": "Skills",
    "certifications": "Certifications",
    "languages": "Languages",
    "projects": "Projects",
    "incomplete_fields": "Incomplete Fields",
    "please_complete": "Please complete the following fields",
    "field_complete": "Complete",
    "field_incomplete": "Incomplete"
  },
  "prompts": {
    "title": "Prompt Management",
    "add_new": "Add New Prompt",
    "edit_prompt": "Edit Prompt",
    "prompt_title": "Title",
    "prompt_description": "Description",
    "prompt_text": "Prompt Text",
    "category": "Category",
    "active": "Active",
    "inactive": "Inactive"
  },
  "ai": {
    "api_keys": "AI API Keys",
    "add_key": "Add API Key",
    "provider": "AI Provider",
    "model": "Model",
    "status_connected": "Connected",
    "status_disconnected": "Disconnected",
    "status_invalid": "Invalid Key",
    "available_models": "Available Models",
    "token_balance": "Token Balance",
    "test_connection": "Test Connection",
    "select_for_draft": "Use for Draft",
    "select_for_final": "Use for Final",
    "draft_mode": "Draft Mode",
    "final_mode": "Final Mode"
  },
  "application": {
    "new_title": "New Job Application",
    "job_description": "Job Description",
    "enter_job_description": "Paste the job description here",
    "select_prompts": "Select Prompts",
    "select_ai": "Select AI Model",
    "select_language": "Output Language",
    "select_tone": "Response Tone",
    "tone_preset": "Choose Preset",
    "tone_custom": "Describe Custom Tone",
    "start_processing": "Start Processing",
    "ai_asking": "AI is asking a question",
    "your_answer": "Your Answer",
    "send_answer": "Send Answer",
    "draft_ready": "Draft Ready",
    "edit_output": "Edit Output",
    "approve_output": "Approve & Generate Documents",
    "generating_documents": "Generating Documents...",
    "documents_ready": "Documents Ready",
    "tailored_cv": "Tailored CV",
    "cover_letter": "Cover Letter",
    "application_email": "Application Email",
    "download_word": "Download Word",
    "download_markdown": "Download Markdown"
  },
  "templates": {
    "title": "Template Management",
    "upload_template": "Upload Template",
    "template_type": "Template Type",
    "select_template": "Select Template"
  },
  "settings": {
    "title": "Settings",
    "ui_language": "Interface Language",
    "profile": "Profile"
  }
}
محتوای [F088] fa.json (ساختار اولیه):

JSON

{
  "common": {
    "app_name": "سی‌وی تیلور",
    "loading": "در حال بارگذاری...",
    "save": "ذخیره",
    "cancel": "انصراف",
    "delete": "حذف",
    "edit": "ویرایش",
    "add": "افزودن",
    "confirm": "تأیید",
    "download": "دانلود",
    "upload": "آپلود",
    "back": "بازگشت",
    "next": "بعدی",
    "submit": "ارسال",
    "search": "جستجو",
    "filter": "فیلتر",
    "status": "وضعیت",
    "actions": "عملیات",
    "language": "زبان",
    "settings": "تنظیمات"
  },
  "nav": {
    "dashboard": "داشبورد",
    "cv_manager": "سی‌وی من",
    "new_application": "درخواست جدید",
    "applications": "درخواست‌های من",
    "prompts": "مدیریت پرامپت‌ها",
    "settings": "تنظیمات",
    "logout": "خروج"
  },
  "auth": {
    "login": "ورود",
    "login_with_google": "ورود با گوگل",
    "logout": "خروج",
    "welcome": "خوش آمدید"
  },
  "cv": {
    "title": "سی‌وی جامع",
    "upload_cv": "آپلود سی‌وی",
    "upload_description": "سی‌وی جامع خود را به فرمت Word یا Markdown آپلود کنید",
    "or_enter_manually": "یا به صورت دستی وارد کنید",
    "personal_info": "اطلاعات شخصی",
    "work_experience": "سوابق کاری",
    "education": "تحصیلات",
    "skills": "مهارت‌ها",
    "certifications": "گواهینامه‌ها",
    "languages": "زبان‌ها",
    "projects": "پروژه‌ها",
    "incomplete_fields": "فیلدهای ناقص",
    "please_complete": "لطفاً فیلدهای زیر را تکمیل کنید",
    "field_complete": "کامل",
    "field_incomplete": "ناقص"
  },
  "prompts": {
    "title": "مدیریت پرامپت‌ها",
    "add_new": "افزودن پرامپت جدید",
    "edit_prompt": "ویرایش پرامپت",
    "prompt_title": "عنوان",
    "prompt_description": "توضیحات",
    "prompt_text": "متن پرامپت",
    "category": "دسته‌بندی",
    "active": "فعال",
    "inactive": "غیرفعال"
  },
  "ai": {
    "api_keys": "کلیدهای API هوش مصنوعی",
    "add_key": "افزودن کلید API",
    "provider": "سرویس هوش مصنوعی",
    "model": "مدل",
    "status_connected": "متصل",
    "status_disconnected": "قطع",
    "status_invalid": "کلید نامعتبر",
    "available_models": "مدل‌های در دسترس",
    "token_balance": "موجودی توکن",
    "test_connection": "تست اتصال",
    "select_for_draft": "استفاده برای پیش‌نویس",
    "select_for_final": "استفاده برای نسخه نهایی",
    "draft_mode": "حالت پیش‌نویس",
    "final_mode": "حالت نهایی"
  },
  "application": {
    "new_title": "درخواست شغلی جدید",
    "job_description": "شرح شغل",
    "enter_job_description": "شرح شغل را اینجا وارد کنید",
    "select_prompts": "انتخاب پرامپت‌ها",
    "select_ai": "انتخاب مدل هوش مصنوعی",
    "select_language": "زبان خروجی",
    "select_tone": "لحن پاسخ",
    "tone_preset": "انتخاب از پیش‌فرض",
    "tone_custom": "توصیف لحن دلخواه",
    "start_processing": "شروع پردازش",
    "ai_asking": "هوش مصنوعی سوالی دارد",
    "your_answer": "پاسخ شما",
    "send_answer": "ارسال پاسخ",
    "draft_ready": "پیش‌نویس آماده است",
    "edit_output": "ویرایش خروجی",
    "approve_output": "تأیید و تولید مستندات",
    "generating_documents": "در حال تولید مستندات...",
    "documents_ready": "مستندات آماده است",
    "tailored_cv": "سی‌وی اختصاصی",
    "cover_letter": "کاورلتر",
    "application_email": "ایمیل درخواست",
    "download_word": "دانلود Word",
    "download_markdown": "دانلود Markdown"
  },
  "templates": {
    "title": "مدیریت قالب‌ها",
    "upload_template": "آپلود قالب",
    "template_type": "نوع قالب",
    "select_template": "انتخاب قالب"
  },
  "settings": {
    "title": "تنظیمات",
    "ui_language": "زبان رابط کاربری",
    "profile": "پروفایل"
  }
}
به‌روزرسانی [F003] next.config.js:

JavaScript

// ============================================
// [F003] next.config.js (Updated for i18n)
// ============================================

const createNextIntlPlugin = require('next-intl/plugin');
const withNextIntl = createNextIntlPlugin();

/** @type {import('next').NextConfig} */
const nextConfig = {};

module.exports = withNextIntl(nextConfig);
ایجاد [F030] src/middleware.ts:

TypeScript

// ============================================
// [F030] src/middleware.ts
// ============================================

import createMiddleware from 'next-intl/middleware';
import { locales, defaultLocale } from './i18n/config';

export default createMiddleware({
  locales,
  defaultLocale,
});

export const config = {
  matcher: ['/', '/(en|fa)/:path*'],
};
تست تأیید:

text

□ مسیر localhost:3000/en صفحه انگلیسی نشان می‌دهد
□ مسیر localhost:3000/fa صفحه فارسی نشان می‌دهد
□ تغییر زبان URL را تغییر می‌دهد
□ npm run build بدون خطا
بلوک B06: اتصال Supabase و ایجاد جداول
هدف: اتصال به Supabase و ایجاد تمام جداول دیتابیس

پیش‌نیاز: B05 ✅

فایل‌های ایجادی:

text

[F063] src/lib/supabase/client.ts
[F064] src/lib/supabase/server.ts
[F005] .env.local (به‌روزرسانی)
اسکریپت SQL برای اجرا در Supabase Dashboard:

SQL

-- ============================================
-- SUPABASE DATABASE SCHEMA
-- Run this in Supabase SQL Editor
-- ============================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Users Table
CREATE TABLE public.users (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  google_id TEXT UNIQUE,
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  avatar_url TEXT,
  preferred_language TEXT DEFAULT 'en' CHECK (preferred_language IN ('en', 'fa')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Comprehensive CVs Table
CREATE TABLE public.comprehensive_cvs (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  personal_info JSONB DEFAULT '{}',
  work_experience JSONB DEFAULT '[]',
  education JSONB DEFAULT '[]',
  skills JSONB DEFAULT '[]',
  certifications JSONB DEFAULT '[]',
  languages JSONB DEFAULT '[]',
  projects JSONB DEFAULT '[]',
  additional_sections JSONB DEFAULT '[]',
  raw_text TEXT DEFAULT '',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id)
);

-- 3. Prompts Table
CREATE TABLE public.prompts (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  title_en TEXT NOT NULL,
  title_fa TEXT NOT NULL,
  description_en TEXT DEFAULT '',
  description_fa TEXT DEFAULT '',
  prompt_text TEXT NOT NULL,
  category TEXT DEFAULT 'general',
  is_active BOOLEAN DEFAULT true,
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. AI API Keys Table
CREATE TABLE public.ai_api_keys (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  provider_name TEXT NOT NULL CHECK (provider_name IN ('openai', 'anthropic', 'google')),
  api_key_encrypted TEXT NOT NULL,
  is_valid BOOLEAN DEFAULT false,
  available_models JSONB DEFAULT '[]',
  token_balance TEXT,
  last_validated_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, provider_name)
);

-- 5. Templates Table
CREATE TABLE public.templates (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  template_name TEXT NOT NULL,
  template_type TEXT NOT NULL CHECK (template_type IN ('cv', 'cover_letter', 'email')),
  file_format TEXT NOT NULL CHECK (file_format IN ('docx', 'md')),
  file_content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 6. Job Applications Table
CREATE TABLE public.job_applications (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  job_description TEXT NOT NULL,
  selected_prompt_ids JSONB DEFAULT '[]',
  ai_selections JSONB DEFAULT '[]',
  output_language TEXT DEFAULT 'en',
  tone_setting JSONB DEFAULT '{"mode": "preset", "preset_value": "professional", "custom_text": null}',
  selected_template_ids JSONB DEFAULT '{"cv": null, "cover_letter": null, "email": null}',
  ai_questions JSONB DEFAULT '[]',
  draft_outputs JSONB DEFAULT '[]',
  final_output JSONB,
  edited_output JSONB,
  status TEXT DEFAULT 'input' CHECK (status IN ('input', 'processing', 'clarification', 'draft_ready', 'editing', 'finalized')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable Row Level Security
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comprehensive_cvs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.prompts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_api_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.job_applications ENABLE ROW LEVEL SECURITY;

-- RLS Policies (simplified for development - will be tightened later)
-- Users can read/write their own data
CREATE POLICY "Users can view own data" ON public.users FOR SELECT USING (true);
CREATE POLICY "Users can update own data" ON public.users FOR UPDATE USING (true);
CREATE POLICY "Users can insert" ON public.users FOR INSERT WITH CHECK (true);

CREATE POLICY "CV owner access" ON public.comprehensive_cvs FOR ALL USING (true);
CREATE POLICY "Prompts read all" ON public.prompts FOR SELECT USING (true);
CREATE POLICY "Prompts manage" ON public.prompts FOR ALL USING (true);
CREATE POLICY "API keys owner" ON public.ai_api_keys FOR ALL USING (true);
CREATE POLICY "Templates owner" ON public.templates FOR ALL USING (true);
CREATE POLICY "Applications owner" ON public.job_applications FOR ALL USING (true);

-- Updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to all tables
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON public.users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_cvs_updated_at BEFORE UPDATE ON public.comprehensive_cvs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_prompts_updated_at BEFORE UPDATE ON public.prompts
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_api_keys_updated_at BEFORE UPDATE ON public.ai_api_keys
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_templates_updated_at BEFORE UPDATE ON public.templates
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_applications_updated_at BEFORE UPDATE ON public.job_applications
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
محتوای [F063] supabase/client.ts:

TypeScript

// ============================================
// [F063] src/lib/supabase/client.ts
// ============================================

import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
محتوای [F064] supabase/server.ts:

TypeScript

// ============================================
// [F064] src/lib/supabase/server.ts
// ============================================

import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';

export function createServerSupabaseClient() {
  const cookieStore = cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}
به‌روزرسانی [F005] .env.local:

text

NEXT_PUBLIC_SUPABASE_URL=your_supabase_url_here
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here
ENCRYPTION_SECRET_KEY=your_32_char_secret_key_here
تست تأیید:

text

□ جداول در Supabase Dashboard قابل مشاهده هستند
□ فایل‌های [F063] و [F064] وجود دارند
□ اتصال به Supabase از سرور و کلاینت تست شده
□ npm run build بدون خطا
بلوک B07: لاگین موقت (Development Auth)
هدف: سیستم لاگین ساده برای مرحله توسعه (بدون Google OAuth)

پیش‌نیاز: B06 ✅

فایل‌های ایجادی/تغییری:

text

[F008] src/app/page.tsx (ریدایرکت به locale)
[F010] src/app/[locale]/layout.tsx
[F011] src/app/[locale]/page.tsx (صفحه لاگین موقت)
توضیح:

یک فرم ساده با فیلد ایمیل و نام
بدون پسورد واقعی، فقط ایجاد/بازیابی کاربر در جدول users
هدف: بتوان بدون Google OAuth توسعه داد
در فاز نهایی با Google Auth جایگزین خواهد شد
تست تأیید:

text

□ صفحه لاگین نمایش داده می‌شود
□ با وارد کردن ایمیل و نام، کاربر در Supabase ایجاد می‌شود
□ پس از لاگین، به داشبورد ریدایرکت می‌شود
□ اطلاعات کاربر در session قابل دسترسی است
□ صفحه به هر دو زبان نمایش داده می‌شود
بلوک B08: Layout اصلی (Header + Sidebar + Footer)
هدف: ساختار ظاهری اصلی اپلیکیشن

پیش‌نیاز: B07 ✅

فایل‌های ایجادی:

text

[F037] src/components/layout/Header.tsx
[F038] src/components/layout/Sidebar.tsx
[F039] src/components/layout/Footer.tsx
[F040] src/components/layout/LanguageSwitcher.tsx
[F010] src/app/[locale]/layout.tsx (به‌روزرسانی)
الزامات:

Header: لوگو + نام اپلیکیشن + LanguageSwitcher + نام کاربر
Sidebar: منوی ناوبری با لینک به تمام صفحات اصلی
Footer: ساده با کپی‌رایت
LanguageSwitcher: دکمه تغییر زبان EN/FA
RTL/LTR اتوماتیک بر اساس زبان
ریسپانسیو
تست تأیید:

text

□ Header با لوگو و LanguageSwitcher نمایش داده می‌شود
□ Sidebar با تمام آیتم‌های منو نمایش داده می‌شود
□ تغییر زبان از EN به FA کار می‌کند
□ در FA، صفحه RTL می‌شود
□ در موبایل، Sidebar به‌صورت همبرگر منو نمایش داده می‌شود
□ لینک‌های ناوبری کار می‌کنند (حتی اگر صفحات هنوز خالی باشند)
🔵 فاز ۱: مدیریت سی‌وی جامع (CV Management)
بلوک B09: پارسرهای فایل (Word + Markdown)
هدف: توابعی که فایل Word و Markdown را پارس و محتوا استخراج کنند

پیش‌نیاز: B04 ✅

فایل‌های ایجادی:

text

[F072] src/lib/parsers/docx-parser.ts
[F073] src/lib/parsers/markdown-parser.ts
تست تأیید:

text

□ یک فایل .docx نمونه وقتی به تابع داده می‌شود، متن آن استخراج می‌شود
□ یک فایل .md نمونه وقتی به تابع داده می‌شود، محتوا پارس می‌شود
□ خروجی هر دو به فرمت string متنی ساده برمی‌گردد
□ خطاهای فایل ناقص به‌درستی هندل می‌شوند
بلوک B10: استخراج‌گر فیلدهای سی‌وی
هدف: لاجیکی که از متن خام سی‌وی، فیلدهای ساختاریافته استخراج کند

پیش‌نیاز: B09 ✅

فایل‌های ایجادی:

text

[F074] src/lib/parsers/cv-field-extractor.ts
توضیح:

دریافت متن خام سی‌وی
تلاش برای شناسایی بخش‌ها (نام، ایمیل، تلفن، سوابق کاری، تحصیلات، مهارت‌ها و...)
خروجی: آبجکت ComprehensiveCV با فیلدهای پر و خالی
خروجی دوم: لیست CVFieldStatus که نشان می‌دهد کدام فیلدها کامل و کدام ناقص هستند
تست تأیید:

text

□ یک متن سی‌وی نمونه وقتی داده می‌شود، حداقل نام و ایمیل استخراج می‌شود
□ فیلدهای ناقص شناسایی و لیست می‌شوند
□ خروجی با تایپ ComprehensiveCV سازگار است
بلوک B11: کامپوننت آپلود سی‌وی
هدف: کامپوننتی که کاربر بتواند فایل سی‌وی آپلود کند یا متن را مستقیم وارد کند

پیش‌نیاز: B10 ✅

فایل‌های ایجادی:

text

[F041] src/components/cv/CVUploader.tsx
الزامات:

Drag & Drop zone برای فایل
پشتیبانی از .docx و .md
محدودیت حجم (MAX_FILE_SIZE_MB)
Textarea برای ورود مستقیم متنی
پیام خطا در صورت فرمت نامعتبر
دوزبانه
تست تأیید:

text

□ فایل .docx قابل آپلود است
□ فایل .md قابل آپلود است
□ فایل با فرمت نامعتبر خطا نمایش می‌دهد
□ فایل بزرگ‌تر از حد مجاز خطا نمایش می‌دهد
□ متن مستقیم قابل ورود است
□ به هر دو زبان کار می‌کند
بلوک B12: نمایش و تکمیل فیلدهای سی‌وی
هدف: نمایش فیلدهای استخراج‌شده، هایلایت بخش‌های ناقص، و فرم تکمیل

پیش‌نیاز: B11 ✅

فایل‌های ایجادی:

text

[F042] src/components/cv/CVFieldExtractor.tsx
[F043] src/components/cv/CVCompletionForm.tsx
[F044] src/components/cv/CVPreview.tsx
تست تأیید:

text

□ فیلدهای کامل با علامت ✅ نشان داده می‌شوند
□ فیلدهای ناقص با علامت ⚠️ هایلایت می‌شوند
□ کلیک روی فیلد ناقص → فرم تکمیل باز می‌شود
□ پس از تکمیل، فیلد به‌عنوان کامل علامت‌گذاری می‌شود
□ پیش‌نمایش سی‌وی کامل قابل مشاهده است
بلوک B13: API Route سی‌وی + ذخیره در Supabase
هدف: API endpoint برای ذخیره و بازیابی سی‌وی + Hook

پیش‌نیاز: B12 ✅

فایل‌های ایجادی:

text

[F022] src/app/api/cv/parse/route.ts
[F082] src/hooks/useCV.ts
تست تأیید:

text

□ سی‌وی جامع در Supabase ذخیره می‌شود
□ سی‌وی ذخیره‌شده قابل بازیابی است
□ به‌روزرسانی بخش‌های تکمیل‌شده در دیتابیس اعمال می‌شود
□ هر کاربر فقط یک سی‌وی جامع دارد (UNIQUE constraint)
بلوک B14: صفحه مدیریت سی‌وی (یکپارچه‌سازی)
هدف: صفحه کامل مدیریت سی‌وی که تمام کامپوننت‌ها را ترکیب می‌کند

پیش‌نیاز: B13 ✅

فایل‌های تغییری:

text

[F013] src/app/[locale]/cv-manager/page.tsx
تست تأیید:

text

□ صفحه CV Manager از منوی Sidebar قابل دسترسی است
□ آپلود سی‌وی → استخراج فیلدها → نمایش ناقص‌ها → تکمیل → ذخیره: کل فرایند کار می‌کند
□ بازگشت به صفحه → سی‌وی ذخیره‌شده نمایش داده می‌شود
□ دوزبانه کار می‌کند
🔵 فاز ۲: مدیریت پرامپت‌ها (Prompt Management)
بلوک B15: CRUD پرامپت‌ها (Backend)
پیش‌نیاز: B06 ✅

فایل‌های ایجادی:

text

[F024] src/app/api/prompts/route.ts
[F083] src/hooks/usePrompts.ts
تست تأیید:

text

□ API: ایجاد پرامپت جدید
□ API: خواندن لیست پرامپت‌ها
□ API: ویرایش پرامپت
□ API: حذف پرامپت
□ API: تغییر وضعیت فعال/غیرفعال
□ Hook: تمام عملیات از طریق Hook قابل استفاده
بلوک B16: کامپوننت‌های پرامپت (Frontend)
پیش‌نیاز: B15 ✅

فایل‌های ایجادی:

text

[F045] src/components/prompts/PromptList.tsx
[F046] src/components/prompts/PromptEditor.tsx
[F047] src/components/prompts/PromptSelector.tsx
[F048] src/components/prompts/PromptCategoryFilter.tsx
تست تأیید:

text

□ لیست پرامپت‌ها نمایش داده می‌شود
□ افزودن پرامپت جدید از طریق UI کار می‌کند
□ ویرایش پرامپت با ویرایشگر متنی مناسب کار می‌کند
□ فیلتر بر اساس دسته‌بندی کار می‌کند
□ فعال/غیرفعال‌سازی با یک کلیک
□ دوزبانه (عنوان فارسی و انگلیسی)
بلوک B17: صفحه مدیریت پرامپت‌ها
پیش‌نیاز: B16 ✅

فایل‌های تغییری:

text

[F015] src/app/[locale]/prompts/page.tsx
تست تأیید:

text

□ صفحه از Sidebar قابل دسترسی
□ CRUD کامل بدون نیاز به کدنویسی
□ دوزبانه
🔵 فاز ۳: مدیریت API Key و اتصال به AI‌ها
بلوک B18: رمزنگاری API Key
پیش‌نیاز: B04 ✅

فایل‌های ایجادی:

text

[F077] src/lib/encryption.ts
تست تأیید:

text

□ رمزنگاری یک رشته و بازگردانی آن به حالت اولیه
□ کلید متفاوت → خروجی متفاوت
□ تابع encrypt و decrypt صحیح کار می‌کنند
بلوک B19: AI Provider Interface (Abstract Layer)
هدف: لایه انتزاعی برای ارتباط با AI‌های مختلف

پیش‌نیاز: B18 ✅

فایل‌های ایجادی:

text

[F066] src/lib/ai/ai-provider.ts
[F067] src/lib/ai/openai-provider.ts
[F068] src/lib/ai/anthropic-provider.ts
[F069] src/lib/ai/google-ai-provider.ts
[F070] src/lib/ai/ai-factory.ts
الزامات فایل [F066] ai-provider.ts:

TypeScript

// Abstract interface that all AI providers must implement
export interface AIProvider {
  readonly providerName: AIProviderName;

  // Validate API key and return connection status
  validateKey(apiKey: string): Promise<{ valid: boolean; error?: string }>;

  // Get available models for this provider
  getAvailableModels(apiKey: string): Promise<AIModel[]>;

  // Get token balance (if supported)
  getTokenBalance(apiKey: string): Promise<string | null>;

  // Send chat message and get response (streaming)
  chat(
    apiKey: string,
    model: string,
    messages: AIChatMessage[],
    onStream?: (chunk: string) => void
  ): Promise<string>;
}
تست تأیید:

text

□ Interface AIProvider تعریف شده
□ OpenAI Provider: validateKey با یک کلید تستی کار می‌کند
□ Anthropic Provider: validateKey با یک کلید تستی کار می‌کند
□ Google Provider: validateKey با یک کلید تستی کار می‌کند
□ Factory: بر اساس نام provider، instance صحیح برمی‌گرداند
□ هر provider متد getAvailableModels را دارد
□ هر provider متد chat را دارد
□ افزودن provider جدید بدون تغییر interface ممکن است
بلوک B20: AI Orchestrator (Multi-AI Draft)
پیش‌نیاز: B19 ✅

فایل‌های ایجادی:

text

[F071] src/lib/ai/ai-orchestrator.ts
الزامات:

دریافت لیست AI Selection‌ها (Draft و Final)
اجرای موازی Draft‌ها
جمع‌آوری خروجی‌های Draft
ارسال به AI نهایی
تست تأیید:

text

□ با یک AI برای Draft: خروجی صحیح
□ با چند AI برای Draft: تمام خروجی‌ها جمع‌آوری می‌شوند
□ خروجی Draft‌ها به AI Final ارسال می‌شود
□ خطای یک Draft، کل فرایند را متوقف نمی‌کند
بلوک B21: API Routes هوش مصنوعی
پیش‌نیاز: B20 ✅

فایل‌های ایجادی:

text

[F019] src/app/api/ai/chat/route.ts
[F020] src/app/api/ai/validate-key/route.ts
[F021] src/app/api/ai/models/route.ts
تست تأیید:

text

□ POST /api/ai/validate-key → وضعیت اتصال
□ GET /api/ai/models?provider=openai → لیست مدل‌ها
□ POST /api/ai/chat → پاسخ streaming
□ API Key هرگز به سمت کلاینت ارسال نمی‌شود
بلوک B22: کامپوننت‌های مدیریت AI Key
پیش‌نیاز: B21 ✅

فایل‌های ایجادی:

text

[F049] src/components/ai/AIKeyManager.tsx
[F050] src/components/ai/AIModelSelector.tsx
[F051] src/components/ai/AIConnectionStatus.tsx
[F081] src/hooks/useAI.ts
تست تأیید:

text

□ فرم ورود API Key نمایش داده می‌شود
□ دکمه Test Connection وضعیت اتصال نشان می‌دهد
□ پس از اتصال موفق، مدل‌های در دسترس لیست می‌شوند
□ انتخاب مدل برای Draft/Final کار می‌کند
□ نشانگر وضعیت (سبز/قرمز) صحیح است
بلوک B23: صفحه تنظیمات (Settings)
پیش‌نیاز: B22 ✅

فایل‌های تغییری:

text

[F016] src/app/[locale]/settings/page.tsx
تست تأیید:

text

□ بخش مدیریت API Key‌ها کار می‌کند
□ بخش تنظیمات زبان کار می‌کند
□ ذخیره تنظیمات در Supabase
□ دوزبانه
🔵 فاز ۴: فرایند اصلی (Core Workflow)
بلوک B24: کامپوننت ورود شرح شغل
پیش‌نیاز: B08 ✅

فایل‌های ایجادی:

text

[F054] src/components/application/JobDescriptionInput.tsx
تست تأیید:

text

□ Textarea بزرگ برای paste کردن شرح شغل
□ شمارنده کاراکتر
□ دوزبانه
بلوک B25: کامپوننت‌های تنظیمات خروجی
پیش‌نیاز: B24 ✅

فایل‌های ایجادی:

text

[F055] src/components/application/ToneSelector.tsx
[F056] src/components/application/LanguageSelector.tsx
الزامات ToneSelector:

حالت ۱: انتخاب از لیست preset (رسمی، حرفه‌ای، دوستانه و...)
حالت ۲: ورود متنی آزاد برای توصیف لحن دلخواه
کاربر یکی از دو حالت را انتخاب می‌کند
الزامات LanguageSelector:

نمایش ۸ زبان پشتیبانی‌شده
انتخاب زبان خروجی (مستقل از زبان UI)
تست تأیید:

text

□ ToneSelector: حالت preset نمایش داده می‌شود
□ ToneSelector: حالت custom نمایش داده می‌شود
□ ToneSelector: سوییچ بین دو حالت
□ LanguageSelector: ۸ زبان نمایش داده می‌شوند
□ دوزبانه
بلوک B26: رابط چت با AI (Clarification Loop)
پیش‌نیاز: B21 ✅

فایل‌های ایجادی:

text

[F052] src/components/ai/AIChatInterface.tsx
الزامات:

نمایش سوال AI در قالب چت
فیلد پاسخ کاربر
ارسال پاسخ → AI مجدد بررسی → سوال بعدی یا تولید خروجی
نمایش Streaming پاسخ AI
تاریخچه مکالمه قابل مشاهده
تست تأیید:

text

□ سوال AI نمایش داده می‌شود
□ کاربر پاسخ می‌دهد
□ پاسخ + داده‌های قبلی به AI ارسال می‌شود
□ حلقه تا رفع ابهام ادامه می‌یابد
□ Streaming کار می‌کند
بلوک B27: پنل Multi-AI Draft
پیش‌نیاز: B26 ✅

فایل‌های ایجادی:

text

[F053] src/components/ai/AIMultiDraftPanel.tsx
تست تأیید:

text

□ انتخاب چند AI برای Draft
□ هر Draft جداگانه نمایش داده می‌شود
□ انتخاب AI Final
□ ترکیب Draft‌ها و ارسال به Final
بلوک B28: ویرایشگر خروجی (Rich Text Editor)
پیش‌نیاز: B02 ✅ (TipTap installed)

فایل‌های ایجادی:

text

[F057] src/components/application/OutputEditor.tsx
الزامات:

TipTap editor با ابزارهای Bold, Italic, Heading, List, Link
محتوای اولیه از خروجی AI لود می‌شود
کاربر می‌تواند ویرایش کند
دکمه تأیید برای نهایی‌سازی
پشتیبانی از RTL
تست تأیید:

text

□ ادیتور با محتوای نمونه لود می‌شود
□ ویرایش متن ممکن است
□ Bold, Italic, Heading کار می‌کنند
□ RTL در فارسی صحیح است
□ خروجی ویرایش‌شده قابل دریافت است
بلوک B29: تولیدکننده فایل‌های خروجی
پیش‌نیاز: B04 ✅

فایل‌های ایجادی:

text

[F075] src/lib/generators/docx-generator.ts
[F076] src/lib/generators/markdown-generator.ts
[F025] src/app/api/export/docx/route.ts
[F026] src/app/api/export/markdown/route.ts
تست تأیید:

text

□ تولید فایل .docx فرمت‌شده از متن ساده
□ تولید فایل .md از متن ساده
□ فایل Word قابل باز کردن در Microsoft Word
□ فایل Markdown قابل رندر
□ فرمت‌بندی (عنوان، پاراگراف، لیست) حفظ می‌شود
بلوک B30: پنل دانلود و پیش‌نمایش
پیش‌نیاز: B29 ✅

فایل‌های ایجادی:

text

[F058] src/components/application/DocumentPreview.tsx
[F059] src/components/application/DownloadPanel.tsx
تست تأیید:

text

□ پیش‌نمایش هر ۳ سند (CV, Cover Letter, Email) در تب‌های جداگانه
□ دکمه دانلود Word و Markdown برای هر سند
□ فایل‌ها صحیح دانلود می‌شوند
بلوک B31: Hook و State Management فرایند اصلی
پیش‌نیاز: B30 ✅

فایل‌های ایجادی:

text

[F084] src/hooks/useApplication.ts
الزامات:

مدیریت state کل فرایند (ورودی → پردازش → سوال → Draft → ویرایش → نهایی)
ذخیره و بازیابی از Supabase
تغییر وضعیت (status)
تست تأیید:

text

□ ایجاد application جدید
□ به‌روزرسانی وضعیت
□ ذخیره Draft output
□ ذخیره Final output
□ ذخیره Edited output
□ بازیابی application از دیتابیس
بلوک B32: صفحه New Application (یکپارچه‌سازی کامل)
پیش‌نیاز: B31 + B17 + B14 + B23 همگی ✅

فایل‌های تغییری:

text

[F014] src/app/[locale]/new-application/page.tsx
الزامات:

Wizard چند مرحله‌ای:
مرحله ۱: ورود شرح شغل
مرحله ۲: انتخاب پرامپت
مرحله ۳: انتخاب AI و مدل (Draft/Final)
مرحله ۴: انتخاب زبان خروجی
مرحله ۵: تنظیم لحن
مرحله ۶: انتخاب تمپلیت (اختیاری)
مرحله ۷: شروع پردازش
مرحله ۸: حلقه پرسش و پاسخ (در صورت نیاز)
مرحله ۹: نمایش Draft + ویرایش
مرحله ۱۰: تأیید → تولید ۳ سند
مرحله ۱۱: دانلود
تست تأیید (تست سرتاسری):

text

□ کل فرایند از ابتدا تا دانلود فایل‌ها بدون خطا اجرا می‌شود
□ با یک AI تکی (Draft+Final یکی)
□ با چند AI (Draft‌های مختلف + Final جدا)
□ با پرسش و پاسخ AI
□ بدون پرسش AI (مستقیم به Draft)
□ ویرایش خروجی و دانلود نسخه ویرایش‌شده
□ در هر دو زبان UI
□ با هر زبان خروجی
□ با لحن preset و custom
🔵 فاز ۵: مدیریت تمپلیت‌ها
بلوک B33: کامپوننت‌های تمپلیت
پیش‌نیاز: B29 ✅

فایل‌های ایجادی:

text

[F060] src/components/templates/TemplateUploader.tsx
[F061] src/components/templates/TemplateSelector.tsx
[F062] src/components/templates/TemplatePreview.tsx
تست تأیید:

text

□ آپلود تمپلیت Word
□ آپلود تمپلیت Markdown
□ لیست تمپلیت‌ها بر اساس نوع (CV/Cover Letter/Email)
□ پیش‌نمایش تمپلیت
□ حذف تمپلیت
🔵 فاز ۶: داشبورد و لیست اپلیکیشن‌ها
بلوک B34: داشبورد
پیش‌نیاز: B32 ✅

فایل‌های تغییری:

text

[F012] src/app/[locale]/dashboard/page.tsx
تست تأیید:

text

□ خلاصه تعداد اپلیکیشن‌ها
□ وضعیت سی‌وی جامع (کامل/ناقص)
□ دسترسی سریع به New Application
□ لیست آخرین اپلیکیشن‌ها
بلوک B35: لیست و جزئیات اپلیکیشن‌ها
پیش‌نیاز: B34 ✅

فایل‌های تغییری:

text

[F017] src/app/[locale]/applications/page.tsx
[F018] src/app/[locale]/applications/[id]/page.tsx
تست تأیید:

text

□ لیست تمام اپلیکیشن‌ها با وضعیت
□ کلیک → صفحه جزئیات
□ در صفحه جزئیات: مشاهده و دانلود مجدد فایل‌ها
🔵 فاز ۷: احراز هویت Google (فاز نهایی)
بلوک B36: پیاده‌سازی Google OAuth
پیش‌نیاز: تمام بلوک‌های قبلی ✅

فایل‌های تغییری:

text

[F011] src/app/[locale]/page.tsx (جایگزینی لاگین موقت با Google)
[F065] src/lib/supabase/middleware.ts
[F030] src/middleware.ts (به‌روزرسانی)
تنظیمات Supabase:

فعال‌سازی Google Provider در Supabase Authentication
تنظیم OAuth Credentials از Google Cloud Console
تنظیم Redirect URLs
تست تأیید:

text

□ دکمه "Login with Google" نمایش داده می‌شود
□ کلیک → ریدایرکت به Google → برگشت به اپلیکیشن
□ اطلاعات کاربر از Google دریافت و در Supabase ذخیره می‌شود
□ RLS Policies بر اساس auth.uid() به‌روزرسانی شده
□ هر کاربر فقط داده‌های خودش را می‌بیند
□ لاگ‌اوت صحیح کار می‌کند
□ کاربر لاگین نشده به صفحات محافظت‌شده دسترسی ندارد
بلوک B37: به‌روزرسانی RLS Policies
پیش‌نیاز: B36 ✅

اسکریپت SQL:

SQL

-- Drop development policies
-- Create production policies based on auth.uid()
-- Each user can only access their own data
تست تأیید:

text

□ کاربر A نمی‌تواند داده‌های کاربر B را ببیند
□ کاربر غیرمجاز به API routes دسترسی ندارد
□ تمام CRUD operations با user filtering کار می‌کنند
🔵 فاز ۸: تست نهایی و دیپلوی
بلوک B38: تست سرتاسری نهایی
پیش‌نیاز: B37 ✅

تست‌ها:

text

□ لاگین با Google → داشبورد
□ آپلود سی‌وی → تکمیل فیلدهای ناقص → ذخیره
□ افزودن API Key → تست اتصال → نمایش مدل‌ها
□ ایجاد پرامپت جدید
□ فرایند کامل New Application (حالت تک‌AI)
□ فرایند کامل New Application (حالت چند‌AI)
□ ویرایش خروجی → دانلود Word و Markdown
□ تغییر زبان UI (EN↔FA) در تمام صفحات
□ تمام ۸ زبان خروجی تست شوند
□ تمام لحن‌ها تست شوند
□ ریسپانسیو بودن در موبایل
□ RTL در فارسی
بلوک B39: دیپلوی روی Vercel
پیش‌نیاز: B38 ✅

مراحل:

text

1. Push to GitHub
2. Connect Vercel to GitHub repo
3. Set Environment Variables in Vercel:
   - NEXT_PUBLIC_SUPABASE_URL
   - NEXT_PUBLIC_SUPABASE_ANON_KEY
   - ENCRYPTION_SECRET_KEY
4. Deploy
5. Update Supabase Auth redirect URLs for production domain
6. Test on production URL
تست تأیید:

text

□ سایت روی دامنه Vercel قابل دسترسی
□ لاگین Google روی production کار می‌کند
□ تمام عملکردها روی production تست شده
سند شماره ۳: قوانین اجرایی برای ایجنت (Agent Rules)
این قوانین باید در هر پرامپت به ایجنت داده شوند

Markdown

## MANDATORY RULES FOR EVERY BLOCK:

1. NEVER reference a file that doesn't exist yet. Check the Status Tracker.
2. NEVER import from a module you haven't created in a previous block.
3. ONLY work on files listed in the current block's file list.
4. After completing a block, LIST all files you created/modified with their full paths.
5. If you're unsure about something, ASK — don't guess.
6. Every component must support both 'en' and 'fa' locales.
7. Every component must handle RTL for 'fa' locale.
8. Use ONLY the types defined in [F079] src/lib/types.ts.
9. Use ONLY the constants defined in [F078] src/lib/constants.ts.
10. Do NOT skip the Checkpoint tests. List each test and its pass/fail status.
11. Do NOT modify files from previous blocks unless explicitly stated.
12. Keep each file under 200 lines. Split if necessary.
13. All API routes must handle errors gracefully with proper HTTP status codes.
14. All user-facing text must come from i18n files [F087] and [F088].
سند شماره ۴: فرمت پرامپت برای هر بلوک
هر بار که بلوکی به ایجنت داده می‌شود، این فرمت استفاده شود

Markdown

# BLOCK [B__]: [Block Name]

## CONTEXT
You are building a web application called "CV Tailor".
Technology: Next.js, TypeScript, Tailwind CSS, Supabase, Vercel.

## CURRENT PROJECT STATE
The following blocks have been completed:
- B01 ✅: [list of files created]
- B02 ✅: [list of files created]
- ...
- B[N-1] ✅: [list of files created]

## YOUR TASK
[Paste the specific block content from this document]

## FILES YOU MUST CREATE/MODIFY
[Exact file list from the block]

## FILES YOU MAY IMPORT FROM (already exist)
[List of relevant existing files]

## FILES YOU MUST NOT TOUCH
[Everything not in your file list]

## CHECKPOINT TESTS
After completing this block, verify:
[Paste the checkpoint tests from the block]

## RULES
[Paste the Agent Rules from Document #3]
نمودار وابستگی بلوک‌ها (Dependency Graph)
text

B01 → B02 → B03 → B04 → B05 → B06 → B07 → B08
                    │                    │
                    │                    ├→ B09 → B10 → B11 → B12 → B13 → B14
                    │                    │
                    │                    ├→ B15 → B16 → B17
                    │                    │
                    ├→ B18 → B19 → B20 → B21 → B22 → B23
                    │                    │
                    │                    ├→ B26 → B27
                    │                    │
                    ├→ B28                │
                    │                    │
                    ├→ B29 → B30        │
                    │    │              │
                    │    └→ B33        │
                    │                  │
                    ├→ B24 → B25      │
                    │                  │
                    └───── B31 ←──────┘
                            │
                            ▼
                    B32 (Main Integration)
                            │
                    B34 → B35
                            │
                    B36 → B37
                            │
                    B38 → B39
خلاصه اجرایی
شماره	اقدام	هدف
۱	Master Blueprint	ایجنت همیشه بداند چه فایلی کجاست و چه چیزی ساخته شده
۲	بلوک‌های اتمیک	هر بار فقط یک کار کوچک و مشخص انجام شود
۳	Checkpoint Tests	بعد از هر بلوک، صحت تأیید شود قبل از رفتن به بلوک بعد
۴	شماره ردیابی فایل‌ها	هر فایل یک ID دارد تا ایجنت گم نشود
۵	نمودار وابستگی	ایجنت بداند چه بلوک‌هایی باید قبلاً ساخته شده باشند
۶	Agent Rules	قوانین سفت و سخت برای جلوگیری از توهم
۷	فرمت استاندارد پرامپت	هر بار اطلاعات زمینه‌ای کامل به ایجنت داده شود
۸	Status Tracker	وضعیت هر بلوک ثبت و به‌روز شود
با این سیستم، ایجنت در هر لحظه فقط یک بلوک کوچک و مشخص پیش رو دارد، دقیقاً می‌داند چه فایل‌هایی وجود دارند، از چه چیزی می‌تواند import کند، و چه چیزی باید تولید کند.





این نرم افزار باید توسط ایجنت antigravity نوشته شود بنابراین وجود یک نقشه راه بسیار مشخص و دقیق که ایجنت را مجبور کند به صورت مرحله به مرحله بدون توهم زدن با کنترل کیفی مناسب و بدون گیج شدن و گم گردن مختصات واقعی همه اجزا پروژه آن را بنویسد بسیار مهم است. حالا بگو برای این کار چه طرحی میتوان پیاده کرد که این اهداف محقق شود. ترجیح میدهم

claude-opus-4-6-thinking

Thought for 5 seconds

مستند مشخصات فنی و عملکردی نرم‌افزار (Software Specification Document)
برای استفاده به‌عنوان پرامپت حرفه‌ای جهت تولید نرم‌افزار توسط AI Agent
۱. مشخصات کلی پروژه (General Project Specifications)
۱.۱ پلتفرم و تکنولوژی
نوع پلتفرم: وب‌اپلیکیشن (Web Application)
فریمورک: Next.js
هاستینگ / دیپلوی: Vercel
دیتابیس: Supabase
احراز هویت: Google Authentication (از طریق Supabase Auth)
۱.۲ زبان رابط کاربری (UI Language)
نرم‌افزار باید دوزبانه باشد: انگلیسی و فارسی
کاربر باید بتواند زبان رابط کاربری را از طریق یک گزینه انتخابی (Language Selector) تغییر دهد
تمام منوها، دکمه‌ها، پیام‌ها، راهنماها و لیبل‌ها باید در هر دو زبان موجود باشند
چینش صفحه باید بر اساس زبان انتخاب‌شده تنظیم شود (RTL برای فارسی، LTR برای انگلیسی)
۲. احراز هویت و مدیریت کاربران (Authentication & User Management)
۲.۱ روش احراز هویت
احراز هویت منحصراً از طریق حساب Google انجام می‌شود
پیاده‌سازی از طریق Supabase Authentication با Provider گوگل
پس از لاگین، پروفایل کاربر در دیتابیس Supabase ذخیره می‌شود
۲.۲ ⚠️ ترتیب توسعه احراز هویت (مهم)
ماژول احراز هویت با گوگل باید در آخرین فاز توسعه پیاده‌سازی شود
در طول فرایند توسعه، از یک مکانیزم ساده لاگین موقت (مثلاً ورود با ایمیل/پسورد ساده یا بدون احراز هویت) استفاده شود تا فرایند توسعه دچار اختلال نشود
در فاز نهایی، سیستم لاگین موقت با Google OAuth جایگزین شود
۳. مدیریت کلیدهای API هوش مصنوعی (AI API Key Management)
۳.۱ ورود و ذخیره کلیدها
نرم‌افزار باید یک صفحه تنظیمات داشته باشد که کاربر بتواند API Key سرویس‌های مختلف هوش مصنوعی را وارد و ذخیره کند
API Key‌ها باید به‌صورت امن و رمزگذاری‌شده در دیتابیس Supabase ذخیره شوند
سرویس‌های هوش مصنوعی پشتیبانی‌شده شامل (ولی نه محدود به):
OpenAI (GPT-4, GPT-4o, GPT-4o-mini, و سایر مدل‌ها)
Anthropic (Claude Sonnet, Claude Opus, Claude Haiku, و سایر مدل‌ها)
Google AI (Gemini Pro, Gemini Ultra, و سایر مدل‌ها)
و هر سرویس دیگری که بعداً اضافه شود
۳.۲ اعتبارسنجی و نمایش مدل‌ها
پس از ورود هر API Key، نرم‌افزار باید:
اتصال به سرویس هوش مصنوعی را تست کند و وضعیت اتصال (متصل/قطع) را نمایش دهد
موجودی توکن / اعتبار باقیمانده را (در صورت پشتیبانی API) بررسی و نمایش دهد
لیست مدل‌های در دسترس آن سرویس هوش مصنوعی را دریافت و به کاربر نمایش دهد
فقط مدل‌هایی که کلید معتبر و متصل دارند، برای انتخاب کاربر قابل دسترسی باشند
۳.۳ ساختار انتخاب هوش مصنوعی توسط کاربر
الگوی انتخاب به‌صورت زیر باشد:
text

[انتخاب سرویس AI] → [انتخاب مدل] → [انتخاب نقش: Draft (پیش‌نویس) | Final (نهایی)]
کاربر مشخص می‌کند که آیا هوش مصنوعی انتخاب‌شده برای مرحله Draft (پیش‌نویس‌سازی) استفاده شود یا برای مرحله Final (تولید خروجی نهایی)
۳.۴ حالت خاص: استفاده ترکیبی از چند هوش مصنوعی
کاربر باید بتواند یک یا چند هوش مصنوعی مختلف را برای مرحله Draft انتخاب کند
و سپس یک هوش مصنوعی متفاوت را برای مرحله Final تعیین کند
در این حالت، خروجی‌های مرحله Draft از AI‌های مختلف جمع‌آوری شده و به‌عنوان ورودی به AI مرحله Final داده می‌شود
۴. مدیریت پرامپت‌ها (Prompt Management) — قلب سیستم
۴.۱ پرامپت‌های از پیش آماده (Pre-built Prompts)
قلب تپنده این نرم‌افزار مجموعه‌ای از پرامپت‌های آماده است
این پرامپت‌ها در داخل سیستم ذخیره می‌شوند (در دیتابیس Supabase)
هر پرامپت شامل:
عنوان پرامپت (به دو زبان فارسی و انگلیسی)
توضیح کوتاه درباره عملکرد پرامپت (به دو زبان)
متن کامل پرامپت (دستورالعملی که به هوش مصنوعی ارسال می‌شود)
دسته‌بندی (Category)
وضعیت فعال/غیرفعال
۴.۲ انتخاب پرامپت توسط کاربر
کاربر از لیست پرامپت‌های موجود، یک یا چند پرامپت را انتخاب می‌کند
پرامپت انتخاب‌شده مشخص می‌کند که خروجی بر اساس چه الزامات و معیارهایی تدوین شود
۴.۳ مدیریت پرامپت‌ها بدون کدنویسی (No-Code Prompt Management)
نرم‌افزار باید یک پنل مدیریت پرامپت داشته باشد
از طریق این پنل بتوان بدون هیچ کدنویسی:
پرامپت جدید اضافه کرد
پرامپت‌های موجود را ویرایش کرد
پرامپت‌ها را حذف یا غیرفعال کرد
ترتیب و دسته‌بندی پرامپت‌ها را تغییر داد
این پنل باید دارای یک ویرایشگر متنی مناسب برای نوشتن و ویرایش متن پرامپت باشد
۵. مدیریت سی‌وی جامع کاربر (Comprehensive CV Management)
۵.۱ ورود سی‌وی جامع
کاربر باید بتواند سی‌وی جامع و کامل خود را وارد سیستم کند
فرمت‌های قابل قبول برای ورود سی‌وی:
فایل Word (.docx)
فایل Markdown (.md)
ورود مستقیم متنی در یک فرم ساختاریافته
۵.۲ استخراج و تکمیل فیلدهای الزامی
نرم‌افزار باید فیلدهای الزامی استاندارد یک سی‌وی حرفه‌ای را تعریف‌شده داشته باشد، از جمله:

اطلاعات شخصی (نام، ایمیل، تلفن، لوکیشن، لینکدین، وب‌سایت)
خلاصه حرفه‌ای (Professional Summary)
سوابق کاری (Work Experience)
تحصیلات (Education)
مهارت‌ها (Skills)
گواهینامه‌ها و دوره‌ها (Certifications)
زبان‌ها (Languages)
پروژه‌ها (Projects)
و سایر بخش‌های مرتبط
پس از ورود سی‌وی جامع، نرم‌افزار باید:

فیلدهای الزامی را از سی‌وی استخراج و شناسایی کند
بخش‌های ناقص یا خالی را تشخیص دهد
از کاربر بخواهد که بخش‌های ناقص را تکمیل کند
اطلاعات تکمیل‌شده توسط کاربر را به سی‌وی جامع اضافه کند و سی‌وی جامع را به‌روزرسانی کند
۶. فرایند اصلی کار (Core Workflow)
۶.۱ ورودی‌های فرایند
فرایند اصلی با سه ورودی کلیدی شروع می‌شود:

ورودی	توضیح
۱. پرامپت انتخاب‌شده	پرامپت(های) انتخابی کاربر از لیست پرامپت‌های آماده سیستم
۲. سی‌وی جامع کاربر	سی‌وی کامل و جامعی که کاربر قبلاً وارد سیستم کرده
۳. شرح شغل (Job Description)	متن شرح شغلی که کاربر می‌خواهد برای آن اقدام کند
۶.۲ تنظیمات اضافی قبل از شروع
قبل از شروع فرایند، کاربر تنظیمات زیر را مشخص می‌کند:

انتخاب سرویس AI و مدل (برای Draft و/یا Final)
انتخاب زبان خروجی فایل‌ها
انتخاب لحن پاسخ هوش مصنوعی (Tone of Response):
به‌صورت گزینه‌های قابل انتخاب از پیش تعریف‌شده (مثلاً: رسمی، نیمه‌رسمی، دوستانه، حرفه‌ای، خلاقانه و...)
یا به‌صورت شرح کتبی آزاد که کاربر خودش لحن مورد نظرش را توصیف می‌کند
هر دو گزینه باید در دسترس باشد و کاربر یکی را انتخاب کند
۶.۳ جریان پردازش (Processing Flow)
text

مرحله ۱: جمع‌آوری ورودی‌ها
    ↓
کاربر پرامپت را انتخاب می‌کند
    + سی‌وی جامع موجود است
    + شرح شغل را وارد می‌کند
    + تنظیمات (AI, زبان, لحن) را مشخص می‌کند
    ↓
مرحله ۲: ارسال به هوش مصنوعی
    ↓
پرامپت انتخاب‌شده + سی‌وی جامع + شرح شغل + تنظیمات لحن
    → ارسال به مدل هوش مصنوعی انتخاب‌شده
    ↓
مرحله ۳: بررسی و پرسش (Clarification Loop)
    ↓
هوش مصنوعی داده‌ها را بر اساس الزامات پرامپت بررسی می‌کند
    → اگر سوالی دارد ← سوال را از کاربر می‌پرسد
        ← کاربر پاسخ می‌دهد
        ← پاسخ کاربر + تمام داده‌های قبلی (پرامپت + سی‌وی + شرح شغل)
           مجدداً آنالیز می‌شود
        ← (این حلقه تا رفع تمام ابهامات ادامه می‌یابد)
    → اگر سوالی ندارد ← به مرحله بعد می‌رود
    ↓
مرحله ۴: تولید خروجی اولیه
    ↓
هوش مصنوعی یک خروجی اولیه (Draft) تولید می‌کند
    ↓
مرحله ۵: ویرایش توسط کاربر
    ↓
خروجی اولیه در یک **ویرایشگر متنی (Rich Text Editor)** به کاربر نمایش داده می‌شود
    → کاربر می‌تواند خروجی را ویرایش کند
    → کاربر خروجی (ویرایش‌شده یا بدون تغییر) را تأیید می‌کند
    ↓
مرحله ۶: تولید ۳ سند نهایی
    ↓
پس از تأیید کاربر، سیستم ۳ سند زیر را تولید می‌کند:
۶.۴ سه خروجی نهایی
سند	توضیح
۱. سی‌وی اختصاصی (Tailored CV)	یک سی‌وی جدید که بر اساس شرح شغل مورد نظر، از سی‌وی جامع کاربر بازنویسی و بهینه‌سازی شده است
۲. کاورلتر اختصاصی (Tailored Cover Letter)	یک نامه معرفی اختصاصی که مخصوص آن شغل خاص نوشته شده است
۳. ایمیل اپلای (Application Email)	متن ایمیلی آماده ارسال برای اپلای در آن شغل
۶.۵ حالت ترکیبی چند AI (Multi-AI Mode)
در حالت خاص:

کاربر یک یا چند AI مختلف را برای مرحله Draft انتخاب می‌کند
هر AI انتخاب‌شده، خروجی Draft خود را تولید می‌کند
تمام خروجی‌های Draft به‌همراه داده‌های اولیه (پرامپت + سی‌وی + شرح شغل) به AI مرحله Final ارسال می‌شود
AI نهایی، بر اساس تمام Draft‌ها، خروجی نهایی را تولید می‌کند
۷. مدیریت قالب‌ها / تمپلیت‌ها (Template Management)
۷.۱ ورود قالب‌ها
نرم‌افزار باید قابلیت دریافت تمپلیت‌های مختلف را داشته باشد
فرمت‌های قابل قبول برای قالب‌ها:
فایل Word (.docx)
فایل Markdown (.md)
کاربر بتواند تمپلیت‌های مختلف برای هر یک از سه خروجی (CV, Cover Letter, Email) آپلود کند
۷.۲ استفاده از قالب‌ها
هنگام تولید خروجی نهایی، کاربر بتواند قالب مورد نظرش را انتخاب کند
خروجی بر اساس ساختار و فرمت قالب انتخاب‌شده تولید شود
۸. فرمت خروجی فایل‌ها (Output File Formats)
۸.۱ فرمت‌های خروجی
هر یک از سه سند نهایی باید در دو فرمت قابل دانلود باشد:

فایل Word (.docx) — فرمت‌بندی‌شده و آماده استفاده
فایل Markdown (.md)
۸.۲ انتخاب زبان خروجی فایل‌ها
کاربر باید بتواند زبان خروجی فایل‌ها را انتخاب کند
زبان‌های پشتیبانی‌شده:
انگلیسی (English)
فارسی (Persian/Farsi)
فرانسوی (French)
آلمانی (German)
اسپانیایی (Spanish)
عربی (Arabic)
چینی (Chinese)
ترکی (Turkish)
(مجموعاً ۷ زبان زنده دنیا + فارسی = ۸ زبان)

زبان خروجی مستقل از زبان رابط کاربری است (مثلاً رابط کاربری فارسی باشد ولی خروجی فایل‌ها به آلمانی تولید شود)
۹. قابلیت ویرایش خروجی (Output Editing)
۹.۱ ویرایشگر داخلی
پس از تولید هر خروجی توسط AI، محتوا در یک ویرایشگر متنی ریچ (Rich Text Editor) نمایش داده شود
کاربر بتواند:
متن را ویرایش کند
ساختار را تغییر دهد
بخش‌هایی را اضافه یا حذف کند
۹.۲ ذخیره نسخه ویرایش‌شده
پس از اتمام ویرایش، کاربر نسخه نهایی ویرایش‌شده را تأیید می‌کند
نسخه ویرایش‌شده به‌صورت فایل (Word و Markdown) برای دانلود ارائه می‌شود
۱۰. ساختار دیتابیس پیشنهادی (Database Schema - Supabase)
text

جداول اصلی:

1. users
   - id, google_id, email, name, avatar_url, preferred_language, created_at, updated_at

2. comprehensive_cvs
   - id, user_id, full_content, personal_info (JSON), work_experience (JSON),
     education (JSON), skills (JSON), certifications (JSON), languages (JSON),
     projects (JSON), additional_sections (JSON), created_at, updated_at

3. prompts
   - id, title_en, title_fa, description_en, description_fa, prompt_text,
     category, is_active, sort_order, created_at, updated_at

4. ai_api_keys
   - id, user_id, provider_name, api_key_encrypted, is_valid,
     available_models (JSON), last_validated_at, created_at, updated_at

5. templates
   - id, user_id, template_name, template_type (cv/cover_letter/email),
     file_format (docx/md), file_content, created_at, updated_at

6. job_applications
   - id, user_id, job_description, selected_prompt_ids (JSON),
     selected_ai_draft (JSON), selected_ai_final (JSON),
     output_language, tone_setting, tone_custom_text,
     ai_questions (JSON), user_answers (JSON),
     draft_output, final_output_cv, final_output_cover_letter,
     final_output_email, edited_output_cv, edited_output_cover_letter,
     edited_output_email, status, created_at, updated_at
۱۱. ساختار صفحات و رابط کاربری (UI Structure)
text

صفحات اصلی:

1. صفحه لندینگ / لاگین
   ├── انتخاب زبان رابط کاربری (فارسی / انگلیسی)
   └── دکمه ورود با گوگل

2. داشبورد اصلی (Dashboard)
   ├── خلاصه وضعیت
   ├── دسترسی سریع به ایجاد اپلیکیشن جدید
   └── لیست اپلیکیشن‌های قبلی

3. مدیریت سی‌وی جامع (My Comprehensive CV)
   ├── آپلود سی‌وی (Word / Markdown / ورود دستی)
   ├── نمایش فیلدهای استخراج‌شده
   ├── هایلایت بخش‌های ناقص
   └── فرم تکمیل بخش‌های ناقص

4. ایجاد اپلیکیشن جدید (New Application)
   ├── وارد کردن شرح شغل (Job Description)
   ├── انتخاب پرامپت(ها) از لیست
   ├── انتخاب AI و مدل (Draft / Final)
   ├── انتخاب زبان خروجی
   ├── انتخاب لحن (گزینه‌ای یا شرح کتبی)
   ├── انتخاب تمپلیت (اختیاری)
   ├── شروع پردازش
   ├── صفحه پرسش و پاسخ با AI (در صورت نیاز)
   ├── نمایش خروجی اولیه + ویرایشگر
   ├── تأیید و تولید ۳ سند نهایی
   └── دانلود فایل‌ها (Word / Markdown)

5. مدیریت پرامپت‌ها (Prompt Management)
   ├── لیست پرامپت‌ها
   ├── افزودن پرامپت جدید
   ├── ویرایش پرامپت
   ├── حذف / غیرفعال‌سازی پرامپت
   └── دسته‌بندی پرامپت‌ها

6. تنظیمات (Settings)
   ├── مدیریت API Key‌ها
   │   ├── افزودن کلید جدید
   │   ├── تست اتصال
   │   ├── نمایش مدل‌های در دسترس
   │   └── نمایش وضعیت اعتبار / توکن
   ├── مدیریت تمپلیت‌ها
   ├── تنظیمات زبان رابط کاربری
   └── تنظیمات پروفایل
۱۲. فازبندی توسعه (Development Phases)
text

فاز ۱: زیرساخت و ساختار پایه
  ├── راه‌اندازی پروژه Next.js
  ├── ساختار پوشه‌ها و فایل‌ها
  ├── اتصال به Supabase
  ├── ایجاد جداول دیتابیس
  ├── پیاده‌سازی سیستم دوزبانه (i18n)
  ├── لاگین موقت (بدون Google Auth) برای توسعه
  └── دیپلوی اولیه روی Vercel

فاز ۲: مدیریت سی‌وی جامع
  ├── فرم ورود سی‌وی
  ├── آپلود فایل Word و Markdown
  ├── پارس و استخراج فیلدها
  ├── شناسایی بخش‌های ناقص
  ├── فرم تکمیل بخش‌های ناقص
  └── ذخیره و به‌روزرسانی سی‌وی جامع

فاز ۳: مدیریت پرامپت‌ها
  ├── CRUD پرامپت‌ها (بدون کدنویسی)
  ├── دسته‌بندی
  ├── ویرایشگر متنی
  └── فعال/غیرفعال‌سازی

فاز ۴: مدیریت API Key و اتصال به AI‌ها
  ├── فرم ورود API Key
  ├── رمزگذاری و ذخیره
  ├── تست اتصال
  ├── دریافت لیست مدل‌ها
  ├── پیاده‌سازی کانکتورهای AI مختلف
  └── نمایش وضعیت اتصال و موجودی

فاز ۵: فرایند اصلی (Core Workflow)
  ├── صفحه ایجاد اپلیکیشن جدید
  ├── انتخاب پرامپت + ورود شرح شغل
  ├── انتخاب AI/مدل (Draft/Final)
  ├── انتخاب زبان خروجی
  ├── تنظیم لحن
  ├── ارسال به AI و دریافت پاسخ
  ├── حلقه پرسش و پاسخ (Clarification Loop)
  ├── پشتیبانی از حالت Multi-AI
  ├── نمایش خروجی + ویرایشگر
  └── تولید ۳ سند نهایی

فاز ۶: مدیریت قالب‌ها و خروجی فایل
  ├── آپلود تمپلیت (Word / Markdown)
  ├── تولید فایل Word فرمت‌شده
  ├── تولید فایل Markdown
  ├── اعمال تمپلیت بر خروجی
  └── دانلود فایل‌ها

فاز ۷: احراز هویت Google (فاز نهایی)
  ├── پیاده‌سازی Google OAuth از طریق Supabase
  ├── جایگزینی لاگین موقت با Google Auth
  ├── تست کامل فرایند لاگین
  └── مدیریت سشن و امنیت
۱۳. نکات فنی مهم (Technical Requirements)
۱۳.۱ امنیت
API Key‌ها باید رمزگذاری‌شده ذخیره شوند
ارتباط با APIهای هوش مصنوعی باید از سمت سرور (Server-Side / API Routes) انجام شود نه از سمت کلاینت
Row Level Security (RLS) در Supabase فعال باشد تا هر کاربر فقط به داده‌های خودش دسترسی داشته باشد
۱۳.۲ عملکرد
درخواست‌های AI باید به‌صورت Streaming پیاده‌سازی شوند تا کاربر منتظر نماند و خروجی به‌تدریج نمایش داده شود
فایل‌های آپلودی باید محدودیت حجم داشته باشند
۱۳.۳ قابلیت توسعه
معماری کد باید به‌گونه‌ای باشد که افزودن سرویس هوش مصنوعی جدید بدون تغییر ساختار کلی ممکن باشد (الگوی Adapter/Provider)
افزودن زبان‌های جدید به رابط کاربری یا خروجی فایل‌ها بدون تغییر ساختار کلی ممکن باشد
۱۳.۴ رابط کاربری
طراحی ریسپانسیو (واکنش‌گرا) برای موبایل، تبلت و دسکتاپ
پشتیبانی کامل از RTL برای زبان فارسی
استفاده از یک کتابخانه UI مناسب (مثل Tailwind CSS + shadcn/ui یا مشابه)
۱۴. خلاصه فنی نهایی (Technical Stack Summary)
مورد	تکنولوژی
فریمورک	Next.js (App Router)
زبان برنامه‌نویسی	TypeScript
استایل‌دهی	Tailwind CSS
کامپوننت UI	shadcn/ui (پیشنهادی)
دیتابیس	Supabase (PostgreSQL)
احراز هویت	Supabase Auth + Google Provider
هاستینگ	Vercel
تولید فایل Word	docx library (یا مشابه)
پارس فایل Word	mammoth.js (یا مشابه)
پارس/تولید Markdown	remark / markdown-it (یا مشابه)
ویرایشگر متنی	TipTap / Lexical (یا مشابه)
دوزبانه	next-intl / react-i18next (یا مشابه)
اتصال به AI‌ها	OpenAI SDK, Anthropic SDK, Google AI SDK
تذکر نهایی: تمام موارد بالا دقیقاً از خواسته‌های اعلام‌شده استخراج شده‌اند. هیچ موردی حذف نشده و هیچ ویژگی خارج از محدوده خواسته‌ها اضافه نشده است. در موارد انتخاب تکنولوژی‌های جزئی (مانند کتابخانه UI یا ویرایشگر)، پیشنهاد داده شده ولی با عبارت «یا مشابه» انعطاف‌پذیری حفظ شده است.





من میخوام یک نرم افزار بنویسم
زبان برنامه انکلیسی و فارسی باشد یعنی بشه یکی رو انتخاب کرد.
میخوام پلت فرمم وب باشه و از تکنولوژی nj استفاده کنم
سایت رو روی ویرسیل بالا خواهم اورذ
از گوگل برای احراز هویت و لاگین استفاده میشود دیتا بیس روی سوپابیس خواهد بود ولی این مرحله لاگین با گوگل در اخرین فاز توسعه اجرایی شود تا در فرایند توسعه مشکل ایجاد نکند
قلب این نرم افزار یک سری پرومپت است که قابلیت انتخاب خواهند داشت
براساس اون پرومپت سی وی جامع که فرد داده و شرح یک شغل میره در یک مدل هوش مصنوعی و هوش مصنوعی براساس الزامات ان پرومپت و سی وی و شرح کاری که دریافت میکنه بررسی میکنه و اگر سوالی داشته باشد از فرد میپرسد اگر فرد جواب داد جواب سوال بعلاوه داده های قبلی از جمله پرومپت و سی وی و شرح شغل رو انالیز میکنه و یک خروجی قابل ویرایش میده و بعد تایید ۳ تا مدرک درست میکنه اولی یک سی وی جدید برای ان شغل خاص دومی یک کاور لتر اختصاصی ان شغل و سومی یک ایمیل اپلای است
نرم افزار باید توانایی استفاده از api هوش مصنوعی های مختلف و مدلهای مختلف آن هوش مصنوعی را داشته باشد و با انتخاب کاربر برای ان کار استفاده کند
در یک حالت خاص کارمند میتواند از یک یا چند هوش مصنوعی برای درفت کردن استفاده کند و نهایتا مرحله اخر کار را به یک هوش مصنوعی دیگر بسپارد
باید توانایی خروجی دادن به صورت فایل ورد فرمت شده و فایل مارک داون را داشته باشد
باید قابلیت قبول فرمت مارک داون فایل ورذ را داشته باشد. یعنی بشود بهش تمپلت های مختلف را داد.
باید قابلیت انتخاب زبان خروجی فایلها را داشته باشد. ۷ زبان زنده دنیا و فارسی.
قلب تپنده این مجموعه پرومپتهای اماده ای است که هر فرد انتخاب میکند تا خروجی براساس ان تدوین شود.این پرومپتها در داخل سیستم قرار میگیرند.
نرم افزار بایستی قابلیت ویرایش خروجی را به کاربر بدهد وبعد نسخه ویرایش شده را به صورت فایل ارایه دهد
نرم افزار بایستی قابلیت گرفتن پرمپت و ذخیره ان راداشته باشد به گونه ای که بعدا بتوان بدون کد نویسی به ان پرومپت داد
برای انتخاب هوش مصنوعی ها نرم افزار باید قابلیت گرفتن API کلید خر هوش مصنوعی و ذخیره را داشته باشد و براستس کلیدها و بازخورد هوش مصنوعی از وصل بودن و داشتن توکن مدلهای در دسترس هوش مصنوعی ها را برای انتخاب به کاربر ارایه دهد
الگوی ارایه به صورت هوش مصنوعی و مدل برای درفت یا برای گزینه نهایی خواهد بود یعنی خود کاربر انتخاب میکند که میخواهد درفت انجام دهد یا نسخه نهایی
فیلدهای الزامی یک سی وی بایستی از سی وی کل کاربر استخراج شود و تکمیل شود و از کاربر خواسته شود که قسمتهای ناقص را تکمیل کند و این قسمتهای تکمیل شده به سی وی جامع کاربر افزوده شود.
لحن پاسخ هوش مصنوعی به صورت گزینه خای قابل انتخاب یا به صورت شرح کتبی باید دردسترس کاربر باشد.

حالا میخوام یک شرح مرتب و با جزییات و بدون حذف از این توصیفات برای نوشتن یک پرومپت حرفه ای توسط یک هوش مصنوعی برای اجرا توسط یک ایجنت تولید کننده نرم افزار بنویسی و چیزی را از قلم نندازی و توهم نزنی

Ask followup…




Inputs are processed by third-party AI and responses may be inaccurate.

Arena | Benchmark & Compare the Best AI Models
